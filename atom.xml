<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛洛爱吃肉</title>
  
  <subtitle>学海无涯,进一步有进一步的欢喜.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-27T06:19:52.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>loirou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/27/计算机网络/网络常见面试题/</id>
    <published>2017-10-27T06:19:52.000Z</published>
    <updated>2017-10-27T06:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵子把《图解http》、《图解tcp/ip》、《计算机网络》都看了看,整理点常见的面试题吧。</p><h3 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h3><p><img src="http://upload-images.jianshu.io/upload_images/1868951-fe03a1158d8c4e6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络体系结构.png"></p><h3 id="中继系统的一些疑问？"><a href="#中继系统的一些疑问？" class="headerlink" title="中继系统的一些疑问？"></a><a href="https://www.zhihu.com/question/51403704/answer/125927499" target="_blank" rel="external">中继系统的一些疑问？</a></h3><h3 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h3><p>主要是以下几个方面的区别:</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">TCP</th><th style="text-align:center">UDP</th></tr></thead><tbody><tr><td style="text-align:center">可靠性</td><td style="text-align:center">可靠</td><td style="text-align:center">不可靠</td></tr><tr><td style="text-align:center">连接性</td><td style="text-align:center">面向连接</td><td style="text-align:center">无连接</td></tr><tr><td style="text-align:center">报文</td><td style="text-align:center">面向字节流</td><td style="text-align:center">面向报文</td></tr><tr><td style="text-align:center">效率</td><td style="text-align:center">传输效率低</td><td style="text-align:center">传输效率高</td></tr><tr><td style="text-align:center">双工性</td><td style="text-align:center">全双工</td><td style="text-align:center">一对一、一对多、多对一、多对多</td></tr><tr><td style="text-align:center">流量控制</td><td style="text-align:center">有(滑动窗口)</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">拥塞控制</td><td style="text-align:center">有(慢开始、拥塞避免、快重传、快恢复)</td><td style="text-align:center">无</td></tr></tbody></table><h3 id="TCP对应的协议和UDP对应的协议"><a href="#TCP对应的协议和UDP对应的协议" class="headerlink" title="TCP对应的协议和UDP对应的协议"></a>TCP对应的协议和UDP对应的协议</h3><p>TCP对应的协议：<br>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。</p><p>UDP对应的协议：<br>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br>（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p><h3 id="简析TCP的三次握手与四次分手"><a href="#简析TCP的三次握手与四次分手" class="headerlink" title="简析TCP的三次握手与四次分手"></a><a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a></h3><h3 id="TCP-为什么是三次握手，为什么不是两次或四次？"><a href="#TCP-为什么是三次握手，为什么不是两次或四次？" class="headerlink" title="TCP 为什么是三次握手，为什么不是两次或四次？"></a><a href="https://www.zhihu.com/question/24853633/answer/115173386" target="_blank" rel="external">TCP 为什么是三次握手，为什么不是两次或四次？</a></h3><h3 id="网络通信过程中，建立连接的本质是什么？"><a href="#网络通信过程中，建立连接的本质是什么？" class="headerlink" title="网络通信过程中，建立连接的本质是什么？"></a><a href="https://www.zhihu.com/question/38483035/answer/106683865" target="_blank" rel="external">网络通信过程中，建立连接的本质是什么？</a></h3><h3 id="从输入网址到显示网页的全过程分析"><a href="#从输入网址到显示网页的全过程分析" class="headerlink" title="从输入网址到显示网页的全过程分析"></a><a href="http://www.itmian4.com/forum.php?mod=viewthread&amp;tid=1655&amp;fromuid=1931" target="_blank" rel="external">从输入网址到显示网页的全过程分析</a></h3><ul><li>查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPDNS缓存，根域名服务器</li><li>浏览器向IP对应的web服务器发送一个HTTP请求</li><li>服务器响应请求，发回网页内容</li><li>浏览器解析网页内容</li></ul><h3 id="常见端口号"><a href="#常见端口号" class="headerlink" title="常见端口号"></a>常见端口号</h3><p><img src="http://upload-images.jianshu.io/upload_images/1868951-5642f3853c486a3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常见端口号.png"></p><h3 id="TCP协议中的端口具体指的是什么，为什么要有端口，你是怎么理解的？"><a href="#TCP协议中的端口具体指的是什么，为什么要有端口，你是怎么理解的？" class="headerlink" title="TCP协议中的端口具体指的是什么，为什么要有端口，你是怎么理解的？"></a><a href="https://www.zhihu.com/question/22577025/answer/103910378" target="_blank" rel="external">TCP协议中的端口具体指的是什么，为什么要有端口，你是怎么理解的？</a></h3><h3 id="ARP是地址解析协议，简单语言解释一下工作原理"><a href="#ARP是地址解析协议，简单语言解释一下工作原理" class="headerlink" title="ARP是地址解析协议，简单语言解释一下工作原理"></a>ARP是地址解析协议，简单语言解释一下工作原理</h3><p>答:1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。<br>2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。<br>3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。<br>4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。</p><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p><img src="http://upload-images.jianshu.io/upload_images/1868951-4353e4bffd7a4aec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP地址的分类.png"><br>IPv6 – 采用128bit，首部固定部分为40字节。</p><h3 id="有了-IP-地址，为什么还要用-MAC-地址？"><a href="#有了-IP-地址，为什么还要用-MAC-地址？" class="headerlink" title="有了 IP 地址，为什么还要用 MAC 地址？"></a><a href="https://www.zhihu.com/question/21546408/answer/104113095" target="_blank" rel="external">有了 IP 地址，为什么还要用 MAC 地址？</a></h3><h3 id="HTTP-协议包括哪些请求？"><a href="#HTTP-协议包括哪些请求？" class="headerlink" title="HTTP 协议包括哪些请求？"></a>HTTP 协议包括哪些请求？</h3><pre><code>GET：对服务器资源的简单请求POST：用于发送包含用户提交数据的请求HEAD：类似于GET请求，不过返回的响应中没有具体内容，用于获取报头PUT：传说中请求文档的一个版本DELETE：发出一个删除指定文档的请求TRACE：发送一个请求副本，以跟踪其处理进程OPTIONS：返回所有可用的方法，检查服务器支持哪些方法CONNECT：用于ssl隧道的基于代理的请求</code></pre><h3 id="浅谈HTTP中Get与Post的区别"><a href="#浅谈HTTP中Get与Post的区别" class="headerlink" title="浅谈HTTP中Get与Post的区别"></a><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external">浅谈HTTP中Get与Post的区别</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一阵子把《图解http》、《图解tcp/ip》、《计算机网络》都看了看,整理点常见的面试题吧。&lt;/p&gt;
&lt;h3 id=&quot;网络体系结构&quot;&gt;&lt;a href=&quot;#网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;网络体系结构&quot;&gt;&lt;/a&gt;网络体系结构&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/10/27/hello-world/"/>
    <id>http://yoursite.com/2017/10/27/hello-world/</id>
    <published>2017-10-27T02:28:02.000Z</published>
    <updated>2017-10-27T02:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP案例-信息管理系统</title>
    <link href="http://yoursite.com/2017/05/24/PHP/PHP%E6%A1%88%E4%BE%8B-%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/05/24/PHP/PHP案例-信息管理系统/</id>
    <published>2017-05-24T03:40:00.000Z</published>
    <updated>2017-10-30T05:58:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>– Database: <code>test</code></p><p>– 表的结构 <code>message</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `message` (</div><div class="line">  `id` tinyint(1) NOT NULL PRIMARY KEY AUTO_INCREMENT,</div><div class="line">  `name` varchar(25) NOT NULL,</div><div class="line">  `sex` varchar(50) NOT NULL,</div><div class="line">  `age` tinyint(1) NOT NULL,</div><div class="line">  `classid` tinyint(1) NOT NULL</div><div class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure><h4 id="index-php"><a href="#index-php" class="headerlink" title="index.php"></a>index.php</h4><p><img src="http://upload-images.jianshu.io/upload_images/1868951-37a23780f6c00006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首页"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;学生信息管理&lt;/title&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        function doDel(id) &#123;</div><div class="line">            if (confirm(&quot;确定要删除么？&quot;)) &#123;</div><div class="line">                window.location = &apos;action.php?action=del&amp;id=&apos; + id;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;center&gt;</div><div class="line">    &lt;?php</div><div class="line">    include_once &quot;menu.php&quot;;</div><div class="line">    ?&gt;</div><div class="line">    &lt;h3&gt;浏览学生信息&lt;/h3&gt;</div><div class="line">    &lt;table width=&quot;600&quot; border=&quot;1&quot;&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;th&gt;ID&lt;/th&gt;</div><div class="line">            &lt;th&gt;姓名&lt;/th&gt;</div><div class="line">            &lt;th&gt;性别&lt;/th&gt;</div><div class="line">            &lt;th&gt;年龄&lt;/th&gt;</div><div class="line">            &lt;th&gt;班级&lt;/th&gt;</div><div class="line">            &lt;th&gt;操作&lt;/th&gt;</div><div class="line">        &lt;/tr&gt;</div><div class="line">        &lt;?php</div><div class="line">        //1.连接数据库</div><div class="line">        try &#123;</div><div class="line">            $pdo = new PDO(&quot;mysql:host=localhost;dbname=test;&quot;, &quot;root&quot;, &quot;&quot;);</div><div class="line">        &#125; catch (PDOException $e) &#123;</div><div class="line">            die(&quot;数据库连接失败&quot; . $e-&gt;getMessage());</div><div class="line">        &#125;</div><div class="line">        //2.解决中文乱码问题</div><div class="line">        $pdo-&gt;query(&quot;SET NAMES &apos;UTF8&apos;&quot;);</div><div class="line">        //3.执行sql语句，并实现解析和遍历</div><div class="line">        $sql = &quot;SELECT * FROM message &quot;;</div><div class="line">        foreach ($pdo-&gt;query($sql) as $row) &#123;</div><div class="line">            echo &quot;&lt;tr&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;id&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;name&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;sex&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;age&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;classid&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;</div><div class="line">                    &lt;a href=&apos;javascript:doDel(&#123;$row[&apos;id&apos;]&#125;)&apos;&gt;删除&lt;/a&gt;</div><div class="line">                    &lt;a href=&apos;edit.php?id=(&#123;$row[&apos;id&apos;]&#125;)&apos;&gt;修改&lt;/a&gt;</div><div class="line">                  &lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;/tr&gt;&quot;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ?&gt;</div><div class="line"></div><div class="line">    &lt;/table&gt;</div><div class="line">&lt;/center&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><h4 id="menu-php"><a href="#menu-php" class="headerlink" title="menu.php"></a>menu.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h2&gt;学生管理系统&lt;/h2&gt;</div><div class="line">&lt;a href=&quot;index.php&quot;&gt; 浏览学生&lt;/a&gt;</div><div class="line">&lt;a href=&quot;add.php&quot;&gt; 添加学生&lt;/a&gt;</div><div class="line">&lt;hr&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><h4 id="add-php"><a href="#add-php" class="headerlink" title="add.php"></a>add.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;学生信息管理&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;center&gt;</div><div class="line">    &lt;?php include(&quot;menu.php&quot;); ?&gt;</div><div class="line">    &lt;h3&gt;增加学生信息&lt;/h3&gt;</div><div class="line">    &lt;form method=&quot;post&quot; action=&quot;action.php?action=add&quot;&gt;</div><div class="line"></div><div class="line">        &lt;table&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;姓名&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input  name=&quot;name&quot; type=&quot;text&quot;/&gt;&lt;/td&gt;</div><div class="line"></div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;性别&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;/&gt; 男</div><div class="line">                    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;/&gt; 女</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;年龄&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;班级&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input  name=&quot;classid&quot; type=&quot;text&quot;/&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt; &lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;增加&quot;/&gt;  </div><div class="line">                    &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">        &lt;/table&gt;</div><div class="line"></div><div class="line">    &lt;/form&gt;</div><div class="line">&lt;/center&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1868951-40db8e8dca16bc41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加成功"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6fb2b56d2790f7c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加后"></p><h4 id="edit-php"><a href="#edit-php" class="headerlink" title="edit.php"></a>edit.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;学生信息管理&lt;/title&gt;</div><div class="line"></div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;center&gt;</div><div class="line">    &lt;?php</div><div class="line">    include_once &quot;menu.php&quot;;</div><div class="line">    //1.连接数据库</div><div class="line">    try &#123;</div><div class="line">        $pdo = new PDO(&quot;mysql:host=localhost;dbname=test;&quot;, &quot;root&quot;, &quot;&quot;);</div><div class="line">    &#125; catch (PDOException $e) &#123;</div><div class="line">        die(&quot;数据库连接失败&quot; . $e-&gt;getMessage());</div><div class="line">    &#125;</div><div class="line">    //2.防止中文乱码</div><div class="line">    $pdo-&gt;query(&quot;SET NAMES &apos;UTF8&apos;&quot;);</div><div class="line">    //3.拼接sql语句，取出信息</div><div class="line">    $sql = &quot;SELECT * FROM message WHERE id =&quot; . $_GET[&apos;id&apos;];</div><div class="line">    $stmt = $pdo-&gt;query($sql);//返回预处理对象</div><div class="line">    if ($stmt-&gt;rowCount() &gt; 0) &#123;</div><div class="line">        $stu = $stmt-&gt;fetch(PDO::FETCH_ASSOC);//按照关联数组进行解析</div><div class="line">    &#125; else &#123;</div><div class="line">        die(&quot;没有要修改的数据！&quot;);</div><div class="line">    &#125;</div><div class="line">    ?&gt;</div><div class="line">    &lt;form method=&quot;post&quot; action=&quot;action.php?action=edit&quot;&gt;</div><div class="line"></div><div class="line">        &lt;input type=&quot;hidden&quot; name=&quot;id&quot; id=&quot;id&quot; value=&quot;&lt;?php echo $stu[&apos;id&apos;]; ?&gt;&quot;/&gt;</div><div class="line">        &lt;table&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;姓名&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input id=&quot;name&quot; name=&quot;name&quot; type=&quot;text&quot; value=&quot;&lt;?php echo $stu[&apos;name&apos;] ?&gt;&quot;/&gt;&lt;/td&gt;</div><div class="line"></div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;性别&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; &lt;?php echo ($stu[&apos;sex&apos;] == &quot;男&quot;) ? &quot;checked&quot; : &quot;&quot; ?&gt;/&gt; 男</div><div class="line">                    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; &lt;?php echo ($stu[&apos;sex&apos;] == &quot;女&quot;) ? &quot;checked&quot; : &quot;&quot; ?&gt;/&gt; 女</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;年龄&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; id=&quot;age&quot; value=&quot;&lt;?php echo $stu[&apos;age&apos;] ?&gt;&quot;/&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;班级&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input id=&quot;classid&quot; name=&quot;classid&quot; type=&quot;text&quot; value=&quot;&lt;?php echo $stu[&apos;classid&apos;] ?&gt;&quot;/&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt; &lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;修改&quot;/&gt;  </div><div class="line">                    &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">        &lt;/table&gt;</div><div class="line"></div><div class="line">    &lt;/form&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/center&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><h4 id="action-php"><a href="#action-php" class="headerlink" title="action.php"></a>action.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">//1.连接数据库</div><div class="line">try&#123;</div><div class="line">    $pdo = new PDO(&quot;mysql:host=localhost;dbname=test;&quot;,&quot;root&quot;,&quot;&quot;);</div><div class="line">&#125;catch(PDOException $e)&#123;</div><div class="line">    die(&quot;数据库连接失败&quot;.$e-&gt;getMessage());</div><div class="line">&#125;</div><div class="line"></div><div class="line">//2.通过action的值做地应操作</div><div class="line"></div><div class="line">switch($_GET[&apos;action&apos;])&#123;</div><div class="line">    case &quot;add&quot;://增加操作</div><div class="line">        $name = $_POST[&apos;name&apos;];</div><div class="line">        $sex = $_POST[&apos;sex&apos;];</div><div class="line">        $age = $_POST[&apos;age&apos;];</div><div class="line">        $classid = $_POST[&apos;classid&apos;];</div><div class="line"></div><div class="line">        $sql = &quot;insert into message values(null,&apos;&#123;$name&#125;&apos;,&apos;&#123;$sex&#125;&apos;,&apos;&#123;$age&#125;&apos;,&apos;&#123;$classid&#125;&apos;)&quot;;</div><div class="line">        $rw = $pdo-&gt;exec($sql);</div><div class="line">        if($rw &gt; 0)&#123;</div><div class="line">            echo &quot;&lt;script&gt;alert(&apos;增加成功&apos;);window.location=&apos;index.php&apos;&lt;/script&gt;&quot;;</div><div class="line">        &#125;else&#123;</div><div class="line">            echo &quot;&lt;script&gt;alert(&apos;增加失败&apos;);window.history.back();&lt;/script&gt;&quot;;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case &quot;del&quot;; //删除操作</div><div class="line">        $id = $_GET[&apos;id&apos;];</div><div class="line">        $sql = &quot;delete from message where id=&#123;$id&#125;&quot;;</div><div class="line">        $pdo-&gt;exec($sql);</div><div class="line">        header(&quot;Location:index.php&quot;);</div><div class="line">        break;</div><div class="line"></div><div class="line">    case &quot;edit&quot;:</div><div class="line"></div><div class="line">        //1.获取表单信息</div><div class="line">        $name = $_POST[&apos;name&apos;];</div><div class="line">        $sex = $_POST[&apos;sex&apos;];</div><div class="line">        $age = $_POST[&apos;age&apos;];</div><div class="line">        $classid = $_POST[&apos;classid&apos;];</div><div class="line">        $id = $_POST[&apos;id&apos;];</div><div class="line"></div><div class="line">        $sql = &quot;update message set name=&apos;&#123;$name&#125;&apos;,sex=&apos;&#123;$sex&#125;&apos;,age=&#123;$age&#125;,classid=&#123;$classid&#125; where id=&#123;$id&#125;&quot;;</div><div class="line">        $rw = $pdo-&gt;exec($sql);</div><div class="line">        if($rw&gt;0)&#123;</div><div class="line">            echo &quot;&lt;script&gt;alert(&apos;修改成功&apos;);window.location=&apos;index.php&apos;&lt;/script&gt;&quot;;</div><div class="line">        &#125;else&#123;</div><div class="line">           echo &quot;&lt;script&gt;alert(&apos;增加失败&apos;);window.history.back();&lt;/script&gt;&quot;;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– Database: &lt;code&gt;test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;– 表的结构 &lt;code&gt;message&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>动画切换效果之push、pop、present、dismiss</title>
    <link href="http://yoursite.com/2017/05/08/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/%E5%8A%A8%E7%94%BB%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E4%B9%8Bpush%E3%80%81pop%E3%80%81present%E3%80%81dismiss/"/>
    <id>http://yoursite.com/2017/05/08/动画与绘图/动画切换效果之push、pop、present、dismiss/</id>
    <published>2017-05-08T02:55:03.000Z</published>
    <updated>2017-10-30T05:48:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候页面跳转或视图切换的时候,需要做成特定的效果,常见的push、pop、present、dismiss效果如下,注意要添加<strong><caanimationdelegate></caanimationdelegate></strong>代理</p><h4 id="push默认动画效果"><a href="#push默认动画效果" class="headerlink" title="push默认动画效果"></a>push默认动画效果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    CATransition *transition = [CATransition animation];</div><div class="line">    transition.duration = 0.3f;</div><div class="line">    transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    transition.type = kCATransitionPush;</div><div class="line">    transition.subtype = kCATransitionFromRight;</div><div class="line">    transition.delegate = self;</div><div class="line">    [self.contentView.layer addAnimation:transition forKey:nil];</div><div class="line">    [self.contentView addSubview:self.productDetailController.view];</div><div class="line"></div><div class="line">```  </div><div class="line">#### pop默认动画效果</div></pre></td></tr></table></figure><pre><code>CATransition *transition = [CATransition animation];transition.duration = 0.3f;transition.timingFunction = [CAMediaTimingFunctionfunctionWithName:kCAMediaTimingFunctionEaseInEaseOut];transition.type = kCATransitionPush;transition.subtype = kCATransitionFromLeft;transition.delegate = self;[self.view.superview.layer addAnimation:transition forKey:nil];[self.view removeFromSuperview];</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### present默认动画效果</div></pre></td></tr></table></figure><pre><code>CATransition *transition = [CATransition animation];transition.duration = 0.4f;transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];transition.type = kCATransitionMoveIn;transition.subtype = kCATransitionFromTop;transition.delegate = self;[[self currentNavigationController].view.layer addAnimation:transition forKey:nil];[[self currentNavigationController] pushViewController:playVC animated:NO];</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#### dismiss默认动画效果</div></pre></td></tr></table></figure><pre><code>CATransition *transition = [CATransition animation];transition.duration = 0.3f;transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];transition.type = kCATransitionReveal;transition.subtype = kCATransitionFromBottom;transition.delegate = self;[self.navigationController.view.layer addAnimation:transition forKey:nil];[self.navigationController popViewControllerAnimated:NO];</code></pre><p>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候页面跳转或视图切换的时候,需要做成特定的效果,常见的push、pop、present、dismiss效果如下,注意要添加&lt;strong&gt;&lt;caanimationdelegate&gt;&lt;/caanimationdelegate&gt;&lt;/strong&gt;代理&lt;/p&gt;
&lt;h4 id=
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="动画与绘图" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP笔记</title>
    <link href="http://yoursite.com/2017/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/04/07/计算机网络/HTTP笔记/</id>
    <published>2017-04-07T06:47:00.000Z</published>
    <updated>2017-10-30T05:51:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>“你知道当我们在网页浏览器（Web browser）的地址栏中输入 URL 时，Web 页面是如何呈现的吗？”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-48cf5d50116ffd8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="过程.png"></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议（HyperText Transfer Protocol）即超文本传输协议是用于服务器传输到客户端浏览器的传输协议。Web上，服务器和客户端利用HTTP协议进行通信会话。</p><p>在Web上，HTTP协议使用TCP协议而不是UDP协议的原因在于一个网页必须传送很多数据，而且保证其完整性。TCP协议提供传输控制，按顺序组织数据和错误纠正的一系列功能。</p><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><pre><code>1、客户端与服务器需要建立连接。（比如某个超级链接，HTTP就开始了。）2、建立连接后，发送请求。3、服务器接到请求后，响应其响应信息。4、客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</code></pre><p>忽略掉连接过程是这样的:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-058c281b84838c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作过程.png"></p><h3 id="URI、URL与RFC"><a href="#URI、URL与RFC" class="headerlink" title="URI、URL与RFC"></a>URI、URL与RFC</h3><p>先看看官方的解释：<br>URI：uniform resource identifier 统一资源标识符<br>URL：uniform resource location 统一资源定位符</p><p>URI用字符串标识某一互联网资源，而URL表示资源的地点。可见URL是URI的子集。</p><p>URI要使用涵盖全部必要信息的URI、绝对URL以及相对URL。相对URL是指从浏览器中基本URI处理的URL，来先看下URI的格式:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-eb2b672fed8c4be9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="URI格式.png"></p><p>RFC：reqeust for comments 征求修正意见书<br>RFC素有网络知识圣经之称，规定了网络中协议的基本内容。因此许多的不同系统的应用程序才可以互相访问。</p><h3 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h3><p>请求行-请求方法</p><ul><li>GET            获取资源</li><li>POST          传输实体主体</li><li>PUT            传输文件</li><li>HEAD         获取报文首部</li><li>DELETE     删除文件</li><li>OPTIONS   请求查询服务器的性能，或者查询与资源相关的选项和需求 </li><li>TRACE        请求服务器回送收到的请求信息，主要用于测试或诊断</li><li>CONNECT  要求用隧道协议连接代理(SSL：Secure Sockets Layer安全套接层，TLS：Transport Layer Security传输层安全)</li></ul><h3 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h3><p><a href="https://segmentfault.com/a/1190000004014583" target="_blank" rel="external">看别人总结的吧</a><br><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external">还有这篇</a></p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-94b9b3e85b4abde1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="状态码类别.png"></p><p>常见的状态码</p><pre><code>200 OK请求成功（其后是对GET和POST请求的应答文档。）304 Not Modified未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。404 Not Found服务器无法找到被请求的页面。500 Internal Server Error请求未完成。服务器遇到不可预知的情况。</code></pre><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。</p><p>请求我博客园首页时发送的报文内容:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-2e62214fed2f76cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报文.png"></p><p>　其中最常使用的属性是：</p><ul><li>URL, 即http访问的地址</li><li>request method, 报文的请求方式</li><li>Remote Address,远程地址</li><li>status code, 状态码以及状态短语</li><li>Connection, 连接方式</li><li>Content-Type头：便是接收方实体的介质类型。</li><li>Accept Encoding, 内容编码</li><li>Date头域：时间描述</li><li>Referer头域：允许客户端指定请求URL的资源地址。</li><li>Cookie, 添加的cookie内容</li><li>Host, 目标主机</li><li>User-Agent, 客户端浏览器的相关信息</li><li>Set-Cookie, 指定想要在Cookie中保存的内容</li></ul><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>“HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-cf9c8252e3979368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通信一次断开一次.png"></p><p>“为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-4e13a9ac5f083e57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="持久连接.png"></p><p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。<br>在 HTTP/1.1 中，所有的连接默认都是持久连接</p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>“持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p><p>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-5f1fa307c9c4ca54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-16 下午3.41.33.png"></p><p>比如，当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。</p><h3 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h3><p>由于某些报文的内容过大，因此在传输时，为了减少传输的时间，会采取一些压缩的措施。</p><p>例如上面的报文信息中，Accept-Encoding就定义了内容编码的格式：gzip,deflate</p><p>有下面几种方式：</p><ul><li>gzip：GNU压缩格式</li><li>compress：UNIX系统的标准压缩格式</li><li>deflate：是一种同时使用了LZ77和哈弗曼编码的无损压缩格式</li><li>identity：不进行压缩</li></ul><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p><p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。</p><p>对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0a2a457a44dd55e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-16 下午4.13.32.png"></p><p>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。</p><p>byte 范围的指定形式如下。</p><ul><li><p>5001~10 000 字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=5001-10000</div></pre></td></tr></table></figure></li><li><p>从 5001 字节之后全部的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=5001-</div></pre></td></tr></table></figure></li><li><p>从一开始到 3000 字节和 5000~7000 字节的多重范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=-3000, 5000-7000</div></pre></td></tr></table></figure></li></ul><p>针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</p><p>如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。”</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</p><p>假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。</p><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><p>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-89c6414d2822a545.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Cookie.png"></p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP 主要有这些不足，例举如下。</p><ul><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改”</li></ul><p>这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题。</p><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p><p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f647e66bc61d89e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SSL.png"></p><p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。</p><p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-aec3c3a7c56e95da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTPS通信.png"></p><p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p><p>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p><p>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p><p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p><p>步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p><p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p><p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p><p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p><p>步骤 9： 服务器同样发送 Finished 报文。</p><p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p><p>步骤 11： 应用层协议通信，即发送 HTTP 响应。</p><p>步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p><p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><h3 id="HTTP认证"><a href="#HTTP认证" class="headerlink" title="HTTP认证"></a>HTTP认证</h3><p>　　有一些网址或者服务需要用户的身份信息，因此需要随时知道这些消息，但是肯定不能每次都让用户输入用户密码，因此关于认证就有下面几种方式：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-7742dd7b79eca737.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="032135393488858.jpeg"></p><p>其中BASIC认证是最简单的认证，大致过程如下：<br>1 、客户端访问某URL。<br>2 、服务器端返回401状态码，提示用户输入用户名密码。<br>3 、用户输入用户名密码，通过BASE64编码传输。<br>4 、服务器通过认证，返回状态码200</p><p>通过上面的过程，就可以发现BASIC的问题：</p><ul><li>仅仅通过BASE64编码，其实还是属于明文传输，安全性不高</li><li>有的浏览器不支持注销</li></ul><p>鉴于上面BASIC的问题，DIGEST做了补充，它的过程与上面类似：<br>1 、客户端访问<br>2 、服务器端返回质询码<br>3 、客户端发送响应码</p><p>这里通过随机的生成质询码来作为计算的一种方式，客户端依据这个质询码生成响应码，进行验证。<br>这样就弥补了明文传输用户密码的风险。</p><p>SSL客户端验证，这个比较普遍了！</p><p>像支付宝啊，邮政网银啊之类的，在登录时，都需要下载一个数字认证的东西，这个东西就属于一种SSL客户端的验证。</p><p>很显然它的缺点就是需要客户去手动的安装，这个对于一般的用户来说，代价有点高。</p><p>最后一种是应用最普遍的，通过表单记录用户的身份信息，可以使用cookie或者session的方式保存用户信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“你知道当我们在网页浏览器（Web browser）的地址栏中输入 URL 时，Web 页面是如何呈现的吗？”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1868951-48cf5d5011
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TCP-IP笔记(八)应用层协议</title>
    <link href="http://yoursite.com/2017/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%AC%94%E8%AE%B0(%E5%85%AB)%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2017/03/21/计算机网络/TCP-IP笔记(八)应用层协议/</id>
    <published>2017-03-21T02:30:00.000Z</published>
    <updated>2017-10-30T05:52:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP的应用层涵盖了OSI参考模型中第5、第6、第7层的所有功能,不仅包含了管理通信连接的会话层功能、转换数据格式的标识层功能,还包括与对端主机交互的应用层功能在内的所有功能。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-07276cc0a56fa5bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模型.png"><br>利用网络的应用程序有很多,包括Web浏览器、电子邮件、远程登录、文件传输、网络管理等。能够让这些应用进行特定通信处理的正式应用协议。</p><p>接下来介绍下应用层常见的协议:</p><ul><li><p>DNS：域名系统。DNS是因特网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。</p><ul><li><p>因特网的域名结构<br>如：  mail.cctv.com    三级域名,二级域名,顶级域名</p><p> 现在顶级域名TLD（Top Level Domain）共分为三大类：<br>　　　　1.国家顶级域名nTLD：如cn表示中国，us为美国<br>　　　　2.通用顶级域名gTLD：如com（公司企业）、net（网络服务机构）、int（国际组织）<br>　　　　3.基础结构域名：只有一个，即arpa，用于反向域名解析</p></li><li><p>域名服务器<br>　　完成域名到IP地址的解析工作。包括：<br>　　　　1.根域名服务器（root name server）：最高层次的域名服务器，知道所有顶级域名服务器的域名和IP地址。<br>　　　　2.顶级域名服务器：负责管理在该顶级域名服务器注册的所有二级域名。<br>　　　　3.权限域名服务器：负责一个区的域名服务器。<br>　　　　4.本地域名服务器：是自己可以设置的服务器，用于管理自己分发的域名。</p></li></ul></li></ul><ul><li><p>FTP：文件传输协议。FTP是因特网上使用得最广泛的文件传送协议。FTP提供交互式的访问，允许客户指明文件类型与格式，并允许文件具有存取权限。FTP其于TCP。</p></li><li><p>HTTP：超文本传送协议。是面向事务的应用层协议，它是万维网上能够可靠地交换文件的重要基础。http使用面向连接的TCP作为运输层协议，保证了数据的可靠传输。</p></li><li><p>SMTP：电子邮件协议。即简单邮件传送协议。SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。SMTP通信的三个阶段：建立连接、邮件传送、连接释放。</p></li><li><p>POP3：邮件读取协议。POP3(Post Office Protocol 3)协议通常被用来接收电子邮件。</p></li><li><p>SNMP：简单网络管理协议。由三部分组成：SNMP本身、管理信息结构SMI和管理信息MIB。SNMP定义了管理站和代理之间所交换的分组格式。SMI定义了命名对象类型的通用规则，以及把对象和对象的值进行编码。MIB在被管理的实体中创建了命名对象，并规定类型。</p></li></ul><p>TCP支持的应用协议主要有：Telnet （远程终端协议）、FTP（文件传输协议）、POP3（邮件读取协议）、SMTP（电子邮件协议）等。</p><p>UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP/IP的应用层涵盖了OSI参考模型中第5、第6、第7层的所有功能,不仅包含了管理通信连接的会话层功能、转换数据格式的标识层功能,还包括与对端主机交互的应用层功能在内的所有功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TCP-IP笔记(七)TCP详解</title>
    <link href="http://yoursite.com/2017/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%AC%94%E8%AE%B0(%E4%B8%83)TCP%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/03/17/计算机网络/TCP-IP笔记(七)TCP详解/</id>
    <published>2017-03-17T02:11:00.000Z</published>
    <updated>2017-10-30T05:52:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP的特点及其目的"><a href="#TCP的特点及其目的" class="headerlink" title="TCP的特点及其目的"></a>TCP的特点及其目的</h3><p>  为了通过数据包实现可靠性传输,需要考虑很多事情,例如数据的破坏、丢包、重复记忆分片顺序混乱等问题。如不能解决这些问题,也就无从谈起可靠传输。<br>TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p><h3 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h3><p>在TCP中,当发送端的数据到达接收主机时,接收端主机会番号一个已收到消息的通知。这个消息叫做确认应答–ACK(Positive Acknowled-gement 意指已经接收。)</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-91892d00cf216bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正常的数据传输.png"></p><p>TCP通过肯定的确认应答(ACK)实现可靠的数据传输。当发送端将数据发生之后会等待对端的确认应答。如果有确认应答,说明数据已经成功到达对端。反之,则数据丢失的可能性很大。</p><p>当然,在一定时间内没有等到确认应答,发送端就可以认为数据已经丢失,并进行重发。由此,即使产生了丢包,仍然能够保证数据能够到达对端,实现可靠传输。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-b6cb6c12465ed4f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据包丢失的情况.png"></p><p>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到,知识返回的确认应答在途中丢失。这种情况也会导致发送端因没有收到确认应答,而认为数据没有到达目的地,从而进行重新发送,如下图:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6588851c3553d3d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="确认应答丢失的情况.png"><br>此外,也有可能因为一些其他原因导致确认应答延迟到达,在源主机重发数据以后才到达的情况也屡见不鲜。此时,源发送主机只需重发数据即可,但是对目标主机,反复收到相同的数据,确是一种”灾难”。而为了对上层应用提供可靠的传输,必须得放弃重复的数据包。</p><p>为此,必须引入一种机制,它能够识别出是否已经接收数据,又能够判断是否需要接收。<br>上述这些确认应答处理、重发控制以及重复控制等功能都可以通过<strong>序列号</strong>实现。<br>序列号是按顺序给发送数据的每一个字节(8位字节)都标上号码的编号。<br>接收到查询接收数据TCP首部中的序列号和数据的长度,将自己下一步应该接收的序号作为确认应答返送回去。<br>就这样,通过序列号和确认应答号,TCP可以实现可靠传输。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6453ddc87ed87740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送数据.png"></p><h3 id="重发超时"><a href="#重发超时" class="headerlink" title="重发超时"></a>重发超时</h3><p>重发超时是指在重发数据之前,等待确认应答到来的那个特定时间间隔。如果超过了这个时间仍未收到确认应答,发送端将进行数据重发。</p><p>在BSD的Unix以及Windows系统中,超时都以0.5秒为单位进行控制,因此重发超时都是0.5秒的整数倍。不过,由于最初的数据包还不知从往返时间,所以其重发超时一般设置为6秒左右。</p><p>数据被重发之后如还是收不到确认应答,则进行再次发送。此时,等待确认应答的时间将会以2倍、4倍的指数函数延长。</p><p>此外,数据也不会被无限、反复地重发。达到一定重发次数之后,如果人没有任何确认应答返回,就会判断为网络或对端主机发生了异常,强制关闭连接。并且通知应用通信异常强行终止。</p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>TCP提供面向有连接的通信传输。面向有链接是指在数据通信开始之前先做好通信两端之间的准备工作。<br>一个连接的建立与断开,正常过程至少需要来回发送7个包才能完成。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-425ec4bbedcbf6d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP连接的建立与断开.png"></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。这就是面试中经常会被问到的TCP三次握手。只是了解TCP三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。 </p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3f85c6bc89d1824c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP三次握手.png"></p><ol><li><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p></li><li><p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p></li><li><p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p></li></ol><p>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：</p><pre><code>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</code></pre><p>在书中同时举了一个例子，如下：</p><blockquote><p>   已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。</p></blockquote><p>这就很明白了，<strong>防止了服务器端的一直等待而浪费资源。</strong></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次挥手”。</p><p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-7734f69f8b86c584.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP四次挥手.png"></p><ol><li><p>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p></li><li><p>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p></li><li><p>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p></li><li><p>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p></li></ol><p>至此，TCP的四次挥手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。    </p><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>那四次挥手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p>如果要正确的理解四次挥手的原理，就需要了解四次挥手过程中的状态变化。</p><ul><li><p>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</p></li><li><p>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</p></li><li><p>CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</p></li><li><p>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</p></li><li><p>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</p></li><li><p>CLOSED: 表示连接中断。</p></li></ul><h3 id="TCP以段为单位发送数据"><a href="#TCP以段为单位发送数据" class="headerlink" title="TCP以段为单位发送数据"></a>TCP以段为单位发送数据</h3><p>TCP在传送大量数据时,是以MSS(Maximum Segment Size 最大消息长度)的大小将数据进行分割发送。进行重发是也是以MSS为单位。<br>MSS是在三次握手的时候,在两端主机之间被计算得出剧好两端的主机在发出建立连接的请求是,会在TCP首部中写入MSS选项,告诉对方自己的接口能够适的MSS的大小。然后会在两者之间选择一个较小的值投入使用。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-c9efbb3f75cb0026.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选较小的MSS.png"></p><h3 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h3><p>TCP以1个段为单位,每发一个段进行一次确认应答的处理。<br>如图:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-16ace958aa720fcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="按数据包进行确认应答.png"></p><p>为了解决通信性能的问题,TCP引入了<strong>窗口</strong>这个概念。<br>确认应答不再以每个分段,而是以更大的单位进行确认时,转发时间将会被大幅度的缩短。也就是说,发送端主机,在发送了一个段以后不必要一直等待确认应答,而是继续发送。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-a95b6a70a6b2561b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用滑动窗口方式并行处理.png"></p><p>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中的窗口大小为4个段。<br>这个机制实现了使用大量的缓冲区,通过对多个段同时进行确认应答的功能。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f9c5f50664cee2ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-15 下午2.08.17.png"><br>如上图中,发送数据中高亮圈起的部分正是前面所提到的窗口。<br>在收到确认应答后,将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也被称为滑动窗口控制。</p><h3 id="窗口控制与重发控制"><a href="#窗口控制与重发控制" class="headerlink" title="窗口控制与重发控制"></a>窗口控制与重发控制</h3><p>在未使用窗口控制时,没有收到确认应答的数据都会被重发。而是用了窗口控制,某些确认应答即使丢失也无需重发</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-dcd5eefd4a7098f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="没有确认应答也不受影响.png"></p><p>其次,我们来考虑一下某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序号以外的数据时,会针对当前位置收到的数据返回确认应答。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-88fa4df7026201ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重发控制.png"></p><p>当某一报文段丢失后,发送端会一直收到序号为1001的确认应答,这个确认应答提醒发送端,”我想接收的是从1001开始的数据”。</p><p>因此,当窗口比较大时,又出现报文段丢失是,同一序号的确认应答会不断重复的返回。<br>当发送端主机如果连续3次收到同一个确认应答,就会将其所对应的数据进行重发。</p><p>这种机制,比之前提到超时管理更搞笑,因此也被称作高速重发控制。</p><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p>流控制是TCP提供的一种可以让发送端根据接受端的实际接收能力控制发送的数据量的机制。<br>具体操作是,接收端主机箱发送端主机通知自己可以接收数据的大小,于是发送端会发送不超过这个限度的数据。该大小限度就被称作窗口大小。<br>TCP首部中,专门有一个字段用来通知窗口大小。<br>接收主机将自己可以接收的缓存区大小放入这个字段中通知给发送端。这个字段的值越大,说明网络的吞吐量越高。<br>不过,当接收端的缓冲区面临数据溢出时,窗口大小的值也会随之呗设置为一个更小的值通知给发送端,从而控制数据发送量。<br>也就是说,发送端主机会根据接收端主机的指示,对发送数据的量进行控制。这也就形成了一个完整的TCP流控制(流量控制)</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-bac76fbc083e437a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流量控制.png"><br>如上图,当接收端从3001号开始的数据段后其缓冲区即满,不得不暂时停止接收数据。之后,在收到发送窗口更新通知后通信才得以继续进行。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>有了窗口控制,首发主机之间可以不再以一个数据段为单位发送确认应答,也能够连续发送大量数据包。但是如果在通信刚开始时就发送大量数据,也有可能会引发其他问题。<br>TCP为了防止该问题的出现,在通信一开始时就会通过一个叫做慢启动的算法得出的数值,对发送数据量进行控制。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-20db3532f42cbafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-15 下午2.39.30.png"><br>首先,为了在发送端调节所要发送数据的量,定义了一个叫做”拥堵窗口”的概念。于是在慢启动的时候,将这个拥堵窗口的大小设置为1个数据段(1MSS)发送数据,之后每收到一次确认应答(ACK),拥堵窗口的值就加1。在发送数据包时,将拥堵窗口的大小与接收端主机通知的窗口大小做比较,然后按照它们当中较小那个值,发送比其还要小的数据量。<br>如果重发采用超时机制,那么拥塞窗口的初始值可以设置为1以后再进行慢启动修正。有了上述这些机制,就可以有限的减少通信开始时连续发包导致的网络拥堵,还可以避免网络拥塞情况的发生。<br>不过,随着包的每次往返,拥塞窗口也会以1、2、4等指数函数的增长,拥堵状况激增甚至导致网络拥塞的发生。为了防止这些,引入了慢启动阀值的概念。只要拥塞窗口的值超出这个阀值,在每收到一次确认应答时,只允许以下面这种比例方法拥塞窗口:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-b36ac71de7daf1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公式.png"><br><img src="http://upload-images.jianshu.io/upload_images/1868951-c71265a3e7831314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拥塞窗口的大小.png"><br>当TCP通信开始以后,网络吞吐量会逐渐上升,但是随着网络拥堵的发生吞吐量也会急剧下降。于是会再次进入吞吐量慢慢上升的过程。因此所谓TCP的吞吐量的特点就好像是在逐步占领网络带宽的感觉。</p><h3 id="提高网络利用率的规范"><a href="#提高网络利用率的规范" class="headerlink" title="提高网络利用率的规范"></a>提高网络利用率的规范</h3><ul><li>Nagle算法</li><li>延迟确认应答</li><li>捎带应答</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP的特点及其目的&quot;&gt;&lt;a href=&quot;#TCP的特点及其目的&quot; class=&quot;headerlink&quot; title=&quot;TCP的特点及其目的&quot;&gt;&lt;/a&gt;TCP的特点及其目的&lt;/h3&gt;&lt;p&gt;  为了通过数据包实现可靠性传输,需要考虑很多事情,例如数据的破坏、丢包、重
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TCP-IP笔记(六)TCP与UDP</title>
    <link href="http://yoursite.com/2017/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%AC%94%E8%AE%B0(%E5%85%AD)TCP%E4%B8%8EUDP/"/>
    <id>http://yoursite.com/2017/03/17/计算机网络/TCP-IP笔记(六)TCP与UDP/</id>
    <published>2017-03-17T01:27:00.000Z</published>
    <updated>2017-10-30T05:53:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于来到了传输层,这个面试问的最多了😁</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>TCP/IP中有两个具有代表性的传输层协议,分别为:</p><ul><li>TCP: 提供可靠的通信传输</li><li>UDP:用于让广播和细节控制交给应用的通信传输<br>根据通信的具体特征,选择合适的传输层协议非常重要。</li></ul><p><strong>套接字(Socket):</strong><br>使用TCP或UDP时,会广泛使用到套接字(socket)的API。套接字原本是由BSD UNIX开发的,但是后被移植到了Windows的Winsock以及嵌入式操作系统中。<br>应用程序利用套接字,可以设置对端的IP地址、端口号,并实现数据的发送与接收。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-8fda5539e2a827c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Socket.png"></p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>数据链路和IP中的地址,分别指的是MAC地址和IP地址。<br>前者用来识别同一链路中不同的计算机,后者用来识别TCP/IP网络中互连的主机和路由器。</p><p>同样的,在传输层中也有类似于地址的概念,那就是端口号。</p><p>端口号用来识别同一台计算机中进行通信的不同应用程序。因此,它也被称为程序地址。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-afc4629f1a207553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="端口号.png"></p><p>另:仅凭目标端口识别某一个通信是远远不够的。通常采用5个信息来识别一个通信。它们分别是:</p><ul><li>源IP地址</li><li>目标IP地址</li><li>协议号 :在IP协议部分我们提到IP首部中有一个协议字段,用来标识网络层(IP)的上层所采用的是哪一种传输层协议。根据这个字段的协议号,就可以识别IP传输的数据部分究竟是TCP的内容,还是UDP的内容。</li><li>源端口号</li><li>目标端口号</li></ul><h4 id="端口号如何确定"><a href="#端口号如何确定" class="headerlink" title="端口号如何确定"></a>端口号如何确定</h4><ul><li>标准既定的端口号<br>也叫静态方法。是指每个应用程序都有其指定的端口号。但不是说可以随意使用任何一个端口号。每个端口号都有其对应的使用目的。<br>例如,HTTP、TELNET、FTP等应用协议使用的知名端口号:</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-2816627c3f993fc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="知名端口号.png"></p><ul><li>时序分配法<br>也叫动态分配法。服务端有必要确定监听端口号,但是客户端没必要确定端口号。<br>这种方法下,客户端不用自己设置端口号,而全权交给操作系统进行分配。操作系统可以为每个应用程序分配互不冲突的端口号。这种动态机制,即使同一个客户端程序发起多个TCP连接,识别这些通信连接的部分数字也不会全部相同。动态端口号取值范围在49152到65535之间。</li></ul><h4 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h4><p>端口号由其使用的传输层协议决定。因此,不同的传输协议可以使用相同的端口号。例如,TCP与UDP使用同一个端口号,但使用目的各不相同。这是因为端口号上的处理会根据每个传输协议的不同而进行的。<br>数据到达IP层后,会先检查IP首部中的协议号,再传给相应协议的模块。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP是User Datagram Protocol 的缩写。<br>UDP是利用IP提供面向无连接的通信服务,不提供复杂的控制机制。<br>并且它是将应用程序发来的数据在收到的那一刻,立刻按照鸳鸯发送到网络上的一种机制。<br>即使是出现网络拥堵的情况下,UDP也无法进行流量控制等避免网络拥堵的行为。此外,传输途中即使出现丢包,UDP也不负责重发。甚至当出现包的到达顺序乱掉是也没有纠正的功能。</p><p>如果需要这些细节控制,那么不得不交有采用UDP的应用程序去处理。<br>由于UDP面向无连接,他可以随时发送数据。再加上UDP本身的处理既简单又高效,因此常用于以下几个方面:</p><ul><li>包总量较小的通信(DNS、SNMP等)</li><li>视频、音频等多媒体通信(即时通信)</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信(广播、多播)</li></ul><h4 id="UDP-首部"><a href="#UDP-首部" class="headerlink" title="UDP 首部"></a>UDP 首部</h4><p>如下图,除去数据的部分就是UDP的首部。<br>UDP的首部源端口号,目标端口号,包长和校验和组成。<br><img src="http://upload-images.jianshu.io/upload_images/1868951-80b631d1cdcf682a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP 首部.png"></p><ul><li>源端口号: 标识发送端端口号,字段长16位。该字段可以不设置,缺省值为0,可用于不需要返回的通信中。</li><li>目标端口号: 标识接收端端口号,字段长16位。</li><li>包长度: 指UDP首部的长度和数据的长度之和。为8位字节。</li><li>检验和: 校验和用来判断数据在传输过程中是否损坏。计算这个校验和的时候，不仅考虑源端口号和目标端口号，还要考虑 IP 首部中的源 IP 地址，目标 IP 地址和协议号（这些又称为 UDP 伪首部）。这是因为以上五个要素用于识别通信时缺一不可，如果校验和只考虑端口号，那么另外三个要素收到破坏时，应用就无法得知。这有可能导致不该收到包的应用收到了包，改收到包的应用反而没有收到。</li></ul><p>这个概念同样适用于即将介绍的 TCP 首部,但是TCP的校验和无法关闭。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>与UDP不同,TCP则”人如其名”,可以说是对”传输、发送、通信”进行”控制”的”协议”。<br>TCP充分实现了数据传输时各种控制功能,可以进行丢包是的重发控制,还可以对次序乱掉的分包进行顺序控制。<br>此外,TCP作为一种面向连接的协议,只有在确认通信对端存在时才会发送数据,从而可以控制通信流量的浪费。</p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>连接是指各种设备、线路,或网络中进行通信的两个应用程序为了相互传递消息而专有的、虚拟的通信线路,也叫做虚拟电路。</p><p>一旦建立了连接,进行通信的应用程序只是用这个虚拟的通信线路发送和接收数据,就可以保障信息的传输。应用程序不用顾虑IP网络上可能发生的各种问题,依然可以转发数据。<br>TCP则负责控制链接的建立、断开、保持等管理工作。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-680b8aff0c72ad73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="连接.png"></p><h4 id="TCP-首部"><a href="#TCP-首部" class="headerlink" title="TCP 首部"></a>TCP 首部</h4><p>和 UDP 首部相比，TCP 首部要复杂得多。解析这个首部的时间也相应的会增加，这是导致 TCP 连接的效率低于 UDP 的原因之一。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-560e4e1aa9e4964a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP 首部.png"></p><p>其中某些关键字段解释如下：</p><ul><li><p>序列号: 字段长32位。它表示发送数据的位置，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。</p></li><li><p>确认应答号: 字段长32位。它等于下一次应该接收到的数据的序列号。假设发送端的序列号为 s，发送数据的长度为 l，那么接收端返回的确认应答号也是 s + l。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。</p></li><li><p>数据偏移: TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示 TCP 首部的长度为 20 字节。</p></li><li><p>保留: 该字段为以后拓展时使用,其长度为4位。一般设置为0,但即使受到的包在该字段不为0,此包也不会被丢弃。</p></li><li><p>控制位: 改字段长度为 8 比特，分别有 8 个控制标志。依次是 CWR，ECE，URG，ACK，PSH，RST，SYN 和 FIN。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0eebc3e6bf64ab02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控制位.png"></p><p>CWR: 与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时,则通知对方已将拥塞窗口缩小。</p><p>ECE: 表示ECN-Echo。置为1会通知通信对方,从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE置为1。 </p><p>URG: 此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；</p><p>ACK: 此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；</p><p> PSH: 这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</p><p> RST: 这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</p><p> SYN: 表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；</p><p>FIN: 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</p><ul><li><p>窗口大小：该字段长16位。用于表示从应答号开始能够接受多少个 8 位字节。如果窗口大小为 0，可以发送窗口探测。</p></li><li><p>紧急指针: 仅在 URG 控制位为 1 时有效。表示紧急数据的末尾在 TCP 数据部分中的位置。通常在暂时中断通信时使用（比如输入 Ctrl + C）。</p></li><li><p>选项: 该字段长度最大为40字节,用于提高TCP的传输性能。选项字段尽量调整其为32位的整数倍。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1558ed07037c992a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选项.png"></p><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><p>TCP是面向连接的、传输可靠(保证数据正确性且保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。</p><p>　　TCP是一种流模式的协议，是面向连接的，也就是说，在连接持续的过程中，Socket 中收到的数据都是由同一台主机发出的（劫持什么的不考虑），因此，知道保证数据是有序的到达就行了，至于每次读取多少数据不关心。</p><p>　　TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。<br>　　UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。</p><p>　　关于TCP是一种流模式的协议，UDP是一种数据报模式的协议，这里要说明一下，TCP是面向连接的，也就是说，在连接持续的过程中，socket 中收到的数据都是由同一台主机发出的（劫持什么的不考虑），因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。</p><p>　　而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一 起，这样的数据是没有意义的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;终于来到了传输层,这个面试问的最多了😁&lt;/p&gt;
&lt;h3 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h3&gt;&lt;p&gt;TCP/IP中有两个具有代表性的传输层协议,分别为:&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TCP-IP笔记(五)IP协议相关技术</title>
    <link href="http://yoursite.com/2017/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%AC%94%E8%AE%B0(%E4%BA%94)IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2017/03/16/计算机网络/TCP-IP笔记(五)IP协议相关技术/</id>
    <published>2017-03-16T02:15:00.000Z</published>
    <updated>2017-10-30T05:54:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>IP旨在让最终目标主机收到数据包,但是在这一过程中仅仅有IP时无法实现通信的。必须还要又能够解析主机名称和MACdivide功能,以技术包在发送过程中异常情况处理的功能。<br>这篇主要介绍下DNS、ARP、ICMP等协议</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>TCP/IP网络中要求每一个互连的计算机都具有其唯一的IP地址,并基于这个IP地址进行通信。但是IP地址太长了,不好记。</p><p>人们希望主机有自己自己的名字，这个名字是唯一的，而且容易记住。于是，诞生了主机名“域名”的概念。域名是一种为了识别主机名称和机构名的具有分层的名称，比如在域名 neu.edu.cn中，neu是主机名，edu 和 cn 是不同层次下的机构名。</p><p>为了实现这样的功能,主机往往会利用一个叫做hosts的数据库文件</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3665731851f94efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hosts.png"></p><p>但是随着网络规模的不断扩大,接入计算机的个数不断增加,这种集中在本地电脑管理的方式就不可取了。</p><p>于是出现了DNS,当我们输入主机名(域名)时,DNS会先在互联网上先自动检索那个注册了主机名和IP地址的数据库,并迅速定位到对应的IP地址。</p><p>域名和 IP 地址都可以唯一对应一台主机，DNS 协议的作用就是将自身具有意义的域名转换成不容易记住的 IP 地址。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-96e8d54d33345ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="![Uploading 屏幕快照 2017-03-16 上午9.47.03_768491.png . . .]"></p><p>域名是分层的，每层都有自己的 DNS 服务器用于处理 DNS 解析的请求。这样的好处在于每层的服务器不用关注过多的信息，它只要知道自己这一层下的域名服务器信息即可。以解析域名： www.abc.com为例：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3e32da753fe9adb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解析域名.png"></p><p>根服务器其实并不知道 www.abc.com 的 IP 地址，但是它知道 abc.com 域名服务器的地址，所以它把这条查询请求转发给 abc.com 域名服务器。DNS请求被逐层下发，直到找到对应的 IP 地址为止。<br>解析器和域名服务器将最新了解到的信息暂时保存在缓存中酱紫可以减少每次查询时的性能消耗。</p><p><strong>DNS就如同互联网中的分布式数据库</strong></p><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>只要确定了IP地址,就可以向这个目标地址发送IP数据报。然而在底层数据链路层,进行实际通信时,却需要知道每个IP地址所对应的MAC地址</p><p>ARP 协议(Address Resolution Protocol)用于通过目标 IP 地址，定位下一个接收数据包的网络设备的 MAC 地址。如果目标主机处在同一个数据链路上，那么可以直接得到目标主机的 MAC 地址，否则会得到下一条路由器的 MAC 地址。</p><p>ARP 协议的工作原理可以分为两部分：ARP 请求和 ARP 响应。 首先，源主机会通过广播发送一个 ARP 请求包：“我要与 IP 地址为 xxx 的主机通话，谁知道它的 MAC地址？”。</p><p>数据链路上的所有主机都会收到这条消息并检查自己的 IP 地址，如果与 ARP 请求包中的 IP 地址一致，主机就会发送 ARP 响应包：“我就是 IP 地址为 xxx 的主机，我的 MAC 地址是：xxxx”。</p><p>下图表示了 ARP 协议的工作机制：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-eee8ed90c44bd2e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-14 下午2.55.11.png"><br>在实际的使用过程中，每次往目标主机发送数据都要使用 ARP 是很低效的，通常的做法是把获取到的 MAC 地址缓存一段时间。一般来说，一旦源主机向目标地址发送一个数据包，接下来继续发送多次的概率非常大，因此这种缓存非常容易命中。</p><p>当下一次发送 ARP 请求或超过一定时间后，缓存都会失效，这保证了即使 MAC 地址与 IP 地址的对应关系发生了变化，数据包依然能够被正确的发往目标地址。</p><h4 id="IP地址和MAC地址缺一不可"><a href="#IP地址和MAC地址缺一不可" class="headerlink" title="IP地址和MAC地址缺一不可?"></a>IP地址和MAC地址缺一不可?</h4><p>MAC 和 IP 地址虽然看上去功能类似(都是用于唯一区分主机)，但是两者缺一不可。如果只有 IP 地址，虽然可以跳过 ARP，直接在数据链路上发一个广播，但是这仅适用于通信双方处于同一个数据链路下的情况。如果双方处于不同的数据链路，数据报无法穿透中间的路由器。</p><p>仅凭MAC地址,人们无法知道这台机器所处的位置。如果全世界只用 MAC 地址，那么网桥就得向全世界发包,那么请参考交换机的自学过程，可以想象这个过程会带来庞大的，不必要的流量,而且网桥要维护一张巨大的表格来维护所有学到的MAC地址,当这些信超过网桥极限,就没法工作了,也就无法通信了。</p><p>正因为 MAC 和 IP 地址缺一不可，所以才产生了 ARP 这样的协议将两者关联起来。</p><h4 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h4><p>RARP(Reverse Address Resolution Protocol)是将ARP反过来,从MAC地址定位IP地址的一种协议。</p><h4 id="代理ARP"><a href="#代理ARP" class="headerlink" title="代理ARP"></a>代理ARP</h4><p>通常ARP包会被路由器隔离,但是采用代理ARP的路由器可以将ARP请求转发给邻近的网段。由此两个以上网段的节点之间可以像在同一个网段中一样进行通信。<br>一般情况下有路由器连接多个网络时,会在每个网段定义各自的子网,从而进行路由控制,但是对于那些不支持设定子网掩码的老设备,不适用代理ARP,有时就无法更好的使用网络。</p><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>架构IP网络时需要特别注意两点:确认网络是否正常工作,以及遇到异常时进行问题诊断。<br>ICMP正是提供这类功能的一种协议。<br>主要功能包括:确认IP包是否成功送达目标地址,通知在发送过程中IP包被废弃的具体原因,改善网络设置等。<br>ICMP的消息大致可以分为两类:一类是通知出错原因的错误消息,另一类是用于诊断的查询消息。</p><h4 id="主要消息类型"><a href="#主要消息类型" class="headerlink" title="主要消息类型"></a>主要消息类型</h4><p><img src="http://upload-images.jianshu.io/upload_images/1868951-a09618374282212d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主要消息类型.png"></p><h3 id="DHCP-Dynamic-Host-Configuration-Protocol"><a href="#DHCP-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP(Dynamic Host Configuration Protocol)"></a>DHCP(Dynamic Host Configuration Protocol)</h3><p>逐一为每一台主机设置IP地址会非常繁琐的事情。特别是移动设备,每到一个新地方,就要重新设置IP地址<br>于是为了实现自动设置IP地址、统一管理IP地址分配,就产生了DHCP协议。<br>有了DHCP,计算机只要连接到网络,就可以进行TCP/IP通信。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-da50c2127f8d336f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DHCP.png"></p><h4 id="DHCP工作机制"><a href="#DHCP工作机制" class="headerlink" title="DHCP工作机制"></a>DHCP工作机制</h4><p>使用DHCP前,首先要假设一台DHCP服务器。然后将DHCP所要分配的IP地址设置到服务器上。此外,还需要将相应的子网掩码、路由控制信息以及DNS服务器的地址等设置到服务器上。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-988b1cef68296a00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作机制.png"></p><p>为了检查所要分配的IP地址以及已经分配了的IP地址是否可用,DHCP服务器或DHCP客户端必须具备以下功能:</p><ul><li>DHCP服务器:<br>在分配IP底之前发送ICMP回送请求包,确认没有返回应答</li><li>DHCP客户端:<br>针对从DHCP哪里获得的IP地址发送ARP请求包,确认没有返回应答</li></ul><p>在大规模组织机构的网络环境中,往往需要将DHCP统一管理</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-9767af7690c6e61e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DHCP中继代理.png"></p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>NAT (Network Address Translator) 是一种用于将局域网中的私有地址转换成全局 IP 地址的技术。</p><p>在连接上无线路由器的时候，如果检查一下设备的 IP 地址，也许你会发现是类似于 192.168.1.1 这样的局域网 IP 地址。那不同网段中，IP 地址都是 192.168.1.1 的主机改如何通信呢？</p><p>局域网中 IP 地址为 10.0.0.10 的主机向全局 IP 地址 163.221.120.9 发送数据。NAT 路由器将数据包的源地址修改成自己的全局 IP 地址：202.244.174.37。同理，接收数据时，路由器把目标地址 202.244.174.37 翻译成内网地址：10.0.0.10</p><p>下图描绘了 NAT 的工作原理：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-fcdd9dc240ae7905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NAT 的工作原理.png"></p><p>路由器只有一个对外的全局 IP 地址，如果有多个内网主机都向外部通讯怎么办呢？这时就要使用 NAPT 技术，它和 NAT 从原理上类似，但它可以转换 TCP 和 UDP 端口号。</p><p>使用 NAPT 技术时，不同的内网 IP 被转换成同一个公共 IP 地址，也就是路由器对外显示的全局 IP 地址，但是被附加不同的端口号以示区分：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0de87f5ab4c34886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NAPT 工作原理.png"></p><p>不管是 NAT 还是 NAPT，都需要路由器路由器内部维护一张自动生成的地址转换表。以 TCP 为例，建立 TCP 连接首次握手的 SYN 包发出时会生成这个表，关闭连接时会发出 FIN 包，收到这个包的应答时转换表被删除。</p><h3 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h3><p>在下图所示的网络环境中,网络A、B使用IPv6,如果处于中间位置的网络C支持使用IPv4的话,A与B之间就无法直接进行通信。为了让他们之间正常通信,这是必须得采用IP隧道的功能。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e63e641dbb6dd2cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="举个🌰.png"><br>IP隧道中可以将那些从网络A发过来的IPv6的包统和为一个数据,再为之追加一个IPv4的首部以后转发给网络C。<br>一般情况下,紧接着IP首部的是TCP或UDP的首部。然而,现在的应用中,”IP首部的后面还是IP首部”或者”IP首部的后面是IPv6的首部”等情况与日俱增。这种在网络层的首部后面继续追加网络层首部 的通信方法就叫做”IP隧道”。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3a14d1dd7c6fbe36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP隧道.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IP旨在让最终目标主机收到数据包,但是在这一过程中仅仅有IP时无法实现通信的。必须还要又能够解析主机名称和MACdivide功能,以技术包在发送过程中异常情况处理的功能。&lt;br&gt;这篇主要介绍下DNS、ARP、ICMP等协议&lt;/p&gt;
&lt;h3 id=&quot;DNS&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TCP-IP笔记(四)IP协议</title>
    <link href="http://yoursite.com/2017/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%AC%94%E8%AE%B0(%E5%9B%9B)IP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2017/03/15/计算机网络/TCP-IP笔记(四)IP协议/</id>
    <published>2017-03-15T02:41:00.000Z</published>
    <updated>2017-10-30T05:54:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>IP相当于OSI参考模型的第3层–网络层:主要作用是”实现终端节点之间的通信”又称”点对点通信”。</p><p>IP作为整个TCP/IP中至关重要的协议,主要负责将数据包发送给最终的目标计算机。因此,IP能够让世界上任何两台计算机之间进行通信。</p><p>数据链路层的作用在于实现同一种数据链路下的包传递，而网络层则可以实现跨越不同数据链路的包传递。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-c065756d7e7bb2d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-14 上午10.07.11.png"></p><p><strong>主机:</strong>配置有IP地址,但是不进行路由控制的设备。<br>既配有IP地址又有路由控制能力的设备叫做”路由器”。<br><strong>节点:</strong>主机和路由器的统称。</p><h4 id="网络层和数据链路层的关系"><a href="#网络层和数据链路层的关系" class="headerlink" title="网络层和数据链路层的关系"></a>网络层和数据链路层的关系</h4><ul><li>数据链路层提供<strong>两个直连设备之间的通信功能</strong>。</li><li>网络层负责<strong>没有直连的两个网络之间进行通信传输</strong>。</li></ul><p>举个旅行的例子:<br>如果要去一个地方,计划先飞机后火车再公交到达目的地。我们买好票,又制定一个行程表,几点几分去哪里坐车都一目了然。</p><p>机票和火车票只在特定区间有效,当你换乘不同公司的飞机或不同区间的火车时,还要重新购票。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-a6e1f1e40f8924de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP与数据链路的作用.png"></p><p>每张票,只能在特定的区间内移动,就如同通信网络上的数据链路。</p><p>而这个区间内的出发地点和目的地点就图同一个数据链路的原地址和目标地址等首部信息。</p><p>整个过程的行程表的作用就相当于网络层。</p><p>如果只有行程表,没有车票,就无法达成交通工具到达目的地。反之,如果只有车票,而不知道坐什么车,在哪换乘,恐怕也很难到达目的地。<br>与之类似,计算机网络中也需要数据链路层和网络层才能实现向最终目标地址的通信。</p><h3 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h3><p>IP大致分为三大作用模块,它们是IP寻址、路由(最终节点为止的转发)以及IP分包与组包。</p><h4 id="IP属于面向无连接"><a href="#IP属于面向无连接" class="headerlink" title="IP属于面向无连接"></a>IP属于面向无连接</h4><ul><li>为了简化</li><li>为了提速</li></ul><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>为了识别通信终端,数据链路有MAC地址,网络层有IP地址。<br>IP地址用于在”连接到网络中的所有主机中识别出进行通信的目标地址”。<br>IP地址(IPv4地址)由32位正整数来表示。<br>IP地址有”网络标识(网络地址)”和”主机标识(主机地址)”两部分组成。<br>相互连接的不同段,以不同的网络标识来区别,在同一个段内,以不同的主机地址来区别。<br>由此,可以保证相互连接的整个网络中的每台主机的IP地址都不会重叠。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-b7f248344c8ad997.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-14 上午11.19.42.png"></p><h4 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h4><p>IP地址分为四个级别，分别为A类、B类、C类和D类。分类的依据是IP地址的前四位：</p><p>A类IP地址是第一位为“0”的地址。A类IP地址的前8位是<strong>网络标识</strong>，用十进制标识的话0.0.0.0-127.0.0.0是A类IP地址的理论范围。另外我们还可以得知，A类IP地址最多只有128个(实际上是126个，下文不赘述)，每个网段内主机上限为2的24次方，也就是16，777，214个。</p><p>B类IP地址是前两位为“10“的地址。B类IP地址的前16位是<strong>网络标识</strong>，用十进制标识的话128.0.0.0-191.255.0.0是B类IP地址的范围。B类IP地址的主机标记长度为16位，因此一个网段内可容纳主机地址上限为65534个。</p><p>C类IP地址是前三位为“110”的地址。C类IP地址的前24位是<strong>网络标识</strong>，用十进制标识的话192.0.0.0-223.255.255.0是C类IP地址的范围。C类地址的后8位是主机标识，共容纳254个主机地址。</p><p>D类IP地址是前四位为“1110”的地址。D类IP地址的<strong>网络标识</strong>长32位，没有主机标识，因此常用于多播。</p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>IP地址总长度32位，它能表示的主机数量有限，大约在43亿左右。而IP地址分类更是造成了极大的浪费，A、B类地址一共也就一万多个，而世界上包含主机数量超过254的网段显然不止这么点。</p><p>我们知道IP地址分类的本质是区分网络标识和主机标识，另一种更加灵活、细粒度的区分方法是使用子网掩码。使用原A,B,C,D类等分类中的主机地址部分用作子网地址,可以将原网络分为多个物理网络的一种机制。</p><p>子网是指一个ip地址上生成的逻辑网络，它可以让一个网络地址跨越多个物理网络，即一个网络地址代表多个网络（很明显这样做可以节省ip地址）。呵呵，听起来是不是很蹊跷？一个网络就这样被莫名其妙的划分成了许多子网？那么这样做有什么用呢？</p><p>我举个例子来跟你说吧：比如你是某个学校的网管，你的学校有四个处于不同物理位置的网络教室，每个网络教室25台机器，你的任务是给这些机器配置ip地址和子网掩码。你可能会觉得这再简单不过了，申请4个C类地址，每个教室一个，然后在一一配置不就搞定了。嗯，这样做理论上没错，但你有没有想到这样做很浪费，你一共浪费了(254-25)*4=916个ip地址，如果所有的网管都像你这样做，那么internet上的ip地址将会在极短的时间内枯竭，显然，你是不能这样做，你应该做子网划分。</p><p>子网划分说白了是这样一个事情：因为在划分了子网后，ip地址的网络号是不变的，因此在局域网外部看来，这里仍然只存在一个网络，即网络号所代表的那个网络；但在网络内部却是另外一个景象，因为我们每个子网的子网号是不同的，当用化分子网后的ip地址与子网掩码（注意，这里指的子网掩码已经不是缺省子网掩码了，而是自定义子网掩码，是管理员在经过计算后得出的）做’与’运算时，每个子网将得到不同的子网地址，从而实现了对网络的划分（得到了不同的地址，当然就能区别出各个子网了，有趣吧）。</p><p>子网编址技术，即子网划分将会有助于以下问题的解决：<br>1）巨大的网络地址管理耗费：如果你是一个A类网络的管理员，你一定会为管理数量庞大的主机而头痛的；<br>2）路由器中的选路表的急剧膨胀：当路由器与其他路由器交换选路表时，互联网的负载是很高的，所需的计算量也很高；<br>3）IP地址空间有限并终将枯竭：这是一个至关重要的问题，高速发展的internet,使原来的编址方法不能适应，而一些ip地址却不能被充分的利用，造成了浪费。<br>因此，在配置局域网或其他网络时，根据需要划分子网是很重要的，有时也是必要的。现在，子网编址技术已经被绝大多数局域网所使用。</p><p>子网掩码长度也是32位，由一段连续的1和一段连续的0组成。1的长度就表示网络标识的长度。以IP地址172.20.100.52为例，它本来是一个B类IP地址(前16位是网络标识)，但通过子网掩码，它可以是前26为为网络标识的IP地址：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-7c0b25bec1fa8db7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子网掩码.png"></p><h4 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h4><p>互联网是由路由器连接的网络组合而成的。为了能让数据包正确的到达目标主机,路由器必须在途中进行正确的转发。<br>这种”正确的方向”转发数据所进行的处理就叫做路由控制或路由。</p><p>路由控制是指将分组数据发送到最终目标地址的功能。</p><p>“跳”指网络的一个区间。IP包正是在网络中一个跳间被转发。因此IP路由也叫做多跳路由。在每一个区间内决定着包在下一条被转发的路径。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-7c431d0b24f3f639.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳.png"></p><p>路由器是根据由控制表转发数据包。它根据所收到的数据包中目标主机的IP地址与路由控制表的比较得出下一个应该接收的路由器。</p><p>为了将数据包发给目标主机,所有主机都维护者一张路由控制表。 该表记录IP数据在下一步应该发给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-90a7a23ba288889a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="路由控制表.png"></p><p>路由控制分为静态和动态两种类型。<br>静态:通常是由使用者手工操作完成的,是指事先设置好路由器和主机中并将路由信息固定的一种方法。<br>动态:让管理者设置好的路由协议在运行过程中自动的设置路由控制信息的一种方法。</p><h4 id="IP分割处理"><a href="#IP分割处理" class="headerlink" title="IP分割处理"></a>IP分割处理</h4><p>IP是实现多个数据链路之间通信的协议。<br>但是不同的数据链路,它们各自的最大传输单位不同。</p><p>为了解决这个问题,IP进行分片处理。将较大的IP包分成多个较小的IP包。分片的包到达了对端目标地址以后会再备注合起来传给上一层。经过分片之后的IP数据报在被重组的时候,只能由目标主机进行。路由器虽然做分片,但不会进行重组。</p><h4 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h4><p>分片会加重路由器的负担，因此只要条件允许，我们都不希望路由器对IP数据包进行分片处理。另外，如果一个分片丢失，整个IP数据报都会作废。</p><p>解决以上问题的技术是“路径MTU发现”。主机会首先获取整个路径中所有数据链路的最小MTU，并按照整个大小将数据分片。因此传输过程中的任何一个路由器都不用进行分片工作。</p><p>为了找到路径MTU，主机首先发送整个数据包，并将IP首部的禁止分片标志设为1.这样路由器在遇到需要分片才能处理的包时不会分片，而是直接丢弃数据并通过ICMP协议将整个不可达的消息发回给主机。</p><p>主机将ICMP通知中的MTU设置为当前MTU，根据整个MTU对数据进行分片处理。如此反复下去，直到不再收到ICMP通知，此时的MTU就是路径MTU。</p><p>以UDP协议发送数据为例：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-bbf2394632f4a2b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MTU路径.png"></p><h3 id="IPv4首部"><a href="#IPv4首部" class="headerlink" title="IPv4首部"></a>IPv4首部</h3><p>通过IP进行通信是,需要在数据的前面加入IP首部信息。IP首部中包含着用于IP协议进行发包控制时所有的必要信息。所以,为了对IP所提供的功能有一个详细的把握,还是有必要了解下IP首部的结构的。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-432a2bfa15bb5f5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IPv4首部.png"></p><p>其中几个重要的部分介绍如下：</p><ul><li><p>总长度(Total Length)：表示IP首部与数据部分总的字节数，该段长16比特，所以IP包的最大长度为65535字节(2^16)。虽然不同数据链路的MTU不同，但是IP协议屏蔽了这些区别，通过自己实现的数据分片功能，从上层的角度来看，IP协议总是能够以65535为最大包长进行传输。</p></li><li><p>标识（ID：Identification）：用于分片重组。属于同一个分片的帧的ID相同。但即使ID相同，如果目标地址、源地址、上层协议中有任何一个不同，都被认为不属于同一个分片。</p></li><li><p>标志（Flags）：由于分片重组，由三个比特构成。</p><p>  第一个比特未使用，目前必须是0。</p><p>  第二个比特表示是否进行分片，0表示可以分片，1表示不能分片。在路径MTU发现技术中就用到了这个位。</p><p>  第三个比特表示在分片时，是否表示最后一个包。1表示不是最后一个包，0表示分配中最后一个包。</p></li><li><p>片偏移（FO: Fragment Offset）：由13比特组成，表示被分片的段相对于原始数据的位置。它可以表示8192(2^13)个位置，单位为8字节，所以最大可以表示8 x 8192 = 65536字节的偏移量。</p></li><li><p>生存时间（TTL: Time To Live）：表示包可以经过多少个路由器的中转。每经过一个路由器，TTL减1。这样可以避免前文提到的无限传递包的问题。</p></li><li><p>协议： 表示IP首部的下一个首部属于哪个协议。比如TCP协议的编号为6，UDP编号为17.</p></li><li><p>首部校验和：用于检查IP首部是否损坏</p></li><li><p>源地址:由32比特构成(4个字节),表示发送端IP地址。</p></li><li><p>目标地址:由32比特构成(4个字节),表示接收端IP地址。</p></li><li><p>可选项：仅在试验或诊断时用，可以没有。如果有，需要配合填充（Padding）占满32比特。</p></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv6是为了根本解决IPv4地址耗尽的问题而被标准化的网际协议。IPv4地址长度32比特,而IPv6地址长度128比特,一般写成8个16位字节。</p><h4 id="IPv6特点"><a href="#IPv6特点" class="headerlink" title="IPv6特点"></a>IPv6特点</h4><ul><li>IP地址的扩大与路由控制表的聚合</li><li>性能提升</li><li>支持即插即用功能</li><li>采用认证与加密功能</li><li>多播、Mobile IP成为拓展功能</li></ul><h4 id="IPv6中IP地址的标记方法"><a href="#IPv6中IP地址的标记方法" class="headerlink" title="IPv6中IP地址的标记方法"></a>IPv6中IP地址的标记方法</h4><p>一般人们将128比特IP地址以每16比特为一组,每组用冒号(“:”)隔开进行标记。而且如果出现连续的0时还可以将这些0省略掉,并用冷儿冒号(“::”)隔开。但是一个IP地址中只允许出现一次两个连续的冒号。</p><p>在互联网通信中,使用一种全局的单播地址。他是互联万中唯一的一个地址,不需要正式分配IP地址。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-60271ba14b0bfb04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单播.png"></p><h4 id="IPv6首部"><a href="#IPv6首部" class="headerlink" title="IPv6首部"></a>IPv6首部</h4><p><img src="http://upload-images.jianshu.io/upload_images/1868951-96b4ed3cb73e2590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IPv6首部.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;IP相当于OSI参考模型的第3层–网络层:主要作用是”实现终端节点之间的通信”又称”点对点通信”。&lt;/p&gt;
&lt;p&gt;IP作为整个TCP/IP中
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TCP-IP笔记(三)数据链路层</title>
    <link href="http://yoursite.com/2017/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%AC%94%E8%AE%B0(%E4%B8%89)%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://yoursite.com/2017/03/14/计算机网络/TCP-IP笔记(三)数据链路层/</id>
    <published>2017-03-14T01:55:00.000Z</published>
    <updated>2017-10-30T05:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据链路的作用"><a href="#数据链路的作用" class="headerlink" title="数据链路的作用"></a>数据链路的作用</h3><p>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外线等介质。此外,各个设备之间有时也会通过交换机、网桥、中继器等中转数据。</p><p>实际上,各个设备之间在数据传输时,数据链路层和物理层都是必不可少的。众所周知,计算机以二级制0、1来表示信息,然而实际的通信媒介之间处理的却是电压的高低、光的闪灭以及光波的强弱等信号。把这些信号与二进制的0、1进行转换正式物理层的责任。数据链路层处理的数据也不是单纯的0、1序列,该层把他们集合为一个叫做帧的块,然后再进行传输。</p><p>网络的连接和构成的形态成为<strong>网络拓扑</strong><br>包括:总线型,环型,星型和网状型。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-ade6679c7c100837.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络拓扑.png"></p><h3 id="数据链路相关作用"><a href="#数据链路相关作用" class="headerlink" title="数据链路相关作用"></a>数据链路相关作用</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>用于识别数据链路中互连的节点,地址长48比特,一般用16进制数表示。在使用网卡的情况下,MAC地址会被烧入到ROM中。因此,任何一个网卡的MAC地址都是唯一的。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-7b2d9e2617377b98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MAC地址.png"></p><p>从通信介质的使用方法上看,网络可分为共享介质型和非共享介质型。<br>共享介质型有两种介质访问控制方式:一种是争用方式,另一种是令牌传递方式。</p><h4 id="MAC地址转发"><a href="#MAC地址转发" class="headerlink" title="MAC地址转发"></a>MAC地址转发</h4><p>以太网交互机会根据数据链路层中每个目标MAC地址,决定从哪个网络接口发送数据。这时所参考的、用意记录发送接口的表就叫做转发表。<br>转发表并非手动设置，而是交换机自动学习得到的。当某个设备向交换机发送帧时，交换机将帧的源 MAC 地址和接口对应起来，作为一条记录添加到转发表中。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-2663e11f7777955a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自学.png"><br>当设备数量增加时,转发表也会随之变大,检索转发表所用的时间就越来越长,所有,有必要将网络分成多个数据链路,采用类似于网络层的IP地址一样对地址进行分层管理。</p><h4 id="环路检测方式"><a href="#环路检测方式" class="headerlink" title="环路检测方式"></a>环路检测方式</h4><ul><li>生成树方式</li><li>源路由法</li></ul><h3 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h3><p>以太网帧的开头是“前导码(Preamble)”，长度为 8 字节，这一段没什么用，重点在于以太网帧的本体。</p><p>本体由首部，数据和 FCS 三部分组成：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-bc39f19caf6de988.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以太网帧.png"></p><p>类型部分存储了上层协议的编号，比如上层是 IP 协议，则编号为 0800。</p><p>FCS 表示帧校验序列(Frame Check Sequence)，用于判断帧是否在传输过程中有损坏(比如电子噪声干扰)。FCS 保存着发送帧除以某个多项式的余数，接收到的帧也做相同计算，如果得到的值与 FCS 相同则表示没有出错。</p><h3 id="无线通信"><a href="#无线通信" class="headerlink" title="无线通信"></a>无线通信</h3><p> 无线通信通常使用电磁波、红外线、激光等方式进行传播数据。一般在办公室的局域网范围内组成的较高速的连接成为无线局域网。</p><h4 id="IEEE802-11"><a href="#IEEE802-11" class="headerlink" title="IEEE802.11"></a>IEEE802.11</h4><p>IEEE802.11定义了无线LAN协议中物理层与数据链路层的一部分(MAC层)。IEEE802.11这个编号有时指众多标准的统称,有时也只无线LAN的一种通信方式。主要针对笔记本电脑这样较大的计算机设备的标准。</p><h4 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h4><p>是使用2.4GHz频率无线电波的一种标准,主要为手机或者智能手机、键盘、鼠标等较小设备而设计的标准。</p><h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><p>PPP是指点对点,及1对1连接计算机的协议。<br>以太网使用同轴电缆或双绞线电缆,它可以决定其中的0,1该被解释为何种电子信号。与之相比,PPP属于纯粹的数据链路层,与物理层没有任何关系。及仅有PPP无法实现通信,还需要有物理层的支持。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-138ac0a0cdd1ab48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PPP.png"><br>PPP可以使用电话线或ISDN、专线、ATM线路。</p><h4 id="LCP与NCP"><a href="#LCP与NCP" class="headerlink" title="LCP与NCP"></a>LCP与NCP</h4><p>在开始进行数据传输前,要先建立一个PPP级连接。这个连接建立以后就可以进行身份认证、压缩与加密。<br>PPP包括两个协议:</p><ul><li><p>不依赖上层的LCP协议: 主要负责建立和断开连接、设置最大接收单元、设置验证协议以及设置是否进行通信质量的监控。</p></li><li><p>依赖上层的NCP(如上层为IP,也叫做IPCP)协议:负责IP地址设置以及是否进行TCP/IP首部压缩设备。</p><h4 id="PPP的帧格式"><a href="#PPP的帧格式" class="headerlink" title="PPP的帧格式"></a>PPP的帧格式</h4></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-278edc30b081b163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" PPP的帧格式.png"></p><h4 id="PPP0E"><a href="#PPP0E" class="headerlink" title="PPP0E"></a>PPP0E</h4><p>单纯的以太网没有验证功能,也没有建立和断开连接的处理,因此无法按时计费。而如果采用PPPoE管理以太网连接,就可以利用PPP的验证等功能使各家ISP可以有效地管理终端用户的使用。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-b47a14f7efc3c4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PPP0E.png"></p><h3 id="主要数据链路类型及特点"><a href="#主要数据链路类型及特点" class="headerlink" title="主要数据链路类型及特点"></a>主要数据链路类型及特点</h3><p><img src="http://upload-images.jianshu.io/upload_images/1868951-c8803ccde6b8a280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-14 上午9.47.42.png"></p><h3 id="公共网络"><a href="#公共网络" class="headerlink" title="公共网络"></a>公共网络</h3><p>公共通信服务类似于电信运营商(如NTT、KDDI或软银等)提供的电话网络。人们通过这些运营商签约、付费不仅可以实现联网还可以与距离遥远的机构组织进行通信。<br>常见的有模拟电话线路、移动通信、ADSL、FTTH、有线电视、专线、VPB以及公共无线LAN等内容。自行了解下就好,就不一一介绍了。</p><p>关于数据链路层，最重要的一点还是它的定义：“通过通信介质相互连接的设备之间，数据传输的规范”。这说明数据链路层的协议适用于处于同一种数据链路两端的节点。如果不能理解这一点，就无法理解网络层和 IP 协议。</p><p>数据链路层的意义在于，如果没有数据链路层，数据只能以流的形式存在与通信介质中，不知道该发送往哪里，过长的数据流可能无法在通信介质中传输。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据链路的作用&quot;&gt;&lt;a href=&quot;#数据链路的作用&quot; class=&quot;headerlink&quot; title=&quot;数据链路的作用&quot;&gt;&lt;/a&gt;数据链路的作用&lt;/h3&gt;&lt;p&gt;数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。通信媒介包括双绞线电缆、同轴电缆、光纤、
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>带你了解UIKit动力学</title>
    <link href="http://yoursite.com/2017/03/14/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3UIKit%E5%8A%A8%E5%8A%9B%E5%AD%A6/"/>
    <id>http://yoursite.com/2017/03/14/动画与绘图/带你了解UIKit动力学/</id>
    <published>2017-03-14T01:23:27.000Z</published>
    <updated>2017-10-30T04:23:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、简单介绍"><a href="#一、简单介绍" class="headerlink" title="一、简单介绍"></a>一、简单介绍</h3><p>1.什么是UIDynamic<br>UIDynamic是从iOS 7开始引入的一种新技术，隶属于UIKit框架可以认为是一种物理引擎，能模拟和仿真现实生活中的物理现象如：重力、弹性碰撞等现象</p><p>2.物理引擎的价值<br>广泛用于游戏开发，经典成功案例是“愤怒的小鸟”,让开发人员可以在远离物理学公式的情况下，实现炫酷的物理仿真效果提高了游戏开发效率，产生更多优秀好玩的物理仿真游戏</p><p>3.知名的2D物理引擎<br>Box2d<br>Chipmunk</p><h3 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h3><p>要想使用UIDynamic来实现物理仿真效果，大致的步骤如下:</p><p>1.创建一个物理仿真器（顺便设置仿真范围）<br>2.创建相应的物理仿真行为（顺便添加物理仿真元素）<br>3.将物理仿真行为添加到物理仿真器中开始仿真</p><h3 id="三、相关说明"><a href="#三、相关说明" class="headerlink" title="三、相关说明"></a>三、相关说明</h3><p>1.三个概念</p><ul><li>谁要进行物理仿真？<br>　　物理仿真元素（Dynamic Item）</li><li>执行怎样的物理仿真效果？怎样的动画效果？<br>　　物理仿真行为（Dynamic Behavior） </li><li>让物理仿真元素执行具体的物理仿真行为<br>　　物理仿真器（Dynamic Animator）</li></ul><p>2.物理仿真元素<br>注意：<br>不是任何对象都能做物理仿真元素<br>不是任何对象都能进行物理仿真</p><p>物理仿真元素要素：<br>任何遵守了UIDynamicItem协议的对象<br>UIView默认已经遵守了UIDynamicItem协议，因此任何UI控件都能做物理仿真</p><p>UICollectionViewLayoutAttributes类默认也遵守UIDynamicItem协议</p><p>3.物理仿真行为</p><p>（1）UIDynamic提供了以下几种物理仿真行为</p><ul><li>UIGravityBehavior：重力行为</li></ul><ul><li><p>UICollisionBehavior：碰撞行为</p></li><li><p>UISnapBehavior：捕捉行为</p></li><li><p>UIPushBehavior：推动行为</p></li><li><p>UIAttachmentBehavior：附着行为</p></li><li><p>UIDynamicItemBehavior：动力元素行为</p></li></ul><p>（2）物理仿真行为须知<br>上述所有物理仿真行为都继承自UIDynamicBehavior，所有的UIDynamicBehavior都可以独立进行组合使用多种行为时，可以实现一些比较复杂的效果</p><p>4.物理仿真器</p><p>（1）物理仿真器须知<br>它可以让物理仿真元素执行物理仿真行为<br>它是UIDynamicAnimator类型的对象<br>（2）UIDynamicAnimator的初始化</p><pre><code>- (instancetype)initWithReferenceView:(UIView *)view;`&lt;/pre&gt;view参数：是一个参照视图，表示物理仿真的范围5.物理仿真器的说明（1）UIDynamicAnimator的常见方法&lt;pre&gt;`//移除之前添加过的所有物理仿真行为  - (void)addBehavior:(UIDynamicBehavior *)behavior; //移除之前添加过的所有物理仿真行为　- (void)removeBehavior:(UIDynamicBehavior *)behavior; //添加1个物理仿真行为　- (void)removeAllBehaviors; `&lt;/pre&gt;（2）UIDynamicAnimator的常见属性&lt;pre&gt;` //参照视图 @property (nonatomic, readonly) UIView* referenceView;  //添加到物理仿真器中的所有物理仿真行为@property (nonatomic, readonly, copy) NSArray* behaviors;//是否正在进行物理仿真@property (nonatomic, readonly, getter = isRunning) BOOL running;//代理对象（能监听物理仿真器的仿真过程，比如开始和结束）@property (nonatomic, assign) id `&lt;/pre&gt;### 四、案例介绍**先看效果吧**- UIGravityBehavior：重力行为![UIGravityBehavior.gif](http://upload-images.jianshu.io/upload_images/1868951-9cd5fca7213318f5.gif?imageMogr2/auto-orient/strip)</code></pre><ul><li><p>UICollisionBehavior：碰撞行为</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-708e87550affbb35.gif?imageMogr2/auto-orient/strip" alt="UICollisionBehavior.gif"></p></li><li><p>UISnapBehavior：捕捉行为</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-52ed8f15d48010b5.gif?imageMogr2/auto-orient/strip" alt="UISnapBehavior.gif"></p></li><li><p>UIPushBehavior：推动行为</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1853b803c4d6db02.gif?imageMogr2/auto-orient/strip" alt="UIPushBehavior.gif"></p></li><li><p>复合效果</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3cebeb72c623eb4e.gif?imageMogr2/auto-orient/strip" alt="复合效果.gif"></p><p><strong>最后是代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line">&lt;pre&gt;`#import &amp;lt;UIKit/UIKit.h&amp;gt;</div><div class="line"></div><div class="line">@interface SecondViewController : UIViewController</div><div class="line">@property (weak, nonatomic) IBOutlet UIView *blueView;</div><div class="line">@property (weak, nonatomic) IBOutlet UIView *orangeView;</div><div class="line">@property (weak, nonatomic) IBOutlet UISegmentedControl *segmented;</div><div class="line">@property (weak, nonatomic) IBOutlet UIView *redView;</div><div class="line">@property (nonatomic,strong) UIDynamicAnimator *animator;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;SecondViewController.h&quot;</div><div class="line"></div><div class="line">@interface SecondViewController ()</div><div class="line">@property (nonatomic,strong)UISnapBehavior *snapBehavior;</div><div class="line">@property (nonatomic,strong)UIPushBehavior *pushBehavior;</div><div class="line">@property (nonatomic,strong)UIAttachmentBehavior *attachmentBehavior;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation SecondViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    self.blueView.transform =  CGAffineTransformMakeRotation(M_PI_4);</div><div class="line">    self.segmented.transform = CGAffineTransformMakeRotation(-M_PI / 8);</div><div class="line"></div><div class="line">    if (!_pushBehavior) &#123;</div><div class="line">        _pushBehavior = [[UIPushBehavior alloc]initWithItems:@[_blueView] mode:UIPushBehaviorModeContinuous];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _pushBehavior.active = YES;</div><div class="line">    _pushBehavior.pushDirection = CGVectorMake(10.0f, 10.0f);</div><div class="line">    _pushBehavior.magnitude = 1.0f;</div><div class="line">    [self.animator addBehavior:_pushBehavior];</div><div class="line"></div><div class="line">&#125;</div><div class="line">- (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:    (UIEvent *)event &#123;</div><div class="line">    _pushBehavior.active = NO;</div><div class="line"></div><div class="line">    //创建重力行为</div><div class="line">    UIGravityBehavior *gravityBehavior = [[UIGravityBehavior alloc]init];</div><div class="line">    [gravityBehavior addItem:self.blueView];</div><div class="line">    [gravityBehavior addItem:self.orangeView];</div><div class="line">    [gravityBehavior addItem:self.segmented];</div><div class="line">    gravityBehavior.gravityDirection = CGVectorMake(-0.3f, 1.0f);</div><div class="line">    //加速度</div><div class="line">    gravityBehavior.magnitude = 3;</div><div class="line">    //创建碰撞行为</div><div class="line">    UICollisionBehavior *collisionBehavior = [[UICollisionBehavior alloc]init];</div><div class="line">    //碰撞类型为元素和边界</div><div class="line">    collisionBehavior.collisionMode = UICollisionBehaviorModeEverything;</div><div class="line"></div><div class="line">    CGFloat Y = self.view.frame.size.height - CGRectGetHeight(self.redView.frame);</div><div class="line">    CGFloat X = self.view.frame.size.width;</div><div class="line">    CGFloat height = self.view.frame.size.height;</div><div class="line"></div><div class="line">    //设置红色的View为底边界,左边框跟右边框作为边界</div><div class="line">    [collisionBehavior addBoundaryWithIdentifier:@&quot;collision1&quot; fromPoint:CGPointMake(0,Y) toPoint:CGPointMake(X, Y)];</div><div class="line">    [collisionBehavior addBoundaryWithIdentifier:@&quot;collision2&quot; fromPoint:CGPointMake(0, 0) toPoint:CGPointMake(0, height)];</div><div class="line">    [collisionBehavior addBoundaryWithIdentifier:@&quot;collision3&quot; fromPoint:CGPointMake(X,0) toPoint:CGPointMake(X, height)];</div><div class="line"></div><div class="line">    [collisionBehavior addItem:self.blueView];</div><div class="line">    [collisionBehavior addItem:self.segmented];</div><div class="line">    [collisionBehavior addItem:self.orangeView];</div><div class="line">    [self.animator addBehavior:collisionBehavior];</div><div class="line">    [self.animator addBehavior:gravityBehavior];</div><div class="line"></div><div class="line">    UIDynamicItemBehavior *itemBehavior = [[UIDynamicItemBehavior alloc] initWithItems:@[self.blueView]];</div><div class="line">    [itemBehavior setElasticity:0.5];</div><div class="line">    [self.animator addBehavior:itemBehavior];</div><div class="line"></div><div class="line">    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapGesture:)];</div><div class="line">    [self.view addGestureRecognizer:tap];</div><div class="line">&#125;</div><div class="line">- (void)tapGesture:(UITapGestureRecognizer *)gesture</div><div class="line">&#123;</div><div class="line">    CGPoint tapPoint = [gesture locationInView:self.view];</div><div class="line">    if (_snapBehavior) &#123;</div><div class="line">        [self.animator removeBehavior:_snapBehavior];</div><div class="line">        _snapBehavior = nil;</div><div class="line">    &#125;</div><div class="line">    _snapBehavior = [[UISnapBehavior alloc]initWithItem:self.blueView snapToPoint:tapPoint];</div><div class="line">    _snapBehavior.action = ^()&#123;</div><div class="line">        NSLog(@&quot;UISnapBehavior 在执行&quot;);</div><div class="line">    &#125;;</div><div class="line">    _snapBehavior.damping = 0.9;</div><div class="line">    [self.animator addBehavior:_snapBehavior];</div><div class="line">&#125;</div><div class="line">- (UIDynamicAnimator *)animator&#123;</div><div class="line">    if (_animator == nil) &#123;</div><div class="line">        _animator = [[UIDynamicAnimator alloc]init];</div><div class="line">    &#125;</div><div class="line">    return _animator;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)panGestureRecognizer:(UIPanGestureRecognizer *)gesture</div><div class="line">&#123;</div><div class="line">    CGPoint location = [gesture locationInView:self.view];</div><div class="line">    CGPoint imageLocation = [gesture locationInView:self.orangeView];</div><div class="line">    switch (gesture.state) &#123;</div><div class="line">        case UIGestureRecognizerStateBegan:</div><div class="line">        &#123;</div><div class="line">            NSLog(@&quot;touch position %@&quot;,NSStringFromCGPoint(location));</div><div class="line">            NSLog(@&quot;loction in image %@&quot;,NSStringFromCGPoint(imageLocation));</div><div class="line">            [self.animator removeAllBehaviors];</div><div class="line"></div><div class="line">            UIOffset centerOffset = UIOffsetMake(imageLocation.x - CGRectGetMidX(self.orangeView.bounds), imageLocation.y - CGRectGetMidY(self.orangeView.bounds));</div><div class="line">            _attachmentBehavior = [[UIAttachmentBehavior alloc]initWithItem:self.orangeView offsetFromCenter:centerOffset attachedToAnchor:location];</div><div class="line">            _attachmentBehavior.damping = 0.5;</div><div class="line">            _attachmentBehavior.frequency = 0.8;</div><div class="line">            [self.animator addBehavior:_attachmentBehavior];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case UIGestureRecognizerStateEnded:</div><div class="line">        &#123;</div><div class="line">            [self.animator removeBehavior:_attachmentBehavior];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">        &#123;</div><div class="line">            [_attachmentBehavior setAnchorPoint:[gesture locationInView:self.view]];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">    // Dispose of any resources that can be recreated.</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line"> #pragma mark - Navigation</div><div class="line"></div><div class="line"> // In a storyboard-based application, you will often want to do a little preparation before navigation</div><div class="line"> - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</div><div class="line"> // Get the new view controller using [segue destinationViewController].</div><div class="line"> // Pass the selected object to the new view controller.</div><div class="line"> &#125;</div><div class="line"> */</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></li></ul><p>UIKit动力学的部分介绍完了.<br>最开始项目中只是用到了重力跟碰撞行为,参考学习了:<a href="http://www.jianshu.com/p/07552fc17734" target="_blank" rel="external">UIDynamic 详细用法</a> 中的案例.然后自己又展开了解了下UIKit动力学的知识,把捕捉行为,推动行为加了进去,做个完善.整理了一下.就是这样.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、简单介绍&quot;&gt;&lt;a href=&quot;#一、简单介绍&quot; class=&quot;headerlink&quot; title=&quot;一、简单介绍&quot;&gt;&lt;/a&gt;一、简单介绍&lt;/h3&gt;&lt;p&gt;1.什么是UIDynamic&lt;br&gt;UIDynamic是从iOS 7开始引入的一种新技术，隶属于UIKit框
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="动画与绘图" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>TCP-IP笔记(二)TCP-IP简介</title>
    <link href="http://yoursite.com/2017/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%AC%94%E8%AE%B0(%E4%BA%8C)TCP-IP%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/03/13/计算机网络/TCP-IP笔记(二)TCP-IP简介/</id>
    <published>2017-03-13T08:04:00.000Z</published>
    <updated>2017-10-30T05:56:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>  <a href="http://www.jianshu.com/p/782be6ec66ab" target="_blank" rel="external">上回</a>,主要介绍了下协议和OSI参考模型,并简单了解下网络构成要素,这回该说说TCP/IP了</p><h3 id="互联网与TCP-IP的关系"><a href="#互联网与TCP-IP的关系" class="headerlink" title="互联网与TCP/IP的关系"></a>互联网与TCP/IP的关系</h3><p>  互联网进行通信时,需要相应的网络协议,TCP/IP原本就是为使用互联网而开发定制的协议族。因此,互联网的协议就是TCP/IP,TCP/IP就是互联网的协议。<br>  <strong>知道了解TCP/IP的重要性了吧,那就好好看看吧</strong></p><h3 id="TCP-IP的诞生"><a href="#TCP-IP的诞生" class="headerlink" title="TCP/IP的诞生"></a>TCP/IP的诞生</h3><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3f6079fcf1afc2e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="诞生.png"></p><h3 id="TCP-IP的标准化"><a href="#TCP-IP的标准化" class="headerlink" title="TCP/IP的标准化"></a>TCP/IP的标准化</h3><p>  20世纪90年代,ISO开展了OSI这一国际标准协议的标准化进程。然而OSI协议并没有得到普及,真正被广泛使用的是TCP/IP协议。</p><p>  那么为什么OSI失败了呢?</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-afe17e0fd73484b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSI失败.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-9c09038c5230ce00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSI失败原因.png"></p><p>那TCP/IP好在哪儿呢?</p><ul><li>开放性</li><li>注重实用性</li></ul><p>  由于TCP/IP尽早地制定了可行性较强的协议，提出了应对技术快速革新的协议，并及时进行后期改良的方案，因此打败了OSI模型，成为了事实上的标准。</p><h3 id="TCP-IP协议分层模型"><a href="#TCP-IP协议分层模型" class="headerlink" title="TCP/IP协议分层模型"></a>TCP/IP协议分层模型</h3><p><img src="http://upload-images.jianshu.io/upload_images/1868951-4b513cf743603420.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分层模型.png"></p><p>　　上图列出了TCP/IP与OSI分层之间的大概关系，不难看出，TCP/IP与OSI在分层模块上稍有区别。OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更强调<strong>“在计算机上实现协议应该开发哪种程序”</strong>。</p><p>　在 TCP/IP 模型中,网络访问层是 TCP/IP 模型的最低层,负责接收从网际层交来的 IP 数据报并将 IP 数据报通过底层物理网络发送出去,或者从底层物理网络上接收物理帧,抽出 IP 数据报,交给互联网层。网络访问层使采用不同技术和网络硬件的网络之间能够互联, 它包括属于操作系统的设备驱动器和计算机网络接口卡,以处理具体的硬件物理接口。</p><p>　　网际层负责独立地将分组从源主机送往目标主机,涉及为分组提供最佳路径的选择和 交换功能,并使这一过程与它们所经过的路径和网络无关。这好比你寄信时,你并不需要知道它是如何到达目的地的,而只关心它是否到达了。TCP/IP 模型的互联网层在功能上非常类似于 OSI 参考模型中的网络层。</p><p>　　传输层的作用与 OSI 参考模型中传输层的作用是类似的,即在源结点和目的结点的两个对等实体间提供可靠的端到端的数据通信。为保证数据传输的可靠性,传输层协议也提供了确认、差错控制和流量控制等机制。另外,由在一般的计算机中,常常是多个应用程序同时访问网络,所以传输层还要提供不同应用程序的标识。</p><p>　　应用层涉及为用户提供网络应用,并为这些应用提供网络支撑服务。由于 TCP/IP 将所有与应用相关的内容都有归为一层,所以在应用层要处理高层协议、数据表达和对话控制等任务。 </p><h3 id="OSI-模型和-TCP-IP-模型的区别"><a href="#OSI-模型和-TCP-IP-模型的区别" class="headerlink" title="OSI 模型和 TCP/IP 模型的区别"></a>OSI 模型和 TCP/IP 模型的区别</h3><p><img src="http://upload-images.jianshu.io/upload_images/1868951-a898ac81a2a44779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="区别.png"></p><p>  OSI 模型包括了七层,而 TCP/IP 模型只有四层。虽然它们具有功能相当的网络层、传输层和应用层,但其它层并不相同。</p><p>  TCP/IP 模型中没有专门的表示层和会话层,它将与这两层相关的表达、编码和会话控制等功能包含到了应用层中去完成。另外,TCP/IP 模型还将 OSI 的数据链路层和物理层包括到了一个网络访问层中。</p><p>  OSI 模型在网络层支持无连接和面向连接的两种服务,而在传输层仅支持面向连接的服 务。TCP/IP 模型在互联网层则只支持无连接的一种服务,但在传输层支持面向连接和无连 接两种服务。</p><p>  TCP/IP 由于有较少的层次,因而显得更简单,并且作为从因特网(INTERNET)上发展起来的协议,已经成了网络互连的事实标准。但是,目前还没有实际网络是建立在 OSI 七层模型基础上的,OSI 仅仅作为理论的参考模型被广泛使用。</p><h3 id="TCP-IP-通信示例"><a href="#TCP-IP-通信示例" class="headerlink" title="TCP/IP 通信示例"></a>TCP/IP 通信示例</h3><h4 id="数据包首部"><a href="#数据包首部" class="headerlink" title="数据包首部"></a>数据包首部</h4><p><img src="http://upload-images.jianshu.io/upload_images/1868951-945f3b55eb76f974.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据包首部.png"></p><p>  每个分层中,都会对所发送的数据附加一个首部,在这个首部中包含了该层必要的信息,如发送的目标地址以及协议相关信息。通常,为协议提供的信息为包首部,所要发送的内容为数据。</p><p>  现在再来看看主机A向主机B发送一封电子邮件，在TCP/IP模型下的处理过程：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-09c5c11ee5b527d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电子邮件.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  &lt;a href=&quot;http://www.jianshu.com/p/782be6ec66ab&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上回&lt;/a&gt;,主要介绍了下协议和OSI参考模型,并简单了解下网络构成要素,这回该说说TCP/IP了&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TCP-IP笔记(一)网络基础知识</title>
    <link href="http://yoursite.com/2017/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%AC%94%E8%AE%B0(%E4%B8%80)%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2017/03/10/计算机网络/TCP-IP笔记(一)网络基础知识/</id>
    <published>2017-03-10T08:42:00.000Z</published>
    <updated>2017-10-30T05:56:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机与网络发展"><a href="#计算机与网络发展" class="headerlink" title="计算机与网络发展"></a>计算机与网络发展</h3><p>  计算机自诞生伊始,经历了一系列演变与发展。大型通用机计算机、超级计算机、小型机、个人电脑、工作站、便携式电以及现如今的智能手机终端都是这一过程的产物。它们性能逐年增强,价格却逐年下降,机体规模也在逐渐变小。</p><p>  随着计算机的发展,人们不再局限于单机模式,而是将一个个计算机连接在一起,形成一个计算机网络。从而实现信息共享,同事在能在两台物理位置较远的机器之间即时传递消息。</p><p>  计算机网络根据规模可以分为WAN(Wide Area Network,广域网)和LAN(Local Area Network,局域网)。</p><p>将有业务往来的计算机连在一起便组成了私有网络,将多个私有网络连接一起就成了为公众使用的互联网。</p><p>  随着互联网爆发性地发展与普及,信息网络如同我们身边的空气,触手可及。但是在以前,对一般人来说使用一台计算机都不是那么容易的事情。</p><p><strong>计算机与网络大致可以分为7个阶段:</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-24fdc0e1beb7860a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机使用模式的演变.png"><br>  互联网是由许多独立发展的网络通信技术融合而成。能够使它们之间不断融合并实现统一的正是TCP/IP技术。<br>   那什么是TCP/IP呢?<br>    TCP/IP是通信协议的统称。<br>    那什么是协议呢?</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="协议的必要性"><a href="#协议的必要性" class="headerlink" title="协议的必要性"></a>协议的必要性</h4><p>协议就是计算机与计算机之间通过网络实现通信事先达成的一种“约定”。这种“约定”使那些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。反之，如果使用的协议不同，就无法通信。</p><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-9a37ee1163e62d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP/IP 是互联网相关的各类协议族的总称 .png"></p><p>协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。</p><p>像这样把与互联网相关联的协议集合起来总称为 TCP/IP。也有说法认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP/ IP 是在 IP 协议的通信过程中，使用到的协议族的统称。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-fbb4ff87606a98bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机通信协议.png"></p><p><strong>分组交换</strong> 是将大数据分割为一个个叫做包（Packet）的较小单位进行传输的方法。这里所说的包，就如同我们平常在邮局里见到的邮包。分组交换就是将大数据分装为一个个这样的邮包交给对方。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3f6b62eeab6be537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分组交换.png"></p><h4 id="协议的标准化"><a href="#协议的标准化" class="headerlink" title="协议的标准化"></a>协议的标准化</h4><p>  在计算机通信诞生之初,系统化和标准化并未得到足够的重视。因此不同厂商的设备,由于支持的协议不同,仍然无法实现正常的通信。<br>就好比语言交流:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-48973be1fb252968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协议的标准化.png"><br>随着计算机重要性的不断提高,很多公司开始逐渐意思是兼容性的重要意义。<br>为了解决上述问题,ISO组织制定了一个国际标准OSI,对通信系统进行标准化。</p><p><strong>现在OSI所定义的协议虽然并没有得到普及,但是在OSI协议设计之初作为其指导方针的OSI参考模型却常被用于网络协议的制定当中。</strong></p><p>TCP/IP并非是ISO定制的国际标准,而是由IETF所致力与推进标准化作业的一种协议。现在也作为业界标准,俨然已成为全世界所广泛应用的通信协议。</p><p>   协议的标准化使得所有遵循标准协议的设备不再因计算机硬件或操作系统的差异而无法通信。因此,协议的标准化推动了计算机网络的普及。</p><h4 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h4><p>  ISO在制定标准化OSI之前,对网络体系结构相关的问题进行了充分的讨论并提出了作为通信协议涉及指标的OSI参考模型。这一模型将通信协议中的必要功能分成了7层。</p><p>  <strong> 为什么要分层呢?</strong></p><p>　如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。</p><p>   值得一提的是，层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题。</p><p>   协议分层就如同计算机软件中的<strong>模块化开发</strong></p><p>举个打电话的例子:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1ba9d663f91f31bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电话.png"></p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e6c32d0a8db7ee0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSI参考模型.png"></p><h4 id="OSI参考模型中每个层的作用："><a href="#OSI参考模型中每个层的作用：" class="headerlink" title="OSI参考模型中每个层的作用："></a>OSI参考模型中每个层的作用：</h4><p>1.物理层(Physical Layer)</p><p>　　物理层位于 OSI 参考模型的最低层,它直接面向原始比特流的传输。为了实现原始比特流的物理传输,物理层必须解决好包括传输介质、信道类型、数据与信号之间的转换、信号传输中的衰减和噪声等在内的一系列问题。另外,物理层标准要给出关于物理接口的机械、 电气、功能和规程特性,以便于不同的制造厂家既能够根据公认的标准各自独立地制造设备,又能使各个厂家的产品能够相互兼容。</p><p>2.数据链路层(Data Link Layer)</p><p>　　在物理层发送和接收数据的过程中,会出现一些物理层自己不能解决的问题。例如, 当两个节点同时试图在一条线路上发送数据时该如何处理?节点如何知道它所接收的数据 是否正确?如果噪声改变了一个分组的目标地址,节点如何察觉它丢失了本应收到的分组呢?这些都是数据链路层所必须负责的工作。</p><p>　　数据链路层涉及相邻节点之间的可靠数据传输,数据链路层通过加强物理层传输原始比特的功能,使之对网络层表现为一条无错线路。为了能够实现相邻节点之间无差错的数据传送,数据链路层在数据传输过程中提供了确认、差错控制和流量控制等机制。</p><p>3.网络层(Network Layer)</p><p>　　网络中的两台计算机进行通信时,中间可能要经过许多中间结点甚至不同的通信子网。 网络层的任务就是在通信子网中选择一条合适的路径,使发送端传输层所传下来的数据能 够通过所选择的路径到达目的端。</p><p>　　为了实现路径选择,网络层必须使用寻址方案来确定存在哪些网络以及设备在这些网络中所处的位置,不同网络层协议所采用的寻址方案是不同的。在确定了目标结点的位置后, 网络层还要负责引导数据包正确地通过网络,找到通过网络的最优路径,即路由选择。如果子网中同时出现过多的分组,它们将相互阻塞通路并可能形成网络瓶颈,所以网络层还需要提供拥塞控制机制以避免此类现象的出现。另外,网络层还要解决异构网络互连问题。</p><p>4.传输层(Transport Layer)</p><p>　　传输层是 OSI 七层模型中唯一负责端到端节点间数据传输和控制功能的层。传输层是 OSI 七层模型中承上启下的层,它下面的三层主要面向网络通信,以确保信息被准确有效地传输;它上面的三个层次则面向用户主机,为用户提供各种服务。</p><p>　　传输层通过弥补网络层服务质量的不足,为会话层提供端到端的可靠数据传输服务。它为会话层屏蔽了传输层以下的数据通信的细节,使会话层不会受到下三层技术变化的影响。但同时,它又依靠下面的三个层次控制实际的网络通信操作,来完成数据从源到目标的传输。传输层为了向会话层提供可靠的端到端传输服务,也使用了差错控制和流量控制等机制。</p><p>5.会话层(Session Layer)</p><p>　　会话层的功能是在两个节点间建立、维护和释放面向用户的连接。它是在传输连接的基础上建立会话连接,并进行数据交换管理,允许数据进行单工、半双工和全双工的传送。会话层提供了令牌管理和同步两种服务功能。</p><p>6.表示层(Presentation Layer)</p><p>　　表示层以下的各层只关心可靠的数据传输,而表示层关心的是所传输数据的语法和语义。它主要涉及处理在两个通信系统之间所交换信息的表示方式,包括数据格式变换、数据加密与解密、数据压缩与恢复等功能。</p><p>7.应用层(Application Layer)</p><p>　　应用层是 OSI 参考模型的最高层,负责为用户的应用程序提供网络服务。与 OSI 其他层不同的是,它不为任何其他 OSI 层提供服务,而只是为 OSI 模型以外的应用程序提供服务。包括为相互通信的应用程序或进行之间建立连接、进行同步,建立关于错误纠正和控 制数据完整性过程的协商等。应用层还包含大量的应用协议,如分布式数据库的访问、文件的交换、电子邮件、虚拟终端等。 </p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-d13f6ca5798b3f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="每个层的作用.png"></p><p>许多通信协议,都对应了OSI参考模型7个分层中的某层。通过这一点,可以大致了解该协议在整个通信功能中的位置和作用。<br><img src="http://upload-images.jianshu.io/upload_images/1868951-b70b962052e39a50.gif?imageMogr2/auto-orient/strip" alt="各层对应的协议"></p><p>举个例子：假设主机A的用户A要给主机B的用户B发送一封电子邮件：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6ea6ba3cc3d59b92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-10 上午10.27.04.png"></p><p>　发送方从第7层、第6层到第1层由上至下按照顺序传输数据，而接收端则从第1层、第2层到第7层由下至上向每个上一级分层传输数据。每个分层上，在处理由上一层传过来的数据时可以附上当前分层的协议所必须的“首部”信息。然后接收端对收到的数据进行数据“首部”与“内容”的分离，再转发给上一分层，并最终将发送端的数据恢复为原状。</p><h3 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h3><p>网络与通信中可以根据其数据发送方法进行多种分类。</p><ol><li>面向连接与面向无连接</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e0860a956a3d7dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏面向连接与面向无连接.png"></p><p>2.电路交换与分组交换</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0a259607b181f0e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电路交换与分组交换.png"></p><p>3.根据接收端数量来分</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-191e8eef54b435a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单播,广播,多播,任播.png"></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>   通信传输中,发送端和接收端都可以被视作通讯主体。它们都能由一个所谓的”地址”的信息标识出来。比如打电话,电话号码就是”地址”,比如寄快递,家庭住址就是”地址”。</p><p>在TCP/IP通信中使用MAC地址,IP地址,端口号等信息作为地址标识。甚至在应用层中可以将电子邮件地址作为网络通信的地址。</p><p>地址具有<strong>唯一性</strong><br>当地址总数多时,需要有<strong>层次性</strong>来快速定位。</p><h3 id="网络的构成要素"><a href="#网络的构成要素" class="headerlink" title="网络的构成要素"></a>网络的构成要素</h3><p>搭建一套网络环境要涉及到各种各样的电缆和网络设备。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6e189b0afaffd65b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构成及作用.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-9d29c855104afad4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各设备对应的网络分层.png"></p><ul><li>数据链路与通信媒介</li></ul><p>计算机之间通过电缆相互连接。电缆可以分为多种,包括双绞线电缆、光纤电缆、同轴电缆、串行电缆等。而媒介本身也可以被划分为电波、微波等不同类型的电磁波。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-520f38933628a5af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据链路.png"></p><ul><li>网卡<br>计算机连接网络时,必须要使用网卡,也被称作网络适配器、LAN卡。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-56fc60b0220828c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网卡.png"></p><ul><li>中继器</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3620a28242606b22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中继器.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1c6682f5e6511f76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中继集线器.png"></p><ul><li>网桥<br>位于OSI模型中的第二层–数据链路层上连接两个网络的设备。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3de2632f11c7ef7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网桥.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-2c56652f52fe6368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自学式网桥及交换集线器.png"></p><ul><li>路由器<br>路由器位于第三层–网络层上连接两个设备、并对分组保温进行转发的设备。<br>网桥是根据MAC地质处理的,路由器是根据IP地址进行处理的。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-8b75041239d274fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="路由器.png"></p><ul><li><p>4~7层交换机<br>负责处理OSI模型中从传输层至应用层的数据。用TCP/IP来表述的话,就是以TCP/IP等协议的传输层及其上面的应用层为基础,分析首发数据,并对其进行特定的处理。<br>主要功能:负载均衡器,带宽控制,广域网加速器,特殊应用访问加速,及防火墙等。</p></li><li><p>网关</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e423d61f84e63f05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网关.png"></p><p>举个例子:电脑跟手机邮件有时候会不兼容,需要网关的转换<br><img src="http://upload-images.jianshu.io/upload_images/1868951-206c0ce693b39859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-10 下午3.17.19.png"></p><p>有时候为了控制流量或保证安全,会有代理服务器,防火墙等都是网关的一种。</p><p>比如谷歌被墙啊:<br><img src="http://upload-images.jianshu.io/upload_images/1868951-0b2d9c28f4005719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="防火墙.png"></p><h3 id="现代网络实态"><a href="#现代网络实态" class="headerlink" title="现代网络实态"></a>现代网络实态</h3><p>看图吧:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-d45d0cd64a4725d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实际网络构成.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1e57df41ae6e9aa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移动通信.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f6e9e4649b6ac32e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据中心.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-96ccc729e8e096dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="云服务.png"></p><p>来个总结:</p><p>学习TCP/IP知识前需要先了解下计算机网络出现的背景及发展阶段,了解矛盾才能明白出现TCP/IP的必然性。<br>另外我们知道想要通信需要先遵守协议,为了更好的互联,要推动协议的标准化,然后标准化又促进了计算机网络的发展。<br>然后为了简便,谈到了协议的分层从而出现了OSI参考模型,知道了各层的分类及作用后,我们再看看现实生活中的网络构成及应用实态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机与网络发展&quot;&gt;&lt;a href=&quot;#计算机与网络发展&quot; class=&quot;headerlink&quot; title=&quot;计算机与网络发展&quot;&gt;&lt;/a&gt;计算机与网络发展&lt;/h3&gt;&lt;p&gt;  计算机自诞生伊始,经历了一系列演变与发展。大型通用机计算机、超级计算机、小型机、个人电脑
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>快速上手UIBezierPath</title>
    <link href="http://yoursite.com/2017/01/19/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BUIBezierPath/"/>
    <id>http://yoursite.com/2017/01/19/动画与绘图/快速上手UIBezierPath/</id>
    <published>2017-01-19T07:41:22.000Z</published>
    <updated>2017-10-30T04:23:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>UIBezierPath主要用来绘制矢量图形，它是基于Core Graphics对CGPathRef数据类型和path绘图属性的一个封装，所以是需要图形上下文的（CGContextRef），所以一般UIBezierPath在drawRect中使用。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>UIBezierPath 是对 CGPathRef 的封装。创建矢量图形时，拆解成一或多条线段，拼接起来，每条线段的终点都是下一条线段的起点。</p><p>具体地：</p><p>1.创建一个 UIBezierPath 对象<br>2.用 moveToPoint: 设置初始线段的起点<br>3.添加线段，定义一或多个子路径<br>4.修改 UIBezierPath 的绘图相关的属性，比如stroke path的属性 lineWidth 和 lineJoinStyle ，filled path的属性 usesEvenOddFillRule</p><p>注意:如果是矩形或者圆之类的特殊图形，可以不用第2步。</p><h3 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h3><ul><li><p>画直线</p><pre><code>UIBezierPath *path = [UIBezierPath bezierPath];[path moveToPoint:CGPointMake(50, 50)];[path addLineToPoint:CGPointMake(100, 50)];path.lineWidth = 5.0f;path.lineJoinStyle = kCGLineJoinRound;[path stroke];</code></pre><p>`</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-16ff36f673e553cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="直线.png"></p></li><li><p>创建三角形</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(50, 50)];    [path addLineToPoint:CGPointMake(300, 50)];    [path addLineToPoint:CGPointMake(200, 150)];    // 最后的闭合线是可以通过调用closePath方法来自动生成的，也可以调用-addLineToPoint:方法来添加    //  [path addLineToPoint:CGPointMake(50, 50)];    [path closePath];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-aea9cce78dcbb04d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三角形.png"></p></li><li><p>创建矩形</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(50, 100, 50, 50)];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-8dbfcbd9be34a2fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="矩形.png"></p></li><li><p>创建内切曲线</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 200, 50, 50)];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-33d7bec06da43891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="圆.png"></p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 200, 50, 100)];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-45261ea74f94f5e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="椭圆.png"></p></li><li><p>创建带有圆角的矩形，当矩形变成正圆的时候，Radius就不再起作用</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 300, 50, 50) cornerRadius:15.0f];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-69993e6575524f1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="带有圆角的矩形.png"></p></li><li><p>设定特定的角为圆角的矩形</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 400, 50, 50) byRoundingCorners:UIRectCornerBottomLeft cornerRadii:CGSizeMake(5,5)];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-2eb9c4626845e02f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特定的角为圆角的矩形.png"></p></li><li><p>创建圆弧</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(100, 550) radius:25 startAngle:0 endAngle:1.5*M_PI clockwise:YES];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e21ece42c37ee1d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建圆弧.png"></p></li><li><p>通过路径A创建路径B</p><pre>`    UIBezierPath *path_A = [UIBezierPath bezierPath];    [path_A moveToPoint:CGPointMake(200, 50)];    [path_A addLineToPoint:CGPointMake(250, 100)];    path_A.lineWidth = 5.0f;    UIBezierPath *path_B = [UIBezierPath bezierPathWithCGPath:path_A.CGPath];    [path_B stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e7bacd50200981a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过路径A创建路径B.png"></p></li><li><p>创建三次贝塞尔曲线</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(100, 200)];    [path addCurveToPoint:CGPointMake(300, 200) controlPoint1:CGPointMake(150, 150) controlPoint2:CGPointMake(250, 250)];    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f9c30b5d17806b03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次贝塞尔曲线.png"></p></li><li><p>创建二次贝塞尔曲线</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(100, 200)];    [path addQuadCurveToPoint:CGPointMake(300, 200) controlPoint:CGPointMake(150, 150)];    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-b576d92730e22a33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二次贝塞尔曲线.png"></p></li><li><p>添加圆弧</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(200, 400)];    [path addLineToPoint:CGPointMake(225, 410)];    [path addArcWithCenter:CGPointMake(200, 400) radius:25 startAngle:0 endAngle:1.5*M_PI clockwise:YES];//    [path closePath];//    [path removeAllPoints];    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-4c5f96ba08475740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加圆弧.png"></p></li><li><p>追加路径</p><pre>`    UIBezierPath *path_A = [UIBezierPath bezierPath];    [path_A moveToPoint:CGPointMake(200, 500)];    [path_A addLineToPoint:CGPointMake(225, 410)];    UIBezierPath *path_B = [UIBezierPath bezierPath];    [path_B moveToPoint:CGPointMake(200, 600)];    [path_B addLineToPoint:CGPointMake(225, 500)];    [path_A appendPath:path_B];    [path_A stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3192e79c84b3393f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="追加路径.png"></p></li><li><p>创建翻转路径，即起点变成终点，终点变成起点</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(50, 50)];    [path addLineToPoint:CGPointMake(100, 50)];    path.lineWidth = 5.0f;    NSLog(@"%@",NSStringFromCGPoint(path.currentPoint));    UIBezierPath *path_b = [path bezierPathByReversingPath];    CGAffineTransform transform = CGAffineTransformMakeTranslation(200, 0);    [path_b applyTransform: transform];    // 两条路径分别添加一条直接到 self.center    [path addLineToPoint: CGPointMake(self.frame.size.width*0.5, self.frame.size.height*0.5)];    [path_b addLineToPoint: CGPointMake(self.frame.size.width*0.5, self.frame.size.height*0.5)];    NSLog(@"%@",NSStringFromCGPoint(path_b.currentPoint));    [[UIColor redColor] set];    [path stroke];    [[UIColor blueColor] set];    [path_b stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-7d3a6fbc364a219c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建翻转路径.png"></p></li><li><p>路径进行仿射变换</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(100, 50)];    [path addLineToPoint:CGPointMake(200, 50)];    CGAffineTransform transform =  CGAffineTransformRotate(self.transform, M_PI_4);    [path applyTransform:transform];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0582260c77588276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="仿射变换.png"></p></li><li><p>创建虚线</p><pre>`    CGFloat dashStyle[] = {1.0f, 2.0f};    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(50, 50)];    [path addLineToPoint:CGPointMake(100, 50)];    [path setLineDash:dashStyle count:2 phase:0.0];    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-699954cefed52f84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建虚线.png"></p></li><li><p>设置颜色</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)];    [[UIColor greenColor] setStroke];    [[UIColor redColor] setFill];    [path stroke];    [path fill];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-a86a7876b611d3c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-01-19 下午1.49.31.png"></p></li><li><p>设置描边混合模式</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)];    [[UIColor greenColor] setStroke];    path.lineWidth = 10.0f;    [path strokeWithBlendMode:kCGBlendModeSaturation alpha:1.0];    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6834121170a017fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Stroke混合.png"></p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)];    [[UIColor redColor] setFill];    [path fillWithBlendMode:kCGBlendModeSaturation alpha:0.6];    [path fill];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-91da4d71de0f0f28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fill混合.png"></p></li><li><p>修改当前图形上下文的绘图区域可见,随后的绘图操作导致呈现内容只有发生在指定路径的填充区域</p><p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)];</pre></p><pre><code>[[UIColor greenColor] setStroke];[path addClip];[path stroke];</code></pre></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-38adb693ff8fea97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Clip.png"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>关于UIBezierPath的简单介绍就到这了,主要是用代码做了展示,属性跟方法,没详细去介绍,我觉得可以直接看苹果的api写的也蛮清楚的.或者自己试试不同的参数样式也能大概理解了.另外简书上看到有篇文章对属性及方法介绍的蛮详细的,可以去看看:<a href="http://www.jianshu.com/p/6130b51a0b71" target="_blank" rel="external">UIBezierPath</a></p><p>核心动画跟贝赛尔曲线都有了简单的介绍了,接下来就可以动手做点简单的自定义动画了.会在下一篇更新.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UIBezierPath主要用来绘制矢量图形，它是基于Core Graphics对CGPathRef数据类型和path绘图属性的一个封装，所以是需要图形上下文的（CGContextRef），所以一般UIBezierPath在drawRect中使用。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="动画与绘图" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>快速上手核心动画</title>
    <link href="http://yoursite.com/2017/01/13/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2017/01/13/动画与绘图/快速上手核心动画/</id>
    <published>2017-01-13T08:25:03.000Z</published>
    <updated>2017-10-30T04:23:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、什么是核心动画"><a href="#1、什么是核心动画" class="headerlink" title="1、什么是核心动画"></a>1、什么是核心动画</h3><p>Core Animation是一套包含图形绘制、投影、动画的Objective-C类集合，该框架包含在QuartzCore.framework中，它因为被用于处理更为强大的平滑的转场效果而引入OS X Leopard和iOS而出名。Core Animation和其它框架的位置关系如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1868951-63095a6c66b74535.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="核心动画.png"><br>     上图中的OpenGL ES是个C语言写的非常底层的图形处理框架，是个移动设备上绘制2D和3D计算机图形的标准开源库，广泛地被用在游戏的图形绘制上，负责直接驱动GPU，效率非常高，缺点是使用起来异常复杂。<br>　　Core Animation是对OpenGL ES的Objective-C封装，具有与OpenGL ES几乎等价的高性能，却隐藏了OpenGL ES的复杂性。</p><h3 id="2、核心动画类的层次结构"><a href="#2、核心动画类的层次结构" class="headerlink" title="2、核心动画类的层次结构"></a>2、核心动画类的层次结构</h3><p><img src="http://upload-images.jianshu.io/upload_images/1868951-859569c019ae7c80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Core Animation类图.png"><br>核心动画中可以直接使用的类有：</p><p>　　CABasicAnimation<br>　　CAKeyframeAnimation<br>　　CAAnimationGroup<br>　　CATransition<br>　　CASpringAnimation</p><p>常用属性有:</p><ul><li>duration : 动画的持续时间</li><li>beginTime : 动画的开始时间</li><li>repeatCount : 动画的重复次数</li><li>autoreverses : 执行的动画按照原动画返回执行</li><li>timingFunction : 控制动画的显示节奏系统提供五种值选择，分别是：<br>kCAMediaTimingFunctionLinear 线性动画<br>kCAMediaTimingFunctionEaseIn 先慢后快<br>kCAMediaTimingFunctionEaseOut 先快后慢<br>kCAMediaTimingFunctionEaseInEaseOut 先慢后快再慢<br>kCAMediaTimingFunctionDefault 默认，也属于中间比较快</li><li>fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后</li><li>beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间</li></ul><ul><li><p>delegate ： 动画代理。能够检测动画的执行和结束。</p><p>@interface NSObject (CAAnimationDelegate)<br>@optional</p><ul><li>(void)animationDidStart:(CAAnimation *)anim; </li><li>(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;<br>@end<br>`</li></ul></li><li><p>path：关键帧动画中的执行路径</p></li><li>type ： 过渡动画的动画类型，系统提供了四种过渡动画。<br>kCATransitionFade 渐变效果<br>kCATransitionMoveIn 进入覆盖效果<br>kCATransitionPush 推出效果<br>kCATransitionReveal 揭露离开效果</li><li><p>subtype : 过渡动画的动画方向<br>kCATransitionFromRight 从右侧进入<br>kCATransitionFromLeft 从左侧进入<br>kCATransitionFromTop 从顶部进入<br>kCATransitionFromBottom 从底部进入</p><h3 id="3、常见类介绍"><a href="#3、常见类介绍" class="headerlink" title="3、常见类介绍"></a>3、常见类介绍</h3><h3 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a>CABasicAnimation</h3><p>　　CABasicAnimation可以设定keyPath的起点，终点的值，动画会沿着设定点进行移动，CABasicAnimation可以看成是只有两个关键点的特殊的CAKeyFrameAnimation。</p><p>重要属性:</p><ul><li>fromValue ： keyPath对应的初始值</li><li>toValue ： keyPath对应的结束值</li></ul><p>基础动画主要提供了对于CALayer对象中的可变属性进行简单动画的操作。比如：位移、透明度、缩放、旋转、背景色等等。</p><p>注意点:<br>如果 fillMode = kCAFillModeForwards 和 removedOnComletion = NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</p><pre>`CABasicAnimation *positionAnima = [CABasicAnimation animationWithKeyPath:@"position.y"];positionAnima.duration = 0.8;positionAnima.fromValue = @(_iconView.center.y);positionAnima.toValue = @(_iconView.center.y-30);positionAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];positionAnima.repeatCount = HUGE_VALF;positionAnima.repeatDuration = 2;positionAnima.removedOnCompletion = NO;positionAnima.fillMode = kCAFillModeBackwards;positionAnima.delegate = self;[positionAnima setValue:@"PositionAnima" forKey:@"AnimationKey"];[_iconView.layer addAnimation:positionAnima forKey:@"AnimationMoveY"];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e4d1ad43ae37c9ed.gif?imageMogr2/auto-orient/strip" alt="CABasicAnimation.gif"></p><h3 id="CAKeyframeAnimation"><a href="#CAKeyframeAnimation" class="headerlink" title="CAKeyframeAnimation"></a>CAKeyframeAnimation</h3><p>可以设定keyPath起点、中间关键点（不止一个）、终点的值，每一帧所对应的时间，动画会沿着设定点进行移动。</p><p>重要属性:</p><ul><li>values ： 键帧数组对象，里面每一个元素即为一个关键帧，动画会在对应的时间段内，依次执行数组中每一个关键帧的动画。</li><li>path ： 动画路径对象，可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略。</li><li>keyTimes ： 可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.如果没有设置该属性，则每一帧的时间平分。</li></ul><pre>`CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"transform.rotation"];animation.duration = 0.25;animation.repeatCount = 10;animation.values = @[@0.0,@(-M_PI_4/4),@0.0,@(M_PI_4/4),@0.0];animation.keyTimes = @[@0.0,@0.25,@0.5,@0.75,@1.0];[_iconView.layer addAnimation:animation forKey:@"AnimationKey"];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-476e68184ac7d47a.gif?imageMogr2/auto-orient/strip" alt="CAKeyframeAnimation.gif"></p><h3 id="CAAnimationGroup"><a href="#CAAnimationGroup" class="headerlink" title="CAAnimationGroup"></a>CAAnimationGroup</h3><p>CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行。<br>重要属性:</p><ul><li>animations : 用来保存一组动画对象的NSArray</li></ul><pre>`CABasicAnimation *positionAnima = [CABasicAnimation animationWithKeyPath:@"position.y"];positionAnima.fromValue = @(self.iconView.center.y);positionAnima.toValue = @(self.iconView.center.y-30);positionAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];CABasicAnimation *transformAnima = [CABasicAnimation animationWithKeyPath:@"transform.rotation.y"];transformAnima.fromValue = @(0);transformAnima.toValue = @(M_PI);transformAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];CAAnimationGroup *animaGroup = [CAAnimationGroup animation];animaGroup.duration = 2.0f;animaGroup.fillMode = kCAFillModeForwards;animaGroup.removedOnCompletion = NO;animaGroup.animations = @[positionAnima,transformAnima];[self.iconView.layer addAnimation:animaGroup forKey:@"Animation"];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-730a29e7cfb59c3d.gif?imageMogr2/auto-orient/strip" alt="CAAnimationGroup.gif"></p><h3 id="CATransition"><a href="#CATransition" class="headerlink" title="CATransition"></a>CATransition</h3><p>转场动画，比UIVIew转场动画具有更多的动画效果，比如Nav的默认Push视图的效果就是通过CATransition的kCATransitionPush类型来实现。<br>重要属性:</p><ul><li>type ：动画过渡类型<br>Apple 官方的SDK其实只提供了四种过渡效果。<br>kCATransitionFade 渐变效果<br>kCATransitionMoveIn 进入覆盖效果<br>kCATransitionPush 推出效果<br>kCATransitionReveal 揭露离开效果</li></ul><p>还有一些私有API的动画类型，效果很炫酷，不过不推荐使用。比如：”cube”、”suckEffect”、”oglFlip”、”rippleEffect”、”pageCurl”、”pageUnCurl”、”cameraIrisHollowOpen”、”cameraIrisHollowClose”等等。</p></li><li><p>subtype ：动画过渡方向<br>kCATransitionFromRight 从右侧进入<br>kCATransitionFromLeft 从左侧进入<br>kCATransitionFromTop 从顶部进入<br>kCATransitionFromBottom 从底部进入</p></li><li>startProgress ：动画起点(在整体动画的百分比)</li><li><p>endProgress ：动画终点(在整体动画的百分比)<br>CATransition * transitionAnima = [CATransition animation];<br>transitionAnima.type = kCATransitionMoveIn;<br>transitionAnima.subtype = kCATransitionFromRight;<br>transitionAnima.duration = 2.5;<br>_iconView.image = [UIImage imageNamed:@”paopao”];<br>[_iconView.layer addAnimation:transitionAnima forKey:@”transitionAnima”];</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-ba2c81b3cf9682ec.gif?imageMogr2/auto-orient/strip" alt="CATransition.gif"></p><h3 id="CASpringAnimation"><a href="#CASpringAnimation" class="headerlink" title="CASpringAnimation"></a>CASpringAnimation</h3><p>CASpringAnimation是iOS9新加入动画类型，是CABasicAnimation的子类，用于实现弹簧动画。</p><p>CASpringAnimation和UIView的SpringAnimation对比：<br>　1.CASpringAnimation 可以设置更多影响弹簧动画效果的属性，可以实现更复杂的弹簧动画效果，且可以和其他动画组合。<br>　2.UIView的SpringAnimation实际上就是通过CASpringAnimation来实现。</p><p>重要属性:</p><ul><li>mass：质量（影响弹簧的惯性，质量越大，弹簧惯性越大，运动的幅度越大）</li><li>stiffness：弹性系数（弹性系数越大，弹簧的运动越快）</li><li>damping：阻尼系数（阻尼系数越大，弹簧的停止越快）</li><li>initialVelocity：初始速率（弹簧动画的初始速度大小，弹簧运动的初始方向与初始速率的正负一致，若初始速率为0，表示忽略该属性）</li><li>settlingDuration：结算时间（根据动画参数估算弹簧开始运动到停止的时间，动画设置的时间最好根据此时间来设置）</li></ul><pre>`CASpringAnimation * springAnima = [CASpringAnimation animationWithKeyPath:@"bounds"];springAnima.mass = 10.0; //质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大springAnima.stiffness = 5000; //刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快springAnima.damping = 100.0;//阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快springAnima.initialVelocity = 3.0;//初始速率，动画视图的初始速度大小;速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反springAnima.duration = springAnima.settlingDuration;springAnima.toValue = [NSValue valueWithCGRect:CGRectMake(100, 200, 200, 200)];springAnima.removedOnCompletion = NO;springAnima.fillMode = kCAFillModeForwards;springAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];[self.iconView.layer addAnimation:ani forKey:@"boundsAni"];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-c3fdaa20b8feea52.gif?imageMogr2/auto-orient/strip" alt="CASpringAnimation.gif"></p><h3 id="CATransaction"><a href="#CATransaction" class="headerlink" title="CATransaction"></a>CATransaction</h3><p>CoreAnimation中还有一个非常重要的类：CATransaction事务类，这个可以同时设置多个layer层的动画效果。可以通过隐式和显式两种方式来进行动画操作。<br>　　事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。<br>　　事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。<br>　　任何可以做动画的图层属性都会被添加到栈顶的事务，你可以通过+setAnimationDuration:方法设置当前事务的动画时间，或者通过+animationDuration方法来获取值（默认0.25秒）。<br>　　Core Animation在每个run loop周期中自动开始一次新的事务（run loop是iOS负责收集用户输入，处理定时器或者网络事件并且重新绘制屏幕的东西），即使你不显式的用[CATransaction begin]开始一次事务，任何在一次run loop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。<br>　　事务的作用：保证一个或多个layer的一个或多个属性变化同时进行<br>　　事务分为隐式和显式：<br>　　1.隐式：没有明显调用事务的方法，由系统自动生成事务。比如直接设置一个layer的position属性，则会在当前线程自动生成一个事务，并在下一个runLoop中自动commit事务。<br>　　2.显式：明显调用事务的方法（[CATransaction begin]和[CATransaction commit]）。</p><p>对layer层的属性操作，都会形成隐式动画，要使用隐式动画，需要关闭layer层的animation动画属性，使用下面的方法：</p><pre>`//关闭animation动画效果，开启隐式动画+ (BOOL)disableActions;+ (void)setDisableActions:(BOOL)flag;`</pre><p>事务的可设置属性（会覆盖隐式动画的设置）：</p><ul><li>animationDuration：动画时间 </li><li>animationTimingFunction：动画时间曲线 </li><li>disableActions：是否关闭动画 </li><li>completionBlock：动画执行完毕的回调</li></ul><p>事务支持嵌套使用：当最外层的事务commit后动画才会开始。<br>使用实例：</p><p><pre>`[CATransaction begin];<br>[CATransaction setAnimationDuration:2.0];<br>[CATransaction setAnimationTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];<br> self.iconView.layer.bounds = self.showView.layer.bounds;<br>[CATransaction commit];</pre></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、什么是核心动画&quot;&gt;&lt;a href=&quot;#1、什么是核心动画&quot; class=&quot;headerlink&quot; title=&quot;1、什么是核心动画&quot;&gt;&lt;/a&gt;1、什么是核心动画&lt;/h3&gt;&lt;p&gt;Core Animation是一套包含图形绘制、投影、动画的Objective-C类
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="动画与绘图" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>快速上手UIView动画</title>
    <link href="http://yoursite.com/2017/01/06/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BUIView%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2017/01/06/动画与绘图/快速上手UIView动画/</id>
    <published>2017-01-06T09:00:20.000Z</published>
    <updated>2017-10-30T04:23:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UIView动画有两种使用方法"><a href="#UIView动画有两种使用方法" class="headerlink" title="UIView动画有两种使用方法"></a>UIView动画有两种使用方法</h2><ul><li><p>UIView [begin commit]模式</p><p>//动画开始标记<br>[UIView beginAnimations:@”changeframe” context:nil];<br>//动画持续时间<br>[UIView setAnimationDuration:2.0];<br>//动画的代理对象<br>[UIView setAnimationDelegate:self];<br>//设置动画将开始时代理对象执行的SEL<br>[UIView setAnimationWillStartSelector:nil];<br>//设置动画结束时代理对象执行的SEL<br>[UIView setAnimationDidStopSelector:nil];<br>//设置动画延迟执行的时间<br>[UIView setAnimationDelay:1.0];<br>//设置动画的重复次数<br>[UIView setAnimationRepeatCount:1];<br>//设置动画的曲线<br>[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];<br>//设置动画是否继续执行相反的动画<br>//[UIView setAnimationRepeatAutoreverses:YES];<br>_aniView.frame = CGRectMake(SCREEN_WIDTH-100, SCREEN_HEIGHT/2, 50, 50);<br>//结束动画标记<br>[UIView commitAnimations];<br>`</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-d1d4b061884fbc0e.gif?imageMogr2/auto-orient/strip" alt="base1.gif"></p></li><li><p>UIView Block调用<br>先举个Spring动画的例子</p><pre>`[UIView animateWithDuration:2.0//动画持续时间delay:1.0//动画延迟执行的时间usingSpringWithDamping:0.5//震动效果，范围0~1，数值越小震动效果越明显initialSpringVelocity:2.0//初始速度，数值越大初始速度越快options:UIViewAnimationOptionCurveEaseInOut//动画的过渡效果animations:^{//执行的动画_aniView.frame = CGRectMake(SCREEN_WIDTH-100, SCREEN_HEIGHT/2, 50, 50);}completion:^(BOOL finished) {//动画执行完毕后的操作}];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3c3b3de37b477787.gif?imageMogr2/auto-orient/strip" alt="Spring.gif"></p><p>Spring动画的看懂了,下面这几个肯定就没问题了</p><pre>`[UIView animateWithDuration:(NSTimeInterval) //动画持续时间 animations:^{ //执行的动画 }];[UIView animateWithDuration:(NSTimeInterval) //动画持续时间 animations:^{ //执行的动画 } completion:^(BOOL finished) { //动画执行完毕后的操作 }];[UIView animateWithDuration:(NSTimeInterval) //动画持续时间 delay:(NSTimeInterval) //动画延迟执行的时间 options:(UIViewAnimationOptions) //动画的过渡效果 animations:^{ //执行的动画 } completion:^(BOOL finished) { //动画执行完毕后的操作 }];`</pre><h3 id="两种使用方法介绍完了-再看下刚才没提到的动画"><a href="#两种使用方法介绍完了-再看下刚才没提到的动画" class="headerlink" title="两种使用方法介绍完了,再看下刚才没提到的动画"></a>两种使用方法介绍完了,再看下刚才没提到的动画</h3></li><li><p>Keyframes关键帧动画</p><p>有时候我们需要实现多个连续的动画，或许我们可以在 completion中来实现多个动画的连续，但是我们却可以有更好的选择，那就是 Keyframe Animations（帧动画）。<br>举个例子:</p><pre>`[UIView animateKeyframesWithDuration:5.0 //所有动画完成的总时间delay:1.0 //延迟执行时间options:UIViewKeyframeAnimationOptionBeginFromCurrentState //枚举类型 UIViewKeyFrameAnimationOptionsanimations:^{ //在这里添加动画[UIView addKeyframeWithRelativeStartTime:0.0 //指相对于全部动画时间的开始时间。比如总时间为10s，设值为0.0，则此动画就是第0秒开始。取值都在0~1.0之间。relativeDuration:0.25 //指相对于全部动画时间的持续时间。比如总时间为10秒，设置为0.25，则此动画所持续的时间就是2.5秒。取值都在0~1.0之间animations:^{_aniView.backgroundColor = [UIColor redColor];}];[UIView addKeyframeWithRelativeStartTime:0.1 relativeDuration:0.4 animations:^{_aniView.transform = CGAffineTransformMakeRotation(M_PI_4);}];[UIView addKeyframeWithRelativeStartTime:0.25 relativeDuration:0.25 animations:^{_aniView.backgroundColor = [UIColor yellowColor];}];[UIView addKeyframeWithRelativeStartTime:0.51 relativeDuration:0.01 animations:^{_aniView.transform = CGAffineTransformIdentity;}];[UIView addKeyframeWithRelativeStartTime:0.55 relativeDuration:0.45 animations:^{_aniView.backgroundColor = [UIColor greenColor];}];} completion:^(BOOL finished) {//这个动画执行完成后会执行这里dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{//两秒之后重复执行动画[self buttonClick3:button];});}];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-be7566476eb00050.gif?imageMogr2/auto-orient/strip" alt="Keyframes.gif"></p></li><li><p>CATransition动画<br>用于做过渡动画或者转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。<br>举个例子:<br>1.单个视图的过渡效果</p><pre>`[UIView transitionWithView:_aniView duration:1.5 options:UIViewAnimationOptionTransitionFlipFromTop|UIViewAnimationOptionOverrideInheritedOptions animations:^{_aniView.backgroundColor = [UIColor blueColor];} completion:^(BOOL finished) {NSLog(@"动画结束");}];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-585cd59a980a3d69.gif?imageMogr2/auto-orient/strip" alt="transition1.gif"></p><p>2.从旧视图转到新视图的动画效果</p><p><pre>`UIImageView * newImageView = [[UIImageView alloc]initWithFrame:_aniView.frame];<br>newImageView.image = [UIImage imageNamed:@”xinqin-paopao”];<br>[UIView transitionFromView:_aniView toView:newImageView duration:1.0 options:UIViewAnimationOptionTransitionFlipFromRight completion:^(BOOL finished) {<br>NSLog(@”动画结束”);<br>}];</pre></p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e473134ea4cacd7e.gif?imageMogr2/auto-orient/strip" alt="transition2.gif"></p><p>常用的大概就这么多,也比较简单,关于动画的过渡效果有很多枚举值,适合看代码直接动手尝试来学习.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UIView动画有两种使用方法&quot;&gt;&lt;a href=&quot;#UIView动画有两种使用方法&quot; class=&quot;headerlink&quot; title=&quot;UIView动画有两种使用方法&quot;&gt;&lt;/a&gt;UIView动画有两种使用方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;UIView [b
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="动画与绘图" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>PHP变量</title>
    <link href="http://yoursite.com/2016/12/16/PHP/PHP%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2016/12/16/PHP/PHP变量/</id>
    <published>2016-12-16T05:23:00.000Z</published>
    <updated>2017-10-30T05:59:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-类型"><a href="#1-1-类型" class="headerlink" title="1.1:类型"></a>1.1:类型</h4><p>变量有8种类型,不必死记硬背,在实际运用中加深理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1) 整型 [integer] 数学中的整数</div><div class="line">2) 浮点型 [float,double] 数学中的小数</div><div class="line">3) 字符串 [string] 一串字符</div><div class="line">4) 布尔 [boolean] 真假</div><div class="line">5) 数组 [array] 键值对复合数据</div><div class="line">6) 对象 [Object] [在后面的面向对象中会学到] </div><div class="line">7) NULL 没有值</div><div class="line">8) 资源 [resource] “吸管”</div></pre></td></tr></table></figure></p><p>NULL是什么? NULL类型只标注了它的类型为NULL<br>它的值的字段是空的,NULL是没有值的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$a = 3;//整型</div><div class="line">$b = 3.14;//浮点型</div><div class="line">$c = null;//null型</div><div class="line">$d = &apos;hello&apos;;//字符串</div><div class="line">$e = true;//布尔型</div><div class="line">echo $D;</div></pre></td></tr></table></figure></p><p>变量名称的命名规范:<br> [a-zA-Z0-9]和下划线(_)<br>1)变量名是区分大小写的<br> 2)不能以数字开头</p><h4 id="1-2-变量检测"><a href="#1-2-变量检测" class="headerlink" title="1.2:变量检测"></a>1.2:变量检测</h4><p>echo 一个不存在的变量,会报notice级别的错误,<br>所以要检测一下这个变量是否存在<br><strong>如何检测变量是否存在?</strong><br>isset — 检测变量是否设置<br>已声明的变量返回 true,未声明的变量返回 false.<br>检测一个变量是否存在: 就是看花名册中是否有这个变量名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$b = null; $c = false; $d=0; $e=&apos;&apos;;</div><div class="line">//分别检测上述变量是否存在 </div><div class="line">if(isset($a)) &#123;</div><div class="line">  echo &apos;变量b存在&apos;;</div><div class="line"> &#125;else&#123;</div><div class="line">  echo &apos;变量b不存在&apos;; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于值为 NULL 的变量,也返回 false,因为null没有值 未曾声明的变量,当然也不存在</p><h4 id="1-3-类型检测"><a href="#1-3-类型检测" class="headerlink" title="1.3:类型检测"></a>1.3:类型检测</h4><p>检测一个变量,php是把它存储成一个什么样的类型的 对于php而言获取它的变量类型是很简单的 因为箱子里面已经存储了它的变量类型<br>gettype — 获取变量的类型 [现成的系统函数]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$a = false;</div><div class="line">echo gettype($a);</div><div class="line">$b = &quot;1&quot;;</div><div class="line">echo gettype($b);</div><div class="line">$c = 1.11;</div><div class="line">echo gettype($c);</div><div class="line">$d = &apos;hello&apos;;</div><div class="line">echo gettype($d);</div><div class="line">$e = null;</div><div class="line">echo gettype($e);</div></pre></td></tr></table></figure></p><p><strong>判断变量是否是某种类型</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">is_float()[is_double] 检测变量是否为浮点型</div><div class="line">is_int()[is_integer] 检测变量是否为整型</div><div class="line">is_string() 检测变量是否为字符串</div><div class="line">is_object() 检测变量是否为对象</div><div class="line">is_array() 检测变量是否为数组</div><div class="line">is_resource 检测变量是否为资源类型</div><div class="line">is_bool 检测变量是否是布尔型</div><div class="line">is_null 检测变量是否为 NULL</div><div class="line">$a = &apos;hello&apos;;</div><div class="line">if(is_string($a)) &#123;</div><div class="line">  echo &apos;a是字符串&apos;; </div><div class="line">&#125;else&#123;</div><div class="line">  echo &apos;a不是字符串&apos;;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h4 id="1-4-调试打印变量"><a href="#1-4-调试打印变量" class="headerlink" title="1.4:调试打印变量"></a>1.4:调试打印变量</h4><p>echo 字符串,数字<br>print_r 打印层次化的数据,比如:数组,对象<br>var_dump 打印变量的类型及其值[调试代码比较方便]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$a = &apos;hello&apos;;</div><div class="line">$b = array(1,2,&quot;3&quot;); $c = false;</div><div class="line">$d = null;</div><div class="line">$e=18;</div><div class="line">$f = true;</div><div class="line">//布尔型的true会打印出1,false和null什么都不显示</div><div class="line"> echo $a,$b,$c,$d,$e,$f,&apos;&lt;hr&gt;&apos;;</div><div class="line">//print_r 打印层次化的数据,比如数组和对象 </div><div class="line">print_r($b);</div><div class="line">print_r($c);</div><div class="line">print_r($d);</div><div class="line">print_r($f);</div><div class="line">//不要用echo和print_r打印布尔型的值,因为会干扰我们 </div><div class="line">//用var_dump打印布尔和null</div><div class="line">var_dump($c);</div><div class="line">var_dump($d);</div></pre></td></tr></table></figure><h4 id="1-5-类型转换"><a href="#1-5-类型转换" class="headerlink" title="1.5:类型转换"></a>1.5:类型转换</h4><p>PHP中,变量的类型是可以随时转换的,非常的灵活 最常见的是字符转与数字之间的相互转换, 或者是数字/字符串 -&gt; 布尔值的转换</p><p><strong>字符串到数字的转换</strong><br>从左到右截取,直道碰到不合法的数字,截取下来的部分转换为数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$a = &apos;12&apos;; $b=$a+3; </div><div class="line">var_dump($b);</div><div class="line">$a = &apos;12.5hello&apos;; </div><div class="line">//$a = &apos;12.5hello99&apos;; </div><div class="line">$b=$a+3;</div><div class="line">var_dump($b);</div><div class="line">$a = &apos;word12.5hello&apos;;</div><div class="line">$b=$a+3; </div><div class="line">var_dump($b);</div></pre></td></tr></table></figure></p><p><strong>数字到字符串的转换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$a = 123;</div><div class="line">$b = $a . &apos;hello&apos;;</div><div class="line">var_dump($b);</div></pre></td></tr></table></figure></p><p><strong>数字/字符串/数组等到布尔型值的转换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$b=3; </div><div class="line">if($b)&#123;</div><div class="line">echo &apos;b is true&apos;;</div><div class="line"> &#125;else&#123;</div><div class="line">    echo &apos;b is false&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>if判断的应该是布尔型的值,那数字3被转成布尔型来理解 那它到底应该理解为真还是假呢?<br><strong>以下值,都被理解为成布尔型值的假</strong><br> ‘’,’0’,0,0.0,false,NULL,array(); 而其它值,都被当成布尔型的真<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(&apos;&apos; == false) &#123;</div><div class="line">echo &apos;空字符串果然假&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>empty(var) — 检查一个变量是否为空</strong><br>如果 var 是非空或非零的值，则 empty() 返回 FALSE<br>换句话 说，””、0、0.0、”0”、NULL、FALSE、array(); 以及没有任何属性的对象都将被认为是空的，如果 var 为空，则返回 TRUE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$arr = array();</div><div class="line">if(empty($arr)) &#123;</div><div class="line">echo &apos;变量为空&apos;;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>####1.6:赋值<br>赋值有两种方式 :<br>1.传值赋值;(两个人看两台电视同一个台)<br>2.引用赋值;(两个人看同一台电视)<br><strong>1.传值赋值</strong><br> 变量名其实不是贴在盒子上的,而是有个变量表(像班级的花名册) 变量值和变量类型放在盒子里面;变量表中的变量名指向它所对应的盒子.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$li = 23;</div><div class="line">$wang = $li;</div><div class="line">echo $li, &apos;~&apos;, $wang;</div></pre></td></tr></table></figure></p><p>改变$li的值,$wang的值会发生变换吗<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$li = 99;</div><div class="line">echo $li, &apos;~&apos; ,$wang;</div></pre></td></tr></table></figure></p><p>这个赋值过程,是把$li的值,赋给$wang<br><strong>2.引用赋值 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$a = &apos;tvb&apos;;</div><div class="line">$b = &amp;$a; </div><div class="line">//$a,$b共同指向同一个值 </div><div class="line">echo $a,&apos;~&apos;,$b;</div></pre></td></tr></table></figure></p><p>改变$a的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$a = &apos;btv&apos;;</div><div class="line">echo $a,&apos;~&apos;,$b;</div></pre></td></tr></table></figure></p><p>####1.7:销毁<br>为什么要销毁变量?<br>因为,有时比较大的数组,或者比较大的对象 特别的GD画图时,比较耗费资源,将它unset掉,可以及时释放出内存<br>unset(变量名); 销毁指定的变量 首先从变量表(花名册)中删除变量名,再找到它对应的盒子也删除掉.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$a=99; //unset($a);</div><div class="line">if(isset($a)) &#123;</div><div class="line"> echo &apos;a存在&apos;;</div><div class="line">&#125;else&#123;</div><div class="line">  echo &apos;a不存在&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意: 引用赋值,如果两个变量指向同一个盒子,当销毁其中一个变量的时候,盒子是不能被销毁掉的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$a=99;</div><div class="line">$b = &amp;$a;</div><div class="line">unset($a);</div><div class="line">echo $a,$b;//报一个notice的错误</div></pre></td></tr></table></figure></p><p>重新给$a赋值一个新值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$a=18; </div><div class="line">echo $a,$b;</div></pre></td></tr></table></figure></p><p>####1.8: 动态变量名<br>动态变量名,可以体现php非常灵活的一个地方<br>用变量的值去做另一个变量的名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$laoda = &apos;liubei&apos;;</div><div class="line">echo $laoda , &apos;&lt;br &gt;&apos;;</div><div class="line">$paihang = &apos;laoda&apos;;</div><div class="line">echo $paihang , &apos;~&apos; , $$paihang;</div><div class="line">//排行</div><div class="line">$rank = &apos;paihang&apos;; </div><div class="line">echo $$$rank;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-1-类型&quot;&gt;&lt;a href=&quot;#1-1-类型&quot; class=&quot;headerlink&quot; title=&quot;1.1:类型&quot;&gt;&lt;/a&gt;1.1:类型&lt;/h4&gt;&lt;p&gt;变量有8种类型,不必死记硬背,在实际运用中加深理解&lt;br&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
</feed>
