<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛洛爱吃肉</title>
  
  <subtitle>学海无涯,进一步有进一步的欢喜.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-30T03:43:04.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>loirou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>try</title>
    <link href="http://yoursite.com/2017/10/30/try/"/>
    <id>http://yoursite.com/2017/10/30/try/</id>
    <published>2017-10-30T03:41:13.000Z</published>
    <updated>2017-10-30T03:43:04.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="bbb" scheme="http://yoursite.com/categories/bbb/"/>
    
    
      <category term="a" scheme="http://yoursite.com/tags/a/"/>
    
      <category term="c" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="f" scheme="http://yoursite.com/tags/f/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/10/27/HTTP%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/10/27/HTTP笔记/</id>
    <published>2017-10-27T06:19:52.000Z</published>
    <updated>2017-10-30T03:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: HTTP笔记<br>categories:</p><ul><li>网络<br>date: 2017-01-06 17:00:20<br>tags:<br>— 网络</li></ul><p>“你知道当我们在网页浏览器（Web browser）的地址栏中输入 URL 时，Web 页面是如何呈现的吗？”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-48cf5d50116ffd8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="过程.png"></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议（HyperText Transfer Protocol）即超文本传输协议是用于服务器传输到客户端浏览器的传输协议。Web上，服务器和客户端利用HTTP协议进行通信会话。</p><p>在Web上，HTTP协议使用TCP协议而不是UDP协议的原因在于一个网页必须传送很多数据，而且保证其完整性。TCP协议提供传输控制，按顺序组织数据和错误纠正的一系列功能。</p><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><pre><code>1、客户端与服务器需要建立连接。（比如某个超级链接，HTTP就开始了。）2、建立连接后，发送请求。3、服务器接到请求后，响应其响应信息。4、客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</code></pre><p>忽略掉连接过程是这样的:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-058c281b84838c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作过程.png"></p><h3 id="URI、URL与RFC"><a href="#URI、URL与RFC" class="headerlink" title="URI、URL与RFC"></a>URI、URL与RFC</h3><p>先看看官方的解释：<br>URI：uniform resource identifier 统一资源标识符<br>URL：uniform resource location 统一资源定位符</p><p>URI用字符串标识某一互联网资源，而URL表示资源的地点。可见URL是URI的子集。</p><p>URI要使用涵盖全部必要信息的URI、绝对URL以及相对URL。相对URL是指从浏览器中基本URI处理的URL，来先看下URI的格式:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-eb2b672fed8c4be9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="URI格式.png"></p><p>RFC：reqeust for comments 征求修正意见书<br>RFC素有网络知识圣经之称，规定了网络中协议的基本内容。因此许多的不同系统的应用程序才可以互相访问。</p><h3 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h3><p>请求行-请求方法</p><ul><li>GET            获取资源</li><li>POST          传输实体主体</li><li>PUT            传输文件</li><li>HEAD         获取报文首部</li><li>DELETE     删除文件</li><li>OPTIONS   请求查询服务器的性能，或者查询与资源相关的选项和需求 </li><li>TRACE        请求服务器回送收到的请求信息，主要用于测试或诊断</li><li>CONNECT  要求用隧道协议连接代理(SSL：Secure Sockets Layer安全套接层，TLS：Transport Layer Security传输层安全)</li></ul><h3 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h3><p><a href="https://segmentfault.com/a/1190000004014583" target="_blank" rel="external">看别人总结的吧</a><br><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external">还有这篇</a></p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-94b9b3e85b4abde1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="状态码类别.png"></p><p>常见的状态码</p><pre><code>200 OK请求成功（其后是对GET和POST请求的应答文档。）304 Not Modified未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。404 Not Found服务器无法找到被请求的页面。500 Internal Server Error请求未完成。服务器遇到不可预知的情况。</code></pre><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。</p><p>请求我博客园首页时发送的报文内容:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-2e62214fed2f76cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报文.png"></p><p>　其中最常使用的属性是：</p><ul><li>URL, 即http访问的地址</li><li>request method, 报文的请求方式</li><li>Remote Address,远程地址</li><li>status code, 状态码以及状态短语</li><li>Connection, 连接方式</li><li>Content-Type头：便是接收方实体的介质类型。</li><li>Accept Encoding, 内容编码</li><li>Date头域：时间描述</li><li>Referer头域：允许客户端指定请求URL的资源地址。</li><li>Cookie, 添加的cookie内容</li><li>Host, 目标主机</li><li>User-Agent, 客户端浏览器的相关信息</li><li>Set-Cookie, 指定想要在Cookie中保存的内容</li></ul><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>“HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-cf9c8252e3979368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通信一次断开一次.png"></p><p>“为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-4e13a9ac5f083e57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="持久连接.png"></p><p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。<br>在 HTTP/1.1 中，所有的连接默认都是持久连接</p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>“持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p><p>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-5f1fa307c9c4ca54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-16 下午3.41.33.png"></p><p>比如，当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。</p><h3 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h3><p>由于某些报文的内容过大，因此在传输时，为了减少传输的时间，会采取一些压缩的措施。</p><p>例如上面的报文信息中，Accept-Encoding就定义了内容编码的格式：gzip,deflate</p><p>有下面几种方式：</p><ul><li>gzip：GNU压缩格式</li><li>compress：UNIX系统的标准压缩格式</li><li>deflate：是一种同时使用了LZ77和哈弗曼编码的无损压缩格式</li><li>identity：不进行压缩</li></ul><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p><p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。</p><p>对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0a2a457a44dd55e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-16 下午4.13.32.png"></p><p>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。</p><p>byte 范围的指定形式如下。</p><ul><li><p>5001~10 000 字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=5001-10000</div></pre></td></tr></table></figure></li><li><p>从 5001 字节之后全部的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=5001-</div></pre></td></tr></table></figure></li><li><p>从一开始到 3000 字节和 5000~7000 字节的多重范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=-3000, 5000-7000</div></pre></td></tr></table></figure></li></ul><p>针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</p><p>如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。”</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</p><p>假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。</p><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><p>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-89c6414d2822a545.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Cookie.png"></p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP 主要有这些不足，例举如下。</p><ul><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改”</li></ul><p>这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题。</p><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p><p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f647e66bc61d89e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SSL.png"></p><p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。</p><p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-aec3c3a7c56e95da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTPS通信.png"></p><p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p><p>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p><p>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p><p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p><p>步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p><p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p><p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p><p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p><p>步骤 9： 服务器同样发送 Finished 报文。</p><p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p><p>步骤 11： 应用层协议通信，即发送 HTTP 响应。</p><p>步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p><p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><h3 id="HTTP认证"><a href="#HTTP认证" class="headerlink" title="HTTP认证"></a>HTTP认证</h3><p>　　有一些网址或者服务需要用户的身份信息，因此需要随时知道这些消息，但是肯定不能每次都让用户输入用户密码，因此关于认证就有下面几种方式：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-7742dd7b79eca737.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="032135393488858.jpeg"></p><p>其中BASIC认证是最简单的认证，大致过程如下：<br>1 、客户端访问某URL。<br>2 、服务器端返回401状态码，提示用户输入用户名密码。<br>3 、用户输入用户名密码，通过BASE64编码传输。<br>4 、服务器通过认证，返回状态码200</p><p>通过上面的过程，就可以发现BASIC的问题：</p><ul><li>仅仅通过BASE64编码，其实还是属于明文传输，安全性不高</li><li>有的浏览器不支持注销</li></ul><p>鉴于上面BASIC的问题，DIGEST做了补充，它的过程与上面类似：<br>1 、客户端访问<br>2 、服务器端返回质询码<br>3 、客户端发送响应码</p><p>这里通过随机的生成质询码来作为计算的一种方式，客户端依据这个质询码生成响应码，进行验证。<br>这样就弥补了明文传输用户密码的风险。</p><p>SSL客户端验证，这个比较普遍了！</p><p>像支付宝啊，邮政网银啊之类的，在登录时，都需要下载一个数字认证的东西，这个东西就属于一种SSL客户端的验证。</p><p>很显然它的缺点就是需要客户去手动的安装，这个对于一般的用户来说，代价有点高。</p><p>最后一种是应用最普遍的，通过表单记录用户的身份信息，可以使用cookie或者session的方式保存用户信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: HTTP笔记&lt;br&gt;categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络&lt;br&gt;date: 2017-01-06 17:00:20&lt;br&gt;tags:&lt;br&gt;— 网络&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“你知道当我们在网页浏览器（Web browser）的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/10/27/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BUIView%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2017/10/27/快速上手UIView动画/</id>
    <published>2017-10-27T04:14:02.000Z</published>
    <updated>2017-10-30T03:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 快速上手UIView动画<br>id: 71<br>categories:</p><ul><li>iOS<br>date: 2017-01-06 17:00:20<br>tags:<br>— 动画</li></ul><h2 id="UIView动画有两种使用方法"><a href="#UIView动画有两种使用方法" class="headerlink" title="UIView动画有两种使用方法"></a>UIView动画有两种使用方法</h2><ul><li><p>UIView [begin commit]模式</p><p>//动画开始标记<br>[UIView beginAnimations:@”changeframe” context:nil];<br>//动画持续时间<br>[UIView setAnimationDuration:2.0];<br>//动画的代理对象<br>[UIView setAnimationDelegate:self];<br>//设置动画将开始时代理对象执行的SEL<br>[UIView setAnimationWillStartSelector:nil];<br>//设置动画结束时代理对象执行的SEL<br>[UIView setAnimationDidStopSelector:nil];<br>//设置动画延迟执行的时间<br>[UIView setAnimationDelay:1.0];<br>//设置动画的重复次数<br>[UIView setAnimationRepeatCount:1];<br>//设置动画的曲线<br>[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];<br>//设置动画是否继续执行相反的动画<br>//[UIView setAnimationRepeatAutoreverses:YES];<br>_aniView.frame = CGRectMake(SCREEN_WIDTH-100, SCREEN_HEIGHT/2, 50, 50);<br>//结束动画标记<br>[UIView commitAnimations];<br>`</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-d1d4b061884fbc0e.gif?imageMogr2/auto-orient/strip" alt="base1.gif"></p></li><li><p>UIView Block调用<br>先举个Spring动画的例子</p><pre>`[UIView animateWithDuration:2.0//动画持续时间delay:1.0//动画延迟执行的时间usingSpringWithDamping:0.5//震动效果，范围0~1，数值越小震动效果越明显initialSpringVelocity:2.0//初始速度，数值越大初始速度越快options:UIViewAnimationOptionCurveEaseInOut//动画的过渡效果animations:^{//执行的动画_aniView.frame = CGRectMake(SCREEN_WIDTH-100, SCREEN_HEIGHT/2, 50, 50);}completion:^(BOOL finished) {//动画执行完毕后的操作}];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3c3b3de37b477787.gif?imageMogr2/auto-orient/strip" alt="Spring.gif"></p><p>Spring动画的看懂了,下面这几个肯定就没问题了</p><pre>`[UIView animateWithDuration:(NSTimeInterval) //动画持续时间 animations:^{ //执行的动画 }];[UIView animateWithDuration:(NSTimeInterval) //动画持续时间 animations:^{ //执行的动画 } completion:^(BOOL finished) { //动画执行完毕后的操作 }];[UIView animateWithDuration:(NSTimeInterval) //动画持续时间 delay:(NSTimeInterval) //动画延迟执行的时间 options:(UIViewAnimationOptions) //动画的过渡效果 animations:^{ //执行的动画 } completion:^(BOOL finished) { //动画执行完毕后的操作 }];`</pre><h3 id="两种使用方法介绍完了-再看下刚才没提到的动画"><a href="#两种使用方法介绍完了-再看下刚才没提到的动画" class="headerlink" title="两种使用方法介绍完了,再看下刚才没提到的动画"></a>两种使用方法介绍完了,再看下刚才没提到的动画</h3></li><li><p>Keyframes关键帧动画</p><p>有时候我们需要实现多个连续的动画，或许我们可以在 completion中来实现多个动画的连续，但是我们却可以有更好的选择，那就是 Keyframe Animations（帧动画）。<br>举个例子:</p><pre>`[UIView animateKeyframesWithDuration:5.0 //所有动画完成的总时间delay:1.0 //延迟执行时间options:UIViewKeyframeAnimationOptionBeginFromCurrentState //枚举类型 UIViewKeyFrameAnimationOptionsanimations:^{ //在这里添加动画[UIView addKeyframeWithRelativeStartTime:0.0 //指相对于全部动画时间的开始时间。比如总时间为10s，设值为0.0，则此动画就是第0秒开始。取值都在0~1.0之间。relativeDuration:0.25 //指相对于全部动画时间的持续时间。比如总时间为10秒，设置为0.25，则此动画所持续的时间就是2.5秒。取值都在0~1.0之间animations:^{_aniView.backgroundColor = [UIColor redColor];}];[UIView addKeyframeWithRelativeStartTime:0.1 relativeDuration:0.4 animations:^{_aniView.transform = CGAffineTransformMakeRotation(M_PI_4);}];[UIView addKeyframeWithRelativeStartTime:0.25 relativeDuration:0.25 animations:^{_aniView.backgroundColor = [UIColor yellowColor];}];[UIView addKeyframeWithRelativeStartTime:0.51 relativeDuration:0.01 animations:^{_aniView.transform = CGAffineTransformIdentity;}];[UIView addKeyframeWithRelativeStartTime:0.55 relativeDuration:0.45 animations:^{_aniView.backgroundColor = [UIColor greenColor];}];} completion:^(BOOL finished) {//这个动画执行完成后会执行这里dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{//两秒之后重复执行动画[self buttonClick3:button];});}];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-be7566476eb00050.gif?imageMogr2/auto-orient/strip" alt="Keyframes.gif"></p></li><li><p>CATransition动画<br>用于做过渡动画或者转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。<br>举个例子:<br>1.单个视图的过渡效果</p><pre>`[UIView transitionWithView:_aniView duration:1.5 options:UIViewAnimationOptionTransitionFlipFromTop|UIViewAnimationOptionOverrideInheritedOptions animations:^{_aniView.backgroundColor = [UIColor blueColor];} completion:^(BOOL finished) {NSLog(@"动画结束");}];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-585cd59a980a3d69.gif?imageMogr2/auto-orient/strip" alt="transition1.gif"></p><p>2.从旧视图转到新视图的动画效果</p><p><pre>`UIImageView * newImageView = [[UIImageView alloc]initWithFrame:_aniView.frame];<br>newImageView.image = [UIImage imageNamed:@”xinqin-paopao”];<br>[UIView transitionFromView:_aniView toView:newImageView duration:1.0 options:UIViewAnimationOptionTransitionFlipFromRight completion:^(BOOL finished) {<br>NSLog(@”动画结束”);<br>}];</pre></p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e473134ea4cacd7e.gif?imageMogr2/auto-orient/strip" alt="transition2.gif"></p><p>常用的大概就这么多,也比较简单,关于动画的过渡效果有很多枚举值,适合看代码直接动手尝试来学习.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 快速上手UIView动画&lt;br&gt;id: 71&lt;br&gt;categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iOS&lt;br&gt;date: 2017-01-06 17:00:20&lt;br&gt;tags:&lt;br&gt;— 动画&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;UIVie
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/10/27/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2017/10/27/快速上手核心动画/</id>
    <published>2017-10-27T04:14:02.000Z</published>
    <updated>2017-10-30T03:19:40.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 快速上手核心动画<br>id: 127<br>categories:</p><ul><li>iOS<br>date: 2017-01-13 16:25:03<br>tags:<br>— 动画</li></ul><h3 id="1、什么是核心动画"><a href="#1、什么是核心动画" class="headerlink" title="1、什么是核心动画"></a>1、什么是核心动画</h3><p>Core Animation是一套包含图形绘制、投影、动画的Objective-C类集合，该框架包含在QuartzCore.framework中，它因为被用于处理更为强大的平滑的转场效果而引入OS X Leopard和iOS而出名。Core Animation和其它框架的位置关系如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1868951-63095a6c66b74535.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="核心动画.png"><br>     上图中的OpenGL ES是个C语言写的非常底层的图形处理框架，是个移动设备上绘制2D和3D计算机图形的标准开源库，广泛地被用在游戏的图形绘制上，负责直接驱动GPU，效率非常高，缺点是使用起来异常复杂。<br>　　Core Animation是对OpenGL ES的Objective-C封装，具有与OpenGL ES几乎等价的高性能，却隐藏了OpenGL ES的复杂性。</p><h3 id="2、核心动画类的层次结构"><a href="#2、核心动画类的层次结构" class="headerlink" title="2、核心动画类的层次结构"></a>2、核心动画类的层次结构</h3><p><img src="http://upload-images.jianshu.io/upload_images/1868951-859569c019ae7c80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Core Animation类图.png"><br>核心动画中可以直接使用的类有：</p><p>　　CABasicAnimation<br>　　CAKeyframeAnimation<br>　　CAAnimationGroup<br>　　CATransition<br>　　CASpringAnimation</p><p>常用属性有:</p><ul><li>duration : 动画的持续时间</li><li>beginTime : 动画的开始时间</li><li>repeatCount : 动画的重复次数</li><li>autoreverses : 执行的动画按照原动画返回执行</li><li>timingFunction : 控制动画的显示节奏系统提供五种值选择，分别是：<br>kCAMediaTimingFunctionLinear 线性动画<br>kCAMediaTimingFunctionEaseIn 先慢后快<br>kCAMediaTimingFunctionEaseOut 先快后慢<br>kCAMediaTimingFunctionEaseInEaseOut 先慢后快再慢<br>kCAMediaTimingFunctionDefault 默认，也属于中间比较快</li><li>fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后</li><li>beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间</li></ul><ul><li><p>delegate ： 动画代理。能够检测动画的执行和结束。</p><p>@interface NSObject (CAAnimationDelegate)<br>@optional</p><ul><li>(void)animationDidStart:(CAAnimation *)anim; </li><li>(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;<br>@end<br>`</li></ul></li><li><p>path：关键帧动画中的执行路径</p></li><li>type ： 过渡动画的动画类型，系统提供了四种过渡动画。<br>kCATransitionFade 渐变效果<br>kCATransitionMoveIn 进入覆盖效果<br>kCATransitionPush 推出效果<br>kCATransitionReveal 揭露离开效果</li><li><p>subtype : 过渡动画的动画方向<br>kCATransitionFromRight 从右侧进入<br>kCATransitionFromLeft 从左侧进入<br>kCATransitionFromTop 从顶部进入<br>kCATransitionFromBottom 从底部进入</p><h3 id="3、常见类介绍"><a href="#3、常见类介绍" class="headerlink" title="3、常见类介绍"></a>3、常见类介绍</h3><h3 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a>CABasicAnimation</h3><p>　　CABasicAnimation可以设定keyPath的起点，终点的值，动画会沿着设定点进行移动，CABasicAnimation可以看成是只有两个关键点的特殊的CAKeyFrameAnimation。</p><p>重要属性:</p><ul><li>fromValue ： keyPath对应的初始值</li><li>toValue ： keyPath对应的结束值</li></ul><p>基础动画主要提供了对于CALayer对象中的可变属性进行简单动画的操作。比如：位移、透明度、缩放、旋转、背景色等等。</p><p>注意点:<br>如果 fillMode = kCAFillModeForwards 和 removedOnComletion = NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</p><pre>`CABasicAnimation *positionAnima = [CABasicAnimation animationWithKeyPath:@"position.y"];positionAnima.duration = 0.8;positionAnima.fromValue = @(_iconView.center.y);positionAnima.toValue = @(_iconView.center.y-30);positionAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];positionAnima.repeatCount = HUGE_VALF;positionAnima.repeatDuration = 2;positionAnima.removedOnCompletion = NO;positionAnima.fillMode = kCAFillModeBackwards;positionAnima.delegate = self;[positionAnima setValue:@"PositionAnima" forKey:@"AnimationKey"];[_iconView.layer addAnimation:positionAnima forKey:@"AnimationMoveY"];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e4d1ad43ae37c9ed.gif?imageMogr2/auto-orient/strip" alt="CABasicAnimation.gif"></p><h3 id="CAKeyframeAnimation"><a href="#CAKeyframeAnimation" class="headerlink" title="CAKeyframeAnimation"></a>CAKeyframeAnimation</h3><p>可以设定keyPath起点、中间关键点（不止一个）、终点的值，每一帧所对应的时间，动画会沿着设定点进行移动。</p><p>重要属性:</p><ul><li>values ： 键帧数组对象，里面每一个元素即为一个关键帧，动画会在对应的时间段内，依次执行数组中每一个关键帧的动画。</li><li>path ： 动画路径对象，可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略。</li><li>keyTimes ： 可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.如果没有设置该属性，则每一帧的时间平分。</li></ul><pre>`CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"transform.rotation"];animation.duration = 0.25;animation.repeatCount = 10;animation.values = @[@0.0,@(-M_PI_4/4),@0.0,@(M_PI_4/4),@0.0];animation.keyTimes = @[@0.0,@0.25,@0.5,@0.75,@1.0];[_iconView.layer addAnimation:animation forKey:@"AnimationKey"];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-476e68184ac7d47a.gif?imageMogr2/auto-orient/strip" alt="CAKeyframeAnimation.gif"></p><h3 id="CAAnimationGroup"><a href="#CAAnimationGroup" class="headerlink" title="CAAnimationGroup"></a>CAAnimationGroup</h3><p>CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行。<br>重要属性:</p><ul><li>animations : 用来保存一组动画对象的NSArray</li></ul><pre>`CABasicAnimation *positionAnima = [CABasicAnimation animationWithKeyPath:@"position.y"];positionAnima.fromValue = @(self.iconView.center.y);positionAnima.toValue = @(self.iconView.center.y-30);positionAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];CABasicAnimation *transformAnima = [CABasicAnimation animationWithKeyPath:@"transform.rotation.y"];transformAnima.fromValue = @(0);transformAnima.toValue = @(M_PI);transformAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];CAAnimationGroup *animaGroup = [CAAnimationGroup animation];animaGroup.duration = 2.0f;animaGroup.fillMode = kCAFillModeForwards;animaGroup.removedOnCompletion = NO;animaGroup.animations = @[positionAnima,transformAnima];[self.iconView.layer addAnimation:animaGroup forKey:@"Animation"];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-730a29e7cfb59c3d.gif?imageMogr2/auto-orient/strip" alt="CAAnimationGroup.gif"></p><h3 id="CATransition"><a href="#CATransition" class="headerlink" title="CATransition"></a>CATransition</h3><p>转场动画，比UIVIew转场动画具有更多的动画效果，比如Nav的默认Push视图的效果就是通过CATransition的kCATransitionPush类型来实现。<br>重要属性:</p><ul><li>type ：动画过渡类型<br>Apple 官方的SDK其实只提供了四种过渡效果。<br>kCATransitionFade 渐变效果<br>kCATransitionMoveIn 进入覆盖效果<br>kCATransitionPush 推出效果<br>kCATransitionReveal 揭露离开效果</li></ul><p>还有一些私有API的动画类型，效果很炫酷，不过不推荐使用。比如：”cube”、”suckEffect”、”oglFlip”、”rippleEffect”、”pageCurl”、”pageUnCurl”、”cameraIrisHollowOpen”、”cameraIrisHollowClose”等等。</p></li><li><p>subtype ：动画过渡方向<br>kCATransitionFromRight 从右侧进入<br>kCATransitionFromLeft 从左侧进入<br>kCATransitionFromTop 从顶部进入<br>kCATransitionFromBottom 从底部进入</p></li><li>startProgress ：动画起点(在整体动画的百分比)</li><li><p>endProgress ：动画终点(在整体动画的百分比)<br>CATransition * transitionAnima = [CATransition animation];<br>transitionAnima.type = kCATransitionMoveIn;<br>transitionAnima.subtype = kCATransitionFromRight;<br>transitionAnima.duration = 2.5;<br>_iconView.image = [UIImage imageNamed:@”paopao”];<br>[_iconView.layer addAnimation:transitionAnima forKey:@”transitionAnima”];</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-ba2c81b3cf9682ec.gif?imageMogr2/auto-orient/strip" alt="CATransition.gif"></p><h3 id="CASpringAnimation"><a href="#CASpringAnimation" class="headerlink" title="CASpringAnimation"></a>CASpringAnimation</h3><p>CASpringAnimation是iOS9新加入动画类型，是CABasicAnimation的子类，用于实现弹簧动画。</p><p>CASpringAnimation和UIView的SpringAnimation对比：<br>　1.CASpringAnimation 可以设置更多影响弹簧动画效果的属性，可以实现更复杂的弹簧动画效果，且可以和其他动画组合。<br>　2.UIView的SpringAnimation实际上就是通过CASpringAnimation来实现。</p><p>重要属性:</p><ul><li>mass：质量（影响弹簧的惯性，质量越大，弹簧惯性越大，运动的幅度越大）</li><li>stiffness：弹性系数（弹性系数越大，弹簧的运动越快）</li><li>damping：阻尼系数（阻尼系数越大，弹簧的停止越快）</li><li>initialVelocity：初始速率（弹簧动画的初始速度大小，弹簧运动的初始方向与初始速率的正负一致，若初始速率为0，表示忽略该属性）</li><li>settlingDuration：结算时间（根据动画参数估算弹簧开始运动到停止的时间，动画设置的时间最好根据此时间来设置）</li></ul><pre>`CASpringAnimation * springAnima = [CASpringAnimation animationWithKeyPath:@"bounds"];springAnima.mass = 10.0; //质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大springAnima.stiffness = 5000; //刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快springAnima.damping = 100.0;//阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快springAnima.initialVelocity = 3.0;//初始速率，动画视图的初始速度大小;速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反springAnima.duration = springAnima.settlingDuration;springAnima.toValue = [NSValue valueWithCGRect:CGRectMake(100, 200, 200, 200)];springAnima.removedOnCompletion = NO;springAnima.fillMode = kCAFillModeForwards;springAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];[self.iconView.layer addAnimation:ani forKey:@"boundsAni"];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-c3fdaa20b8feea52.gif?imageMogr2/auto-orient/strip" alt="CASpringAnimation.gif"></p><h3 id="CATransaction"><a href="#CATransaction" class="headerlink" title="CATransaction"></a>CATransaction</h3><p>CoreAnimation中还有一个非常重要的类：CATransaction事务类，这个可以同时设置多个layer层的动画效果。可以通过隐式和显式两种方式来进行动画操作。<br>　　事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。<br>　　事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。<br>　　任何可以做动画的图层属性都会被添加到栈顶的事务，你可以通过+setAnimationDuration:方法设置当前事务的动画时间，或者通过+animationDuration方法来获取值（默认0.25秒）。<br>　　Core Animation在每个run loop周期中自动开始一次新的事务（run loop是iOS负责收集用户输入，处理定时器或者网络事件并且重新绘制屏幕的东西），即使你不显式的用[CATransaction begin]开始一次事务，任何在一次run loop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。<br>　　事务的作用：保证一个或多个layer的一个或多个属性变化同时进行<br>　　事务分为隐式和显式：<br>　　1.隐式：没有明显调用事务的方法，由系统自动生成事务。比如直接设置一个layer的position属性，则会在当前线程自动生成一个事务，并在下一个runLoop中自动commit事务。<br>　　2.显式：明显调用事务的方法（[CATransaction begin]和[CATransaction commit]）。</p><p>对layer层的属性操作，都会形成隐式动画，要使用隐式动画，需要关闭layer层的animation动画属性，使用下面的方法：</p><pre>`//关闭animation动画效果，开启隐式动画+ (BOOL)disableActions;+ (void)setDisableActions:(BOOL)flag;`</pre><p>事务的可设置属性（会覆盖隐式动画的设置）：</p><ul><li>animationDuration：动画时间 </li><li>animationTimingFunction：动画时间曲线 </li><li>disableActions：是否关闭动画 </li><li>completionBlock：动画执行完毕的回调</li></ul><p>事务支持嵌套使用：当最外层的事务commit后动画才会开始。<br>使用实例：</p><p><pre>`[CATransaction begin];<br>[CATransaction setAnimationDuration:2.0];<br>[CATransaction setAnimationTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];<br> self.iconView.layer.bounds = self.showView.layer.bounds;<br>[CATransaction commit];</pre></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 快速上手核心动画&lt;br&gt;id: 127&lt;br&gt;categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iOS&lt;br&gt;date: 2017-01-13 16:25:03&lt;br&gt;tags:&lt;br&gt;— 动画&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1、什么是核心动
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/10/27/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2017/10/27/网络基础知识/</id>
    <published>2017-10-27T04:14:02.000Z</published>
    <updated>2017-10-30T03:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 网络基础知识<br>id: 164<br>categories:</p><ul><li>网络<br>date: 2017-03-13 10:55:34<br>tags:<br>— 网络</li></ul><h3 id="计算机与网络发展"><a href="#计算机与网络发展" class="headerlink" title="计算机与网络发展"></a>计算机与网络发展</h3><p>计算机自诞生伊始,经历了一系列演变与发展。大型通用机计算机、超级计算机、小型机、个人电脑、工作站、便携式电以及现如今的智能手机终端都是这一过程的产物。它们性能逐年增强,价格却逐年下降,机体规模也在逐渐变小。</p><p>随着计算机的发展,人们不再局限于单机模式,而是将一个个计算机连接在一起,形成一个计算机网络。从而实现信息共享,同事在能在两台物理位置较远的机器之间即时传递消息。</p><p>计算机网络根据规模可以分为WAN(Wide Area Network,广域网)和LAN(Local Area Network,局域网)。</p><p>将有业务往来的计算机连在一起便组成了私有网络,将多个私有网络连接一起就成了为公众使用的互联网。</p><p>随着互联网爆发性地发展与普及,信息网络如同我们身边的空气,触手可及。但是在以前,对一般人来说使用一台计算机都不是那么容易的事情。</p><p><strong>计算机与网络大致可以分为7个阶段:</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-24fdc0e1beb7860a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机使用模式的演变.png"><br>  互联网是由许多独立发展的网络通信技术融合而成。能够使它们之间不断融合并实现统一的正是TCP/IP技术。<br>   那什么是TCP/IP呢?<br>    TCP/IP是通信协议的统称。<br>    那什么是协议呢?</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="协议的必要性"><a href="#协议的必要性" class="headerlink" title="协议的必要性"></a>协议的必要性</h4><p>协议就是计算机与计算机之间通过网络实现通信事先达成的一种“约定”。这种“约定”使那些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。反之，如果使用的协议不同，就无法通信。</p><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-9a37ee1163e62d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP/IP 是互联网相关的各类协议族的总称 .png"></p><p>协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。</p><p>像这样把与互联网相关联的协议集合起来总称为 TCP/IP。也有说法认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP/ IP 是在 IP 协议的通信过程中，使用到的协议族的统称。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-fbb4ff87606a98bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机通信协议.png"></p><p><strong>分组交换</strong> 是将大数据分割为一个个叫做包（Packet）的较小单位进行传输的方法。这里所说的包，就如同我们平常在邮局里见到的邮包。分组交换就是将大数据分装为一个个这样的邮包交给对方。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3f6b62eeab6be537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分组交换.png"></p><h4 id="协议的标准化"><a href="#协议的标准化" class="headerlink" title="协议的标准化"></a>协议的标准化</h4><p>在计算机通信诞生之初,系统化和标准化并未得到足够的重视。因此不同厂商的设备,由于支持的协议不同,仍然无法实现正常的通信。<br>就好比语言交流:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-48973be1fb252968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协议的标准化.png"><br>随着计算机重要性的不断提高,很多公司开始逐渐意思是兼容性的重要意义。<br>为了解决上述问题,ISO组织制定了一个国际标准OSI,对通信系统进行标准化。</p><p><strong>现在OSI所定义的协议虽然并没有得到普及,但是在OSI协议设计之初作为其指导方针的OSI参考模型却常被用于网络协议的制定当中。</strong></p><p>TCP/IP并非是ISO定制的国际标准,而是由IETF所致力与推进标准化作业的一种协议。现在也作为业界标准,俨然已成为全世界所广泛应用的通信协议。</p><p>协议的标准化使得所有遵循标准协议的设备不再因计算机硬件或操作系统的差异而无法通信。因此,协议的标准化推动了计算机网络的普及。</p><h4 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h4><p>ISO在制定标准化OSI之前,对网络体系结构相关的问题进行了充分的讨论并提出了作为通信协议涉及指标的OSI参考模型。这一模型将通信协议中的必要功能分成了7层。</p><p><strong> 为什么要分层呢?</strong></p><p>　如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。</p><p>值得一提的是，层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题。</p><p>协议分层就如同计算机软件中的<strong>模块化开发</strong></p><p>举个打电话的例子:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1ba9d663f91f31bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电话.png"></p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e6c32d0a8db7ee0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSI参考模型.png"></p><h4 id="OSI参考模型中每个层的作用："><a href="#OSI参考模型中每个层的作用：" class="headerlink" title="OSI参考模型中每个层的作用："></a>OSI参考模型中每个层的作用：</h4><p>1.物理层(Physical Layer)</p><p>　　物理层位于 OSI 参考模型的最低层,它直接面向原始比特流的传输。为了实现原始比特流的物理传输,物理层必须解决好包括传输介质、信道类型、数据与信号之间的转换、信号传输中的衰减和噪声等在内的一系列问题。另外,物理层标准要给出关于物理接口的机械、 电气、功能和规程特性,以便于不同的制造厂家既能够根据公认的标准各自独立地制造设备,又能使各个厂家的产品能够相互兼容。</p><p>2.数据链路层(Data Link Layer)</p><p>　　在物理层发送和接收数据的过程中,会出现一些物理层自己不能解决的问题。例如, 当两个节点同时试图在一条线路上发送数据时该如何处理?节点如何知道它所接收的数据 是否正确?如果噪声改变了一个分组的目标地址,节点如何察觉它丢失了本应收到的分组呢?这些都是数据链路层所必须负责的工作。</p><p>　　数据链路层涉及相邻节点之间的可靠数据传输,数据链路层通过加强物理层传输原始比特的功能,使之对网络层表现为一条无错线路。为了能够实现相邻节点之间无差错的数据传送,数据链路层在数据传输过程中提供了确认、差错控制和流量控制等机制。</p><p>3.网络层(Network Layer)</p><p>　　网络中的两台计算机进行通信时,中间可能要经过许多中间结点甚至不同的通信子网。 网络层的任务就是在通信子网中选择一条合适的路径,使发送端传输层所传下来的数据能 够通过所选择的路径到达目的端。</p><p>　　为了实现路径选择,网络层必须使用寻址方案来确定存在哪些网络以及设备在这些网络中所处的位置,不同网络层协议所采用的寻址方案是不同的。在确定了目标结点的位置后, 网络层还要负责引导数据包正确地通过网络,找到通过网络的最优路径,即路由选择。如果子网中同时出现过多的分组,它们将相互阻塞通路并可能形成网络瓶颈,所以网络层还需要提供拥塞控制机制以避免此类现象的出现。另外,网络层还要解决异构网络互连问题。</p><p>4.传输层(Transport Layer)</p><p>　　传输层是 OSI 七层模型中唯一负责端到端节点间数据传输和控制功能的层。传输层是 OSI 七层模型中承上启下的层,它下面的三层主要面向网络通信,以确保信息被准确有效地传输;它上面的三个层次则面向用户主机,为用户提供各种服务。</p><p>　　传输层通过弥补网络层服务质量的不足,为会话层提供端到端的可靠数据传输服务。它为会话层屏蔽了传输层以下的数据通信的细节,使会话层不会受到下三层技术变化的影响。但同时,它又依靠下面的三个层次控制实际的网络通信操作,来完成数据从源到目标的传输。传输层为了向会话层提供可靠的端到端传输服务,也使用了差错控制和流量控制等机制。</p><p>5.会话层(Session Layer)</p><p>　　会话层的功能是在两个节点间建立、维护和释放面向用户的连接。它是在传输连接的基础上建立会话连接,并进行数据交换管理,允许数据进行单工、半双工和全双工的传送。会话层提供了令牌管理和同步两种服务功能。</p><p>6.表示层(Presentation Layer)</p><p>　　表示层以下的各层只关心可靠的数据传输,而表示层关心的是所传输数据的语法和语义。它主要涉及处理在两个通信系统之间所交换信息的表示方式,包括数据格式变换、数据加密与解密、数据压缩与恢复等功能。</p><p>7.应用层(Application Layer)</p><p>　　应用层是 OSI 参考模型的最高层,负责为用户的应用程序提供网络服务。与 OSI 其他层不同的是,它不为任何其他 OSI 层提供服务,而只是为 OSI 模型以外的应用程序提供服务。包括为相互通信的应用程序或进行之间建立连接、进行同步,建立关于错误纠正和控 制数据完整性过程的协商等。应用层还包含大量的应用协议,如分布式数据库的访问、文件的交换、电子邮件、虚拟终端等。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-d13f6ca5798b3f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="每个层的作用.png"></p><p>许多通信协议,都对应了OSI参考模型7个分层中的某层。通过这一点,可以大致了解该协议在整个通信功能中的位置和作用。<br><img src="http://upload-images.jianshu.io/upload_images/1868951-b70b962052e39a50.gif?imageMogr2/auto-orient/strip" alt="各层对应的协议"></p><p>举个例子：假设主机A的用户A要给主机B的用户B发送一封电子邮件：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6ea6ba3cc3d59b92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-10 上午10.27.04.png"></p><p>　发送方从第7层、第6层到第1层由上至下按照顺序传输数据，而接收端则从第1层、第2层到第7层由下至上向每个上一级分层传输数据。每个分层上，在处理由上一层传过来的数据时可以附上当前分层的协议所必须的“首部”信息。然后接收端对收到的数据进行数据“首部”与“内容”的分离，再转发给上一分层，并最终将发送端的数据恢复为原状。</p><h3 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h3><p>网络与通信中可以根据其数据发送方法进行多种分类。</p><ol><li>面向连接与面向无连接</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e0860a956a3d7dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏面向连接与面向无连接.png"></p><p>2.电路交换与分组交换</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0a259607b181f0e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电路交换与分组交换.png"></p><p>3.根据接收端数量来分</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-191e8eef54b435a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单播,广播,多播,任播.png"></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>通信传输中,发送端和接收端都可以被视作通讯主体。它们都能由一个所谓的”地址”的信息标识出来。比如打电话,电话号码就是”地址”,比如寄快递,家庭住址就是”地址”。</p><p>在TCP/IP通信中使用MAC地址,IP地址,端口号等信息作为地址标识。甚至在应用层中可以将电子邮件地址作为网络通信的地址。</p><p>地址具有<strong>唯一性</strong><br>当地址总数多时,需要有<strong>层次性</strong>来快速定位。</p><h3 id="网络的构成要素"><a href="#网络的构成要素" class="headerlink" title="网络的构成要素"></a>网络的构成要素</h3><p>搭建一套网络环境要涉及到各种各样的电缆和网络设备。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6e189b0afaffd65b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构成及作用.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-9d29c855104afad4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各设备对应的网络分层.png"></p><ul><li>数据链路与通信媒介</li></ul><p>计算机之间通过电缆相互连接。电缆可以分为多种,包括双绞线电缆、光纤电缆、同轴电缆、串行电缆等。而媒介本身也可以被划分为电波、微波等不同类型的电磁波。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-520f38933628a5af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据链路.png"></p><ul><li>网卡<br>计算机连接网络时,必须要使用网卡,也被称作网络适配器、LAN卡。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-56fc60b0220828c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网卡.png"></p><ul><li>中继器</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3620a28242606b22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中继器.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1c6682f5e6511f76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中继集线器.png"></p><ul><li>网桥<br>位于OSI模型中的第二层–数据链路层上连接两个网络的设备。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3de2632f11c7ef7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网桥.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-2c56652f52fe6368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自学式网桥及交换集线器.png"></p><ul><li>路由器<br>路由器位于第三层–网络层上连接两个设备、并对分组保温进行转发的设备。<br>网桥是根据MAC地质处理的,路由器是根据IP地址进行处理的。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-8b75041239d274fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="路由器.png"></p><ul><li><p>4~7层交换机<br>负责处理OSI模型中从传输层至应用层的数据。用TCP/IP来表述的话,就是以TCP/IP等协议的传输层及其上面的应用层为基础,分析首发数据,并对其进行特定的处理。<br>主要功能:负载均衡器,带宽控制,广域网加速器,特殊应用访问加速,及防火墙等。</p></li><li><p>网关</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e423d61f84e63f05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网关.png"></p><p>举个例子:电脑跟手机邮件有时候会不兼容,需要网关的转换<br><img src="http://upload-images.jianshu.io/upload_images/1868951-206c0ce693b39859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-10 下午3.17.19.png"></p><p>有时候为了控制流量或保证安全,会有代理服务器,防火墙等都是网关的一种。</p><p>比如谷歌被墙啊:<br><img src="http://upload-images.jianshu.io/upload_images/1868951-0b2d9c28f4005719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="防火墙.png"></p><h3 id="现代网络实态"><a href="#现代网络实态" class="headerlink" title="现代网络实态"></a>现代网络实态</h3><p>看图吧:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-d45d0cd64a4725d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实际网络构成.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1e57df41ae6e9aa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移动通信.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f6e9e4649b6ac32e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据中心.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-96ccc729e8e096dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="云服务.png"></p><p>来个总结:</p><p>学习TCP/IP知识前需要先了解下计算机网络出现的背景及发展阶段,了解矛盾才能明白出现TCP/IP的必然性。<br>另外我们知道想要通信需要先遵守协议,为了更好的互联,要推动协议的标准化,然后标准化又促进了计算机网络的发展。<br>然后为了简便,谈到了协议的分层从而出现了OSI参考模型,知道了各层的分类及作用后,我们再看看现实生活中的网络构成及应用实态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 网络基础知识&lt;br&gt;id: 164&lt;br&gt;categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络&lt;br&gt;date: 2017-03-13 10:55:34&lt;br&gt;tags:&lt;br&gt;— 网络&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;计算机与网络发展&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>带你了解UIKit动力学</title>
    <link href="http://yoursite.com/2017/10/27/%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3UIKit%E5%8A%A8%E5%8A%9B%E5%AD%A6/"/>
    <id>http://yoursite.com/2017/10/27/带你了解UIKit动力学/</id>
    <published>2017-10-27T02:35:27.000Z</published>
    <updated>2017-10-30T04:01:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、简单介绍"><a href="#一、简单介绍" class="headerlink" title="一、简单介绍"></a>一、简单介绍</h3><p>1.什么是UIDynamic<br>UIDynamic是从iOS 7开始引入的一种新技术，隶属于UIKit框架可以认为是一种物理引擎，能模拟和仿真现实生活中的物理现象如：重力、弹性碰撞等现象</p><p>2.物理引擎的价值<br>广泛用于游戏开发，经典成功案例是“愤怒的小鸟”,让开发人员可以在远离物理学公式的情况下，实现炫酷的物理仿真效果提高了游戏开发效率，产生更多优秀好玩的物理仿真游戏</p><p>3.知名的2D物理引擎<br>Box2d<br>Chipmunk</p><h3 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h3><p>要想使用UIDynamic来实现物理仿真效果，大致的步骤如下:</p><p>1.创建一个物理仿真器（顺便设置仿真范围）<br>2.创建相应的物理仿真行为（顺便添加物理仿真元素）<br>3.将物理仿真行为添加到物理仿真器中开始仿真</p><h3 id="三、相关说明"><a href="#三、相关说明" class="headerlink" title="三、相关说明"></a>三、相关说明</h3><p>1.三个概念</p><ul><li>谁要进行物理仿真？<br>　　物理仿真元素（Dynamic Item）</li><li>执行怎样的物理仿真效果？怎样的动画效果？<br>　　物理仿真行为（Dynamic Behavior） </li><li>让物理仿真元素执行具体的物理仿真行为<br>　　物理仿真器（Dynamic Animator）</li></ul><p>2.物理仿真元素<br>注意：<br>不是任何对象都能做物理仿真元素<br>不是任何对象都能进行物理仿真</p><p>物理仿真元素要素：<br>任何遵守了UIDynamicItem协议的对象<br>UIView默认已经遵守了UIDynamicItem协议，因此任何UI控件都能做物理仿真</p><p>UICollectionViewLayoutAttributes类默认也遵守UIDynamicItem协议</p><p>3.物理仿真行为</p><p>（1）UIDynamic提供了以下几种物理仿真行为</p><ul><li>UIGravityBehavior：重力行为</li></ul><ul><li><p>UICollisionBehavior：碰撞行为</p></li><li><p>UISnapBehavior：捕捉行为</p></li><li><p>UIPushBehavior：推动行为</p></li><li><p>UIAttachmentBehavior：附着行为</p></li><li><p>UIDynamicItemBehavior：动力元素行为</p></li></ul><p>（2）物理仿真行为须知<br>上述所有物理仿真行为都继承自UIDynamicBehavior，所有的UIDynamicBehavior都可以独立进行组合使用多种行为时，可以实现一些比较复杂的效果</p><p>4.物理仿真器</p><p>（1）物理仿真器须知<br>它可以让物理仿真元素执行物理仿真行为<br>它是UIDynamicAnimator类型的对象<br>（2）UIDynamicAnimator的初始化</p><pre><code>- (instancetype)initWithReferenceView:(UIView *)view;`&lt;/pre&gt;view参数：是一个参照视图，表示物理仿真的范围5.物理仿真器的说明（1）UIDynamicAnimator的常见方法&lt;pre&gt;`//移除之前添加过的所有物理仿真行为  - (void)addBehavior:(UIDynamicBehavior *)behavior; //移除之前添加过的所有物理仿真行为　- (void)removeBehavior:(UIDynamicBehavior *)behavior; //添加1个物理仿真行为　- (void)removeAllBehaviors; `&lt;/pre&gt;（2）UIDynamicAnimator的常见属性&lt;pre&gt;` //参照视图 @property (nonatomic, readonly) UIView* referenceView;  //添加到物理仿真器中的所有物理仿真行为@property (nonatomic, readonly, copy) NSArray* behaviors;//是否正在进行物理仿真@property (nonatomic, readonly, getter = isRunning) BOOL running;//代理对象（能监听物理仿真器的仿真过程，比如开始和结束）@property (nonatomic, assign) id `&lt;/pre&gt;### 四、案例介绍**先看效果吧**- UIGravityBehavior：重力行为![UIGravityBehavior.gif](http://upload-images.jianshu.io/upload_images/1868951-9cd5fca7213318f5.gif?imageMogr2/auto-orient/strip)</code></pre><ul><li><p>UICollisionBehavior：碰撞行为</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-708e87550affbb35.gif?imageMogr2/auto-orient/strip" alt="UICollisionBehavior.gif"></p></li><li><p>UISnapBehavior：捕捉行为</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-52ed8f15d48010b5.gif?imageMogr2/auto-orient/strip" alt="UISnapBehavior.gif"></p></li><li><p>UIPushBehavior：推动行为</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1853b803c4d6db02.gif?imageMogr2/auto-orient/strip" alt="UIPushBehavior.gif"></p></li><li><p>复合效果</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3cebeb72c623eb4e.gif?imageMogr2/auto-orient/strip" alt="复合效果.gif"></p><p><strong>最后是代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line">&lt;pre&gt;`#import &amp;lt;UIKit/UIKit.h&amp;gt;</div><div class="line"></div><div class="line">@interface SecondViewController : UIViewController</div><div class="line">@property (weak, nonatomic) IBOutlet UIView *blueView;</div><div class="line">@property (weak, nonatomic) IBOutlet UIView *orangeView;</div><div class="line">@property (weak, nonatomic) IBOutlet UISegmentedControl *segmented;</div><div class="line">@property (weak, nonatomic) IBOutlet UIView *redView;</div><div class="line">@property (nonatomic,strong) UIDynamicAnimator *animator;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;SecondViewController.h&quot;</div><div class="line"></div><div class="line">@interface SecondViewController ()</div><div class="line">@property (nonatomic,strong)UISnapBehavior *snapBehavior;</div><div class="line">@property (nonatomic,strong)UIPushBehavior *pushBehavior;</div><div class="line">@property (nonatomic,strong)UIAttachmentBehavior *attachmentBehavior;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation SecondViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    self.blueView.transform =  CGAffineTransformMakeRotation(M_PI_4);</div><div class="line">    self.segmented.transform = CGAffineTransformMakeRotation(-M_PI / 8);</div><div class="line"></div><div class="line">    if (!_pushBehavior) &#123;</div><div class="line">        _pushBehavior = [[UIPushBehavior alloc]initWithItems:@[_blueView] mode:UIPushBehaviorModeContinuous];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _pushBehavior.active = YES;</div><div class="line">    _pushBehavior.pushDirection = CGVectorMake(10.0f, 10.0f);</div><div class="line">    _pushBehavior.magnitude = 1.0f;</div><div class="line">    [self.animator addBehavior:_pushBehavior];</div><div class="line"></div><div class="line">&#125;</div><div class="line">- (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:    (UIEvent *)event &#123;</div><div class="line">    _pushBehavior.active = NO;</div><div class="line"></div><div class="line">    //创建重力行为</div><div class="line">    UIGravityBehavior *gravityBehavior = [[UIGravityBehavior alloc]init];</div><div class="line">    [gravityBehavior addItem:self.blueView];</div><div class="line">    [gravityBehavior addItem:self.orangeView];</div><div class="line">    [gravityBehavior addItem:self.segmented];</div><div class="line">    gravityBehavior.gravityDirection = CGVectorMake(-0.3f, 1.0f);</div><div class="line">    //加速度</div><div class="line">    gravityBehavior.magnitude = 3;</div><div class="line">    //创建碰撞行为</div><div class="line">    UICollisionBehavior *collisionBehavior = [[UICollisionBehavior alloc]init];</div><div class="line">    //碰撞类型为元素和边界</div><div class="line">    collisionBehavior.collisionMode = UICollisionBehaviorModeEverything;</div><div class="line"></div><div class="line">    CGFloat Y = self.view.frame.size.height - CGRectGetHeight(self.redView.frame);</div><div class="line">    CGFloat X = self.view.frame.size.width;</div><div class="line">    CGFloat height = self.view.frame.size.height;</div><div class="line"></div><div class="line">    //设置红色的View为底边界,左边框跟右边框作为边界</div><div class="line">    [collisionBehavior addBoundaryWithIdentifier:@&quot;collision1&quot; fromPoint:CGPointMake(0,Y) toPoint:CGPointMake(X, Y)];</div><div class="line">    [collisionBehavior addBoundaryWithIdentifier:@&quot;collision2&quot; fromPoint:CGPointMake(0, 0) toPoint:CGPointMake(0, height)];</div><div class="line">    [collisionBehavior addBoundaryWithIdentifier:@&quot;collision3&quot; fromPoint:CGPointMake(X,0) toPoint:CGPointMake(X, height)];</div><div class="line"></div><div class="line">    [collisionBehavior addItem:self.blueView];</div><div class="line">    [collisionBehavior addItem:self.segmented];</div><div class="line">    [collisionBehavior addItem:self.orangeView];</div><div class="line">    [self.animator addBehavior:collisionBehavior];</div><div class="line">    [self.animator addBehavior:gravityBehavior];</div><div class="line"></div><div class="line">    UIDynamicItemBehavior *itemBehavior = [[UIDynamicItemBehavior alloc] initWithItems:@[self.blueView]];</div><div class="line">    [itemBehavior setElasticity:0.5];</div><div class="line">    [self.animator addBehavior:itemBehavior];</div><div class="line"></div><div class="line">    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapGesture:)];</div><div class="line">    [self.view addGestureRecognizer:tap];</div><div class="line">&#125;</div><div class="line">- (void)tapGesture:(UITapGestureRecognizer *)gesture</div><div class="line">&#123;</div><div class="line">    CGPoint tapPoint = [gesture locationInView:self.view];</div><div class="line">    if (_snapBehavior) &#123;</div><div class="line">        [self.animator removeBehavior:_snapBehavior];</div><div class="line">        _snapBehavior = nil;</div><div class="line">    &#125;</div><div class="line">    _snapBehavior = [[UISnapBehavior alloc]initWithItem:self.blueView snapToPoint:tapPoint];</div><div class="line">    _snapBehavior.action = ^()&#123;</div><div class="line">        NSLog(@&quot;UISnapBehavior 在执行&quot;);</div><div class="line">    &#125;;</div><div class="line">    _snapBehavior.damping = 0.9;</div><div class="line">    [self.animator addBehavior:_snapBehavior];</div><div class="line">&#125;</div><div class="line">- (UIDynamicAnimator *)animator&#123;</div><div class="line">    if (_animator == nil) &#123;</div><div class="line">        _animator = [[UIDynamicAnimator alloc]init];</div><div class="line">    &#125;</div><div class="line">    return _animator;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)panGestureRecognizer:(UIPanGestureRecognizer *)gesture</div><div class="line">&#123;</div><div class="line">    CGPoint location = [gesture locationInView:self.view];</div><div class="line">    CGPoint imageLocation = [gesture locationInView:self.orangeView];</div><div class="line">    switch (gesture.state) &#123;</div><div class="line">        case UIGestureRecognizerStateBegan:</div><div class="line">        &#123;</div><div class="line">            NSLog(@&quot;touch position %@&quot;,NSStringFromCGPoint(location));</div><div class="line">            NSLog(@&quot;loction in image %@&quot;,NSStringFromCGPoint(imageLocation));</div><div class="line">            [self.animator removeAllBehaviors];</div><div class="line"></div><div class="line">            UIOffset centerOffset = UIOffsetMake(imageLocation.x - CGRectGetMidX(self.orangeView.bounds), imageLocation.y - CGRectGetMidY(self.orangeView.bounds));</div><div class="line">            _attachmentBehavior = [[UIAttachmentBehavior alloc]initWithItem:self.orangeView offsetFromCenter:centerOffset attachedToAnchor:location];</div><div class="line">            _attachmentBehavior.damping = 0.5;</div><div class="line">            _attachmentBehavior.frequency = 0.8;</div><div class="line">            [self.animator addBehavior:_attachmentBehavior];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        case UIGestureRecognizerStateEnded:</div><div class="line">        &#123;</div><div class="line">            [self.animator removeBehavior:_attachmentBehavior];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">        &#123;</div><div class="line">            [_attachmentBehavior setAnchorPoint:[gesture locationInView:self.view]];</div><div class="line">        &#125;</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">    // Dispose of any resources that can be recreated.</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line"> #pragma mark - Navigation</div><div class="line"></div><div class="line"> // In a storyboard-based application, you will often want to do a little preparation before navigation</div><div class="line"> - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</div><div class="line"> // Get the new view controller using [segue destinationViewController].</div><div class="line"> // Pass the selected object to the new view controller.</div><div class="line"> &#125;</div><div class="line"> */</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></li></ul><p>UIKit动力学的部分介绍完了.<br>最开始项目中只是用到了重力跟碰撞行为,参考学习了:<a href="http://www.jianshu.com/p/07552fc17734" target="_blank" rel="external">UIDynamic 详细用法</a> 中的案例.然后自己又展开了解了下UIKit动力学的知识,把捕捉行为,推动行为加了进去,做个完善.整理了一下.就是这样.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、简单介绍&quot;&gt;&lt;a href=&quot;#一、简单介绍&quot; class=&quot;headerlink&quot; title=&quot;一、简单介绍&quot;&gt;&lt;/a&gt;一、简单介绍&lt;/h3&gt;&lt;p&gt;1.什么是UIDynamic&lt;br&gt;UIDynamic是从iOS 7开始引入的一种新技术，隶属于UIKit框
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/10/27/hello-world/"/>
    <id>http://yoursite.com/2017/10/27/hello-world/</id>
    <published>2017-10-27T02:28:02.000Z</published>
    <updated>2017-10-27T02:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>快速上手UIBezierPath</title>
    <link href="http://yoursite.com/2017/01/19/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BUIBezierPath/"/>
    <id>http://yoursite.com/2017/01/19/快速上手UIBezierPath/</id>
    <published>2017-01-19T07:41:22.000Z</published>
    <updated>2017-10-30T04:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>UIBezierPath主要用来绘制矢量图形，它是基于Core Graphics对CGPathRef数据类型和path绘图属性的一个封装，所以是需要图形上下文的（CGContextRef），所以一般UIBezierPath在drawRect中使用。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>UIBezierPath 是对 CGPathRef 的封装。创建矢量图形时，拆解成一或多条线段，拼接起来，每条线段的终点都是下一条线段的起点。</p><p>具体地：</p><p>1.创建一个 UIBezierPath 对象<br>2.用 moveToPoint: 设置初始线段的起点<br>3.添加线段，定义一或多个子路径<br>4.修改 UIBezierPath 的绘图相关的属性，比如stroke path的属性 lineWidth 和 lineJoinStyle ，filled path的属性 usesEvenOddFillRule</p><p>注意:如果是矩形或者圆之类的特殊图形，可以不用第2步。</p><h3 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h3><ul><li><p>画直线</p><pre><code>UIBezierPath *path = [UIBezierPath bezierPath];[path moveToPoint:CGPointMake(50, 50)];[path addLineToPoint:CGPointMake(100, 50)];path.lineWidth = 5.0f;path.lineJoinStyle = kCGLineJoinRound;[path stroke];</code></pre><p>`</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-16ff36f673e553cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="直线.png"></p></li><li><p>创建三角形</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(50, 50)];    [path addLineToPoint:CGPointMake(300, 50)];    [path addLineToPoint:CGPointMake(200, 150)];    // 最后的闭合线是可以通过调用closePath方法来自动生成的，也可以调用-addLineToPoint:方法来添加    //  [path addLineToPoint:CGPointMake(50, 50)];    [path closePath];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-aea9cce78dcbb04d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三角形.png"></p></li><li><p>创建矩形</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(50, 100, 50, 50)];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-8dbfcbd9be34a2fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="矩形.png"></p></li><li><p>创建内切曲线</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 200, 50, 50)];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-33d7bec06da43891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="圆.png"></p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 200, 50, 100)];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-45261ea74f94f5e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="椭圆.png"></p></li><li><p>创建带有圆角的矩形，当矩形变成正圆的时候，Radius就不再起作用</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 300, 50, 50) cornerRadius:15.0f];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-69993e6575524f1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="带有圆角的矩形.png"></p></li><li><p>设定特定的角为圆角的矩形</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 400, 50, 50) byRoundingCorners:UIRectCornerBottomLeft cornerRadii:CGSizeMake(5,5)];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-2eb9c4626845e02f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特定的角为圆角的矩形.png"></p></li><li><p>创建圆弧</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(100, 550) radius:25 startAngle:0 endAngle:1.5*M_PI clockwise:YES];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e21ece42c37ee1d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建圆弧.png"></p></li><li><p>通过路径A创建路径B</p><pre>`    UIBezierPath *path_A = [UIBezierPath bezierPath];    [path_A moveToPoint:CGPointMake(200, 50)];    [path_A addLineToPoint:CGPointMake(250, 100)];    path_A.lineWidth = 5.0f;    UIBezierPath *path_B = [UIBezierPath bezierPathWithCGPath:path_A.CGPath];    [path_B stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e7bacd50200981a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过路径A创建路径B.png"></p></li><li><p>创建三次贝塞尔曲线</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(100, 200)];    [path addCurveToPoint:CGPointMake(300, 200) controlPoint1:CGPointMake(150, 150) controlPoint2:CGPointMake(250, 250)];    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f9c30b5d17806b03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次贝塞尔曲线.png"></p></li><li><p>创建二次贝塞尔曲线</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(100, 200)];    [path addQuadCurveToPoint:CGPointMake(300, 200) controlPoint:CGPointMake(150, 150)];    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-b576d92730e22a33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二次贝塞尔曲线.png"></p></li><li><p>添加圆弧</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(200, 400)];    [path addLineToPoint:CGPointMake(225, 410)];    [path addArcWithCenter:CGPointMake(200, 400) radius:25 startAngle:0 endAngle:1.5*M_PI clockwise:YES];//    [path closePath];//    [path removeAllPoints];    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-4c5f96ba08475740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加圆弧.png"></p></li><li><p>追加路径</p><pre>`    UIBezierPath *path_A = [UIBezierPath bezierPath];    [path_A moveToPoint:CGPointMake(200, 500)];    [path_A addLineToPoint:CGPointMake(225, 410)];    UIBezierPath *path_B = [UIBezierPath bezierPath];    [path_B moveToPoint:CGPointMake(200, 600)];    [path_B addLineToPoint:CGPointMake(225, 500)];    [path_A appendPath:path_B];    [path_A stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3192e79c84b3393f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="追加路径.png"></p></li><li><p>创建翻转路径，即起点变成终点，终点变成起点</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(50, 50)];    [path addLineToPoint:CGPointMake(100, 50)];    path.lineWidth = 5.0f;    NSLog(@"%@",NSStringFromCGPoint(path.currentPoint));    UIBezierPath *path_b = [path bezierPathByReversingPath];    CGAffineTransform transform = CGAffineTransformMakeTranslation(200, 0);    [path_b applyTransform: transform];    // 两条路径分别添加一条直接到 self.center    [path addLineToPoint: CGPointMake(self.frame.size.width*0.5, self.frame.size.height*0.5)];    [path_b addLineToPoint: CGPointMake(self.frame.size.width*0.5, self.frame.size.height*0.5)];    NSLog(@"%@",NSStringFromCGPoint(path_b.currentPoint));    [[UIColor redColor] set];    [path stroke];    [[UIColor blueColor] set];    [path_b stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-7d3a6fbc364a219c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建翻转路径.png"></p></li><li><p>路径进行仿射变换</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(100, 50)];    [path addLineToPoint:CGPointMake(200, 50)];    CGAffineTransform transform =  CGAffineTransformRotate(self.transform, M_PI_4);    [path applyTransform:transform];    path.lineWidth = 5.0f;    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0582260c77588276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="仿射变换.png"></p></li><li><p>创建虚线</p><pre>`    CGFloat dashStyle[] = {1.0f, 2.0f};    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(50, 50)];    [path addLineToPoint:CGPointMake(100, 50)];    [path setLineDash:dashStyle count:2 phase:0.0];    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-699954cefed52f84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建虚线.png"></p></li><li><p>设置颜色</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)];    [[UIColor greenColor] setStroke];    [[UIColor redColor] setFill];    [path stroke];    [path fill];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-a86a7876b611d3c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-01-19 下午1.49.31.png"></p></li><li><p>设置描边混合模式</p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)];    [[UIColor greenColor] setStroke];    path.lineWidth = 10.0f;    [path strokeWithBlendMode:kCGBlendModeSaturation alpha:1.0];    [path stroke];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6834121170a017fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Stroke混合.png"></p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)];    [[UIColor redColor] setFill];    [path fillWithBlendMode:kCGBlendModeSaturation alpha:0.6];    [path fill];`</pre><p><img src="http://upload-images.jianshu.io/upload_images/1868951-91da4d71de0f0f28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fill混合.png"></p></li><li><p>修改当前图形上下文的绘图区域可见,随后的绘图操作导致呈现内容只有发生在指定路径的填充区域</p><p><pre>`    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)];</pre></p><pre><code>[[UIColor greenColor] setStroke];[path addClip];[path stroke];</code></pre></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-38adb693ff8fea97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Clip.png"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>关于UIBezierPath的简单介绍就到这了,主要是用代码做了展示,属性跟方法,没详细去介绍,我觉得可以直接看苹果的api写的也蛮清楚的.或者自己试试不同的参数样式也能大概理解了.另外简书上看到有篇文章对属性及方法介绍的蛮详细的,可以去看看:<a href="http://www.jianshu.com/p/6130b51a0b71" target="_blank" rel="external">UIBezierPath</a></p><p>核心动画跟贝赛尔曲线都有了简单的介绍了,接下来就可以动手做点简单的自定义动画了.会在下一篇更新.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UIBezierPath主要用来绘制矢量图形，它是基于Core Graphics对CGPathRef数据类型和path绘图属性的一个封装，所以是需要图形上下文的（CGContextRef），所以一般UIBezierPath在drawRect中使用。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>
