<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛洛爱吃肉</title>
  
  <subtitle>学海无涯,进一步有进一步的欢喜.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-30T06:06:29.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>loirou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重置mac网络设置</title>
    <link href="http://yoursite.com/2017/10/24/tips/%E9%87%8D%E7%BD%AEmac%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/10/24/tips/重置mac网络设置/</id>
    <published>2017-10-24T03:22:00.000Z</published>
    <updated>2017-10-30T06:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1868951-a5e6281a5fdcf2a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-10-24 上午11.19.27.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1868951-a5e6281a5fdcf2a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
      <category term="tips" scheme="http://yoursite.com/categories/tips/"/>
    
    
      <category term="tips" scheme="http://yoursite.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>缓存网易云音乐</title>
    <link href="http://yoursite.com/2017/09/28/tips/%E7%BC%93%E5%AD%98%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    <id>http://yoursite.com/2017/09/28/tips/缓存网易云音乐/</id>
    <published>2017-09-28T08:33:00.000Z</published>
    <updated>2017-10-30T06:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1868951-1ba8f4f4aea735d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1868951-1ba8f4f4aea735d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
      <category term="tips" scheme="http://yoursite.com/categories/tips/"/>
    
    
      <category term="tips" scheme="http://yoursite.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>日期小demo</title>
    <link href="http://yoursite.com/2017/09/28/iOS/%E6%97%A5%E6%9C%9F%E5%B0%8Fdemo/"/>
    <id>http://yoursite.com/2017/09/28/iOS/日期小demo/</id>
    <published>2017-09-28T08:26:00.000Z</published>
    <updated>2017-10-31T09:56:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>有个项目需求是做个在日期上选择的,就是这种:<br><img src="http://upload-images.jianshu.io/upload_images/1868951-f9743a36922cc91e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需求"></p><p>网上看了几个日期的demo都太厚重了,移植起来太麻烦,然后打算自己写。</p><p>就先写个简化的demo看看,主要有几个关键点:</p><ul><li>首先要根据当前日期获取这个月有几天</li><li>然后判断这个月份第一天是周几</li><li>再根据上面两个数据在合理的位置显示数据</li><li>还要记录下当前的日期方便切换月份</li><li>如果调接口的话其实根据后台给数据比对下对应的日期展示数据即可</li></ul><p>其中有一个容易迷糊的是获取的星期天是第一天,下标是1<br>所以我们的数组是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_weekdays = [NSArray arrayWithObjects: [NSNull null],@&quot;星期日&quot;, @&quot;周一&quot;, @&quot;周二&quot;, @&quot;周三&quot;, @&quot;周四&quot;, @&quot;周五&quot;, @&quot;周六&quot;, nil];</div></pre></td></tr></table></figure><p>好吧,看下写出来的效果:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-05c9fbf48e14ddd7.gif?imageMogr2/auto-orient/strip" alt="demo"></p><p>总的来说没什么难度,就是要熟悉下关于日期的api.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//3.获取这个月总天数,填充数据源</div><div class="line"> NSRange range = [calendar rangeOfUnit:NSCalendarUnitDay inUnit:NSCalendarUnitMonth forDate:self.currentDate];</div><div class="line"> NSUInteger numberOfDaysInMonth = range.length;</div><div class="line"> NSLog(@&quot;%lu&quot;, (unsigned long)numberOfDaysInMonth);</div><div class="line"> </div><div class="line"> //4.获取这个月的第一天为周几</div><div class="line"> NSCalendar *cal = [NSCalendar currentCalendar];</div><div class="line"> NSDateComponents *comps = [cal</div><div class="line">                            components:NSCalendarUnitYear | NSCalendarUnitMonth</div><div class="line">                            fromDate:self.currentDate];</div><div class="line"> lastMonthComps.day = 1;</div><div class="line"> NSDate *firstDay = [cal dateFromComponents:comps];</div><div class="line"> NSCalendarUnit calendarUnit = NSCalendarUnitWeekday;</div><div class="line"> NSDateComponents *firsComponents = [cal components:calendarUnit fromDate:firstDay];</div><div class="line"> </div><div class="line"> NSLog(@&quot;%@&quot;, [_weekdays objectAtIndex:firsComponents.weekday]);</div></pre></td></tr></table></figure><p><a href="https://github.com/loirou/datePicker" target="_blank" rel="external">demo完整代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有个项目需求是做个在日期上选择的,就是这种:&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1868951-f9743a36922cc91e.png?imageMogr2/auto-orient/str
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS混合开发研究</title>
    <link href="http://yoursite.com/2017/09/15/iOS/iOS%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2017/09/15/iOS/iOS混合开发研究/</id>
    <published>2017-09-15T01:41:00.000Z</published>
    <updated>2017-10-31T09:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/oc-bowen/p/5423902.html" target="_blank" rel="external">iOS-Hybrid</a><br><a href="http://www.jianshu.com/p/b88944250b25" target="_blank" rel="external">写给移动开发者的 React Native 指南</a><br><a href="http://eteng-wiki.github.io/HAC-WIKI/buildEnv/" target="_blank" rel="external">Cordova教程</a><br><a href="http://www.chongchonggou.com/g_41684204.html" target="_blank" rel="external">在已有 Xcode 项目中 加入Cordova框架</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/oc-bowen/p/5423902.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS-Hybrid&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC与JS交互</title>
    <link href="http://yoursite.com/2017/09/11/iOS/OC%E4%B8%8EJS%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2017/09/11/iOS/OC与JS交互/</id>
    <published>2017-09-11T09:09:00.000Z</published>
    <updated>2017-10-31T09:39:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/markstray/p/5757828.html" target="_blank" rel="external"><a href="http://www.cnblogs.com/markstray/p/5757828.html" target="_blank" rel="external">OC与JS交互前言</a></a></p><p><a href="http://www.cnblogs.com/markstray/p/5757238.html" target="_blank" rel="external"><a href="http://www.cnblogs.com/markstray/p/5757238.html" target="_blank" rel="external">OC与JS交互之UIWebView</a></a></p><p><a href="http://www.cnblogs.com/markstray/p/5757244.html" target="_blank" rel="external"><a href="http://www.cnblogs.com/markstray/p/5757244.html" target="_blank" rel="external">OC与JS交互之WebViewJavascriptBridge</a></a></p><p><a href="http://www.cnblogs.com/markstray/p/5757255.html" target="_blank" rel="external"><a href="http://www.cnblogs.com/markstray/p/5757255.html" target="_blank" rel="external">OC与JS交互之JavaScriptCore</a></a></p><p><a href="http://www.cnblogs.com/markstray/p/5757264.html" target="_blank" rel="external"><a href="http://www.cnblogs.com/markstray/p/5757264.html" target="_blank" rel="external">OC与JS交互之WKWebView</a></a></p><p><a href="http://www.brighttj.com/ios/ios-user-safari-debug-webview.html" target="_blank" rel="external">使用safari对webview进行调试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/markstray/p/5757828.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/markstray/p/5757
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS如何使屏幕一直保持亮屏？</title>
    <link href="http://yoursite.com/2017/08/23/iOS/iOS%E5%A6%82%E4%BD%95%E4%BD%BF%E5%B1%8F%E5%B9%95%E4%B8%80%E7%9B%B4%E4%BF%9D%E6%8C%81%E4%BA%AE%E5%B1%8F%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/08/23/iOS/iOS如何使屏幕一直保持亮屏？/</id>
    <published>2017-08-23T08:05:00.000Z</published>
    <updated>2017-10-31T09:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>播放视频页面</p><p>加入一行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UIApplicationsharedApplication]setIdleTimerDisabled:YES];</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;播放视频页面&lt;/p&gt;
&lt;p&gt;加入一行代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UIButton点击状态</title>
    <link href="http://yoursite.com/2017/08/23/iOS/UIButton%E7%82%B9%E5%87%BB%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2017/08/23/iOS/UIButton点击状态/</id>
    <published>2017-08-23T08:03:00.000Z</published>
    <updated>2017-10-31T09:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>类似问题 <a href="http://www.cocoachina.com/bbs/read.php?tid-254503-page-1.html" target="_blank" rel="external">http://www.cocoachina.com/bbs/read.php?tid-254503-page-1.html</a></p><p>需求:在UIControlStateNormal 和selected 两种状态下文字颜色分别为白色和红色<br>每次点击的时候把这个按钮的isSelected设为yes 或no<br>当我当前选中的按钮为buttonA时，再点击这个按钮buttonA，<br>按钮的颜色会在点击的时候变回白色，松开鼠标又变回了红色</p><p>找到解决方法了,在这个地方<a href="http://commandshift.co.uk/blog/2013/04/16/uibutton-control-states/" target="_blank" rel="external">http://commandshift.co.uk/blog/2013/04/16/uibutton-control-states/</a></p><p>原来UIControlStateSelected ｜ UIControlStateHighlighted 和 UIControlStateSelected 是两种不同的状态, 在isSelected状态时再点击按钮就变成了UIControlStateSelected ｜ UIControlStateHighlighted的状态.我前面一直自顾自以为前面的状态包含了后面这种状态,都没想到把两个方法放在一起试.总结一下方法就是,设置成在这两种情况下的颜色都为红色,问题解决. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[self.button setBackgroundImage:normal forState:UIControlStateNormal];</div><div class="line">[self.button setBackgroundImage:highlighted forState:UIControlStateHighlighted];</div><div class="line">[self.button setBackgroundImage:selected forState:UIControlStateSelected];</div><div class="line">[self.button setBackgroundImage:selectedHighlighted forState:UIControlStateSelected | UIControlStateHighlighted];</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类似问题 &lt;a href=&quot;http://www.cocoachina.com/bbs/read.php?tid-254503-page-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cocoachina.com/bbs
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS在控制器中监听是否点击Home键以及重新进入界面的方法</title>
    <link href="http://yoursite.com/2017/07/31/iOS/iOS%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E7%9B%91%E5%90%AC%E6%98%AF%E5%90%A6%E7%82%B9%E5%87%BBHome%E9%94%AE%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%96%B0%E8%BF%9B%E5%85%A5%E7%95%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/07/31/iOS/iOS在控制器中监听是否点击Home键以及重新进入界面的方法/</id>
    <published>2017-07-31T02:18:00.000Z</published>
    <updated>2017-10-31T09:36:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一步:<br>创建2个NSNotificationCenter监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillResignActive:)</div><div class="line">name:UIApplicationWillResignActiveNotification object:nil]; //监听是否触发home键挂起程序.</div><div class="line">    </div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationDidBecomeActive:)</div><div class="line">name:UIApplicationDidBecomeActiveNotification object:nil]; //监听是否重新进入程序程序.</div></pre></td></tr></table></figure></p><p>第二步:<br>实现2个NSNotificationCenter所触发的事件方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)applicationWillResignActive:(NSNotification *)notification</div><div class="line"></div><div class="line">&#123;</div><div class="line">    printf(&quot;按理说是触发home按下\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidBecomeActive:(NSNotification *)notification</div><div class="line">&#123;</div><div class="line">    printf(&quot;按理说是重新进来后响应\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注: 在home键触发后,AppDelegate响应的方法为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    /*</div><div class="line">     Use this method to release shared resources, save user data, invalidate timers, </div><div class="line"></div><div class="line">     and store enough application state information to restore your application to its current state in case it is terminated later.</div><div class="line">     If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</div><div class="line">     */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一步:&lt;br&gt;创建2个NSNotificationCenter监听&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div cl
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS获取Label高度的几种方法与对比</title>
    <link href="http://yoursite.com/2017/07/31/iOS/iOS%E8%8E%B7%E5%8F%96Label%E9%AB%98%E5%BA%A6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2017/07/31/iOS/iOS获取Label高度的几种方法与对比/</id>
    <published>2017-07-31T02:18:00.000Z</published>
    <updated>2017-10-31T09:46:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在设置 UILabel 的 Frame 高度时，不能简单的设置为字体的 font size。否则会将字体的一部分裁剪掉。因为 UILabel 在不同的字体设置下，对 Frame 的高度要求也不一样，大多数情况下都比Font的高度设置要高一些。</p><h4 id="一、sizeThatFits"><a href="#一、sizeThatFits" class="headerlink" title="一、sizeThatFits"></a>一、sizeThatFits</h4><p>使用 view 的 sizeThatFits 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// return &apos;best&apos; size to fit given size. does not actually resize view. Default is return existing view size</div><div class="line">- (CGSize)sizeThatFits:(CGSize)size;</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UILabel *testLabel = [[UILabel alloc] init];</div><div class="line">testLabel.font = [UIFont systemFontOfSize:30];</div><div class="line">testLabel.text = @&quot;Today is a fine day&quot;;</div><div class="line">CGSize size = [testLabel sizeThatFits:CGSizeMake(200, 30)];</div><div class="line">NSLog(@&quot;size = %@&quot;, NSStringFromCGSize(size));</div></pre></td></tr></table></figure><p>输出: <strong>size = {246.33333333333334, 36}</strong></p><h4 id="二、sizeToFit"><a href="#二、sizeToFit" class="headerlink" title="二、sizeToFit"></a>二、sizeToFit</h4><p>使用 view 的 sizeToFit 方法。</p><p>注意：sizeToFit 会改变 view 原来的 bounds，而 sizeThatFits 不会。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// calls sizeThatFits: with current view bounds and changes bounds size.</div><div class="line">- (void)sizeToFit;</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UILabel *testLabel = [[UILabel alloc] init];</div><div class="line">testLabel.font = [UIFont systemFontOfSize:30];</div><div class="line">testLabel.text = @&quot;Today is a fine day&quot;;</div><div class="line">[testLabel sizeToFit];</div><div class="line">NSLog(@&quot;size = %@&quot;, NSStringFromCGSize(testLabel.frame.size));</div></pre></td></tr></table></figure><p>输出：<strong>size = {246.33333333333334, 36}</strong></p><h4 id="三、sizeWithAttributes"><a href="#三、sizeWithAttributes" class="headerlink" title="三、sizeWithAttributes"></a>三、sizeWithAttributes</h4><p>使用 NSString 的 sizeWithAttributes 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (CGSize)sizeWithAttributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attrs NS_AVAILABLE(10_0, 7_0);</div></pre></td></tr></table></figure><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *text = @&quot;Today is a fine day&quot;;</div><div class="line">UIFont *font = [UIFont systemFontOfSize:30];</div><div class="line">CGSize size = [text sizeWithAttributes:@&#123;</div><div class="line">           NSFontAttributeName : font</div><div class="line">           &#125;];</div><div class="line">NSLog(@&quot;size = %@&quot;, NSStringFromCGSize(size));</div></pre></td></tr></table></figure><p>输出：<strong>size = {246.3134765625, 35.80078125}</strong></p><h4 id="四、boundingRectWithSize"><a href="#四、boundingRectWithSize" class="headerlink" title="四、boundingRectWithSize"></a>四、boundingRectWithSize</h4><p>使用 NSString 的 boundingRectWithSize 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (CGRect)boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attributes context:(nullable NSStringDrawingContext *)context NS_AVAILABLE(10_11, 7_0);</div></pre></td></tr></table></figure><p>参数的意义：<br>1、size<br>限制最大宽高, 虽然是自适应，但是需要限制最大的宽度和高度。<br>2、options<br>类型为 NSStringDrawingOptions，用来指明绘制字符串时的渲染选项。<br>各个选项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSInteger, NSStringDrawingOptions) &#123;</div><div class="line"> // The specified origin is the line fragment origin, not the base line origin</div><div class="line"> // 整个文本将以每行组成的矩形为单位计算整个文本的尺寸</div><div class="line"> NSStringDrawingUsesLineFragmentOrigin = 1 &lt;&lt; 0, </div><div class="line"> </div><div class="line"> // Uses the font leading for calculating line heights</div><div class="line"> // 使用字体的行间距来计算文本占用的范围，即每一行的底部到下一行的底部的距离计算</div><div class="line"> NSStringDrawingUsesFontLeading = 1 &lt;&lt; 1, </div><div class="line"> </div><div class="line"> // Uses image glyph bounds instead of typographic bounds</div><div class="line"> // 将文字以图像符号计算文本占用范围，而不是排版的边界</div><div class="line"> NSStringDrawingUsesDeviceMetrics = 1 &lt;&lt; 3,</div><div class="line"> </div><div class="line"> // Truncates and adds the ellipsis character to the last visible line if the text doesn&apos;t fit into the bounds specified.</div><div class="line"> // Ignored if NSStringDrawingUsesLineFragmentOrigin is not also set.</div><div class="line"> // 如果文本内容超出指定的矩形限制，文本将被截去并在最后一个字符后加上省略号。</div><div class="line"> // 如果 NSStringDrawingUsesLineFragmentOrigin 没有设置，则该选项不生效</div><div class="line"> NSStringDrawingTruncatesLastVisibleLine NS_ENUM_AVAILABLE(10_5, 6_0) = 1 &lt;&lt; 5, </div><div class="line">&#125; NS_ENUM_AVAILABLE(10_0, 6_0);</div></pre></td></tr></table></figure><p>3、attributes<br>应用于字符串的文本属性。</p><p>4、context<br>NSStringDrawingContext 类型，控制调整字间距和缩放的比例，用于文本绘制时使用。该参数传入 nil 即可。</p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSString *text = @&quot;Today is a fine day&quot;;</div><div class="line">UIFont *font = [UIFont systemFontOfSize:30];</div><div class="line">CGRect suggestedRect = [text boundingRectWithSize:CGSizeMake(800, MAXFLOAT)</div><div class="line">            options:NSStringDrawingUsesFontLeading</div><div class="line">           attributes:@&#123; NSFontAttributeName : font &#125;</div><div class="line">            context:nil];</div><div class="line">NSLog(@&quot;size = %@&quot;, NSStringFromCGSize(suggestedRect.size));</div></pre></td></tr></table></figure><p>输出： <strong>size = {200, 35.80078125}</strong></p><h4 id="四种方式对比"><a href="#四种方式对比" class="headerlink" title="四种方式对比:"></a>四种方式对比:</h4><p>在设置字体为 30 的情况下，前两种使用 view 的方法返回 <strong>size = {246.33333333333334, 36}</strong> ，后两种使用 NSString 的方法返回 <strong>size = {246.3134765625, 35.80078125}</strong> 。使用 view 方法比使用  NSString 方法的返回的值略大。<br>我猜测其原因都是因为，文本渲染引擎在渲染一行文本的时候都需要在label的顶部和底部预留一小部分空间，应该是出于排版美观方面的考量。<br>在显示不同的 font size 的字体时，获得的字符串高度比 font size 大的值是不同的。<br>比如 font size 为 13 时，算出高度为 16，font size 为 20 时，算出高度为 24。<br>所以平常设置 UILabel 高度的时候，也不能简单的在 font height 基础之上加随意值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;在设置 UILabel 的 Frame 高度时，不能简单的设置为字体的 font size。否则会将字体的一部分裁剪掉。因为 UILabel
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS崩溃解决记录</title>
    <link href="http://yoursite.com/2017/07/31/iOS/iOS%E5%B4%A9%E6%BA%83%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2017/07/31/iOS/iOS崩溃解决记录/</id>
    <published>2017-07-31T01:30:00.000Z</published>
    <updated>2017-10-31T09:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Terminating-app-due-to-uncaught-exception-‘CALayerInvalidGeometry’-reason-‘CALayer-position-contains-NaN-nan-40"><a href="#Terminating-app-due-to-uncaught-exception-‘CALayerInvalidGeometry’-reason-‘CALayer-position-contains-NaN-nan-40" class="headerlink" title="Terminating app due to uncaught exception ‘CALayerInvalidGeometry’, reason: ‘CALayer position contains NaN: [nan 40]"></a>Terminating app due to uncaught exception ‘CALayerInvalidGeometry’, reason: ‘CALayer position contains NaN: [nan 40]</h4><p>栈信息打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">2015-10-20 10:01:12.871 Putaoji[49129:1691777] *** Terminating app due to uncaught exception &apos;CALayerInvalidGeometry&apos;, reason: &apos;CALayer position contains NaN: [nan 40]&apos;</div><div class="line">*** First throw call stack:</div><div class="line">(</div><div class="line">    0   CoreFoundation                      0x000000010df49f65 __exceptionPreprocess + 165</div><div class="line">    1   libobjc.A.dylib                     0x000000010d244deb objc_exception_throw + 48</div><div class="line">    2   CoreFoundation                      0x000000010df49e9d +[NSException raise:format:] + 205</div><div class="line">    3   QuartzCore                          0x000000010cc2f7e6 _ZN2CA5Layer12set_positionERKNS_4Vec2IdEEb + 152</div><div class="line">    4   QuartzCore                          0x000000010cc2f959 -[CALayer setPosition:] + 44</div><div class="line">    5   QuartzCore                          0x000000010cc2ffbd -[CALayer setFrame:] + 650</div><div class="line">    6   UIKit                               0x000000010e9673f7 -[UIView(Geometry) setFrame:] + 356</div><div class="line">    7   UIKit                               0x000000010ec50422 -[UIButton _setFrame:deferLayout:] + 125</div><div class="line">    8   UIKit                               0x000000010ec50522 -[UIButton setFrame:] + 178</div><div class="line">    9   Putaoji                             0x000000010ae41132 -[PTJInviteFriendsViewController createShareButtonWithFrame:atIndex:title:imageName:] + 690</div><div class="line">    10  Putaoji                             0x000000010ae4004b -[PTJInviteFriendsViewController setupUI] + 2715</div><div class="line">    11  Putaoji                             0x000000010ae3f5a4 -[PTJInviteFriendsViewController viewDidLoad] + 228</div><div class="line">    12  UIKit                               0x000000010ea59931 -[UIViewController loadViewIfRequired] + 1344</div><div class="line">    13  UIKit                               0x000000010ea5f923 -[UIViewController __viewWillAppear:] + 120</div><div class="line">    14  UIKit                               0x000000010ea8f18a -[UINavigationController _startCustomTransition:] + 1177</div><div class="line">    15  UIKit                               0x000000010ea9e7c7 -[UINavigationController _startDeferredTransitionIfNeeded:] + 712</div><div class="line">    16  UIKit                               0x000000010ea9f67d -[UINavigationController __viewWillLayoutSubviews] + 57</div><div class="line">    17  UIKit                               0x000000010ec3763d -[UILayoutContainerView layoutSubviews] + 248</div><div class="line">    18  UIKit                               0x000000010e97f11c -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 710</div><div class="line">    19  QuartzCore                          0x000000010cc3836a -[CALayer layoutSublayers] + 146</div><div class="line">    20  QuartzCore                          0x000000010cc2cbd0 _ZN2CA5Layer16layout_if_neededEPNS_11TransactionE + 366</div><div class="line">    21  QuartzCore                          0x000000010cc2ca4e _ZN2CA5Layer28layout_and_display_if_neededEPNS_11TransactionE + 24</div><div class="line">    22  QuartzCore                          0x000000010cc211d5 _ZN2CA7Context18commit_transactionEPNS_11TransactionE + 277</div><div class="line">    23  QuartzCore                          0x000000010cc4e9f0 _ZN2CA11Transaction6commitEv + 508</div><div class="line">    24  UIKit                               0x000000010e8f853a _afterCACommitHandler + 174</div><div class="line">    25  CoreFoundation                      0x000000010de759d7 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23</div><div class="line">    26  CoreFoundation                      0x000000010de75947 __CFRunLoopDoObservers + 391</div><div class="line">    27  CoreFoundation                      0x000000010de6b59b __CFRunLoopRun + 1147</div><div class="line">    28  CoreFoundation                      0x000000010de6ae98 CFRunLoopRunSpecific + 488</div><div class="line">    29  GraphicsServices                    0x0000000112b04ad2 GSEventRunModal + 161</div><div class="line">    30  UIKit                               0x000000010e8ce676 UIApplicationMain + 171</div><div class="line">    31  Putaoji                             0x000000010af306ff main + 111</div><div class="line">    32  libdyld.dylib                       0x000000010fe9d92d start + 1</div><div class="line">)</div><div class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</div><div class="line">(lldb)</div></pre></td></tr></table></figure><p><a href="http://www.jianshu.com/p/456f96564567" target="_blank" rel="external">解决方法：</a><br>意思是说程序崩溃是CALayer的位置中含有不存在的数,说白了就是你的View.frame 中计算的时候，有的地方除以0了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Terminating-app-due-to-uncaught-exception-‘CALayerInvalidGeometry’-reason-‘CALayer-position-contains-NaN-nan-40&quot;&gt;&lt;a href=&quot;#Terminati
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础语法</title>
    <link href="http://yoursite.com/2017/06/27/iOS/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2017/06/27/iOS/Swift基础语法/</id>
    <published>2017-06-27T14:08:00.000Z</published>
    <updated>2017-11-01T04:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>特点<br>（1）优于OC，快速，安全<br>（2）取消了预编译指令包括宏定义（OC用的太多了）<br>（3）取消了OC指针和不安全访问的使用（看不到星星了）<br>（4）舍弃 Objective-C 早期应用 Smalltalk 的语法，全面改为点语法<br>（5）3.0中对Foundation框架做了很多改变，去除了NS，将绝大部分class转换成struct结构体（为了考虑性能和安全性，绝大部分使用结构体来代替以前的类，但是在实际使用感觉不到）<br>（6）可以使用现有的 Cocoa 和 Cocoa Touch 框架<br>, 以前是OC调UIKit，现在就是Swift调UIKit，这点事没问题的<br>（7）Swift因为语法的严谨性可以让很多错误提前遇到，这样很少出现bug让程序停在main导致无法找到<br>（8）@UIApplicationMain是程序的入口<br>（9）只有.h没有.m<br>（10）所有的代码都包括在{}里，默认方法func都有缩进！<br>（11）语法的allocinit替换成（）</p></li><li><p>PlayGround<br>（1）可以看苹果官方自带的tips和100个tips，都在Placground来使用</p></li><li><p>基础点<br>（1）不适用self. 在闭包或者编译器提示的时候再使用<br>（2）分号是用来分割语句的，如果一行洗很多，就可以加分号，一般时候可以不加<br>（3）#function打印执行的函数<br>（4）添加标记用到// MARK: - 选择，如果是接下来要做的可以用// TODO：和// FIXME：这些非常有用</p></li></ul><h3 id="一、常量和变量"><a href="#一、常量和变量" class="headerlink" title="一、常量和变量"></a>一、常量和变量</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>let 定义常量，一经赋值不允许再修改</li><li><p>var 定义变量，赋值之后仍然可以修改<br>常量和变量的细节</p><ul><li>使用 : 类型，仅仅只定义类型</li><li>常量有一次设置的机会</li><li>应该尽量先选择常量，只有在必须修改时，才需要修改为 var</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 定义常量并且直接设置数值</div><div class="line">let x: Int = 10</div><div class="line">// 常量数值一经设置，不能修改，以下代码会报错</div><div class="line">// x = 30</div><div class="line"></div><div class="line">let y: Int</div><div class="line">// 常量有一次设置的机会，以下代码没有问题，因为 `y` 还没有被设置数值</div><div class="line">y = 10</div><div class="line"></div><div class="line">// 一旦设置之后，则不能再次修改，以下代码会报错，因为 `y` 已经被设置了数值</div><div class="line">// y = 50</div><div class="line"></div><div class="line">print(x + y)</div><div class="line"></div><div class="line">// 变量设置数值之后，可以继续修改数值</div><div class="line">var z: Int</div><div class="line">z = 100</div><div class="line">z = 200</div><div class="line"></div><div class="line">print(x + y + z)</div></pre></td></tr></table></figure><h4 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h4><p>Swift 能够根据右边的代码，推导出变量的准确类型<br>只有相同类型的值才能够进行运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 整数默认的类型是 Int</div><div class="line">let intValue = 200</div><div class="line">// 小数的默认类型是 Double</div><div class="line">let doubleValue = 10.5</div><div class="line"></div><div class="line">// 如果要对不同类型的数据进行计算，必须要显式的转换</div><div class="line">print(intValue + Int(doubleValue))</div><div class="line">print(Double(intValue) + doubleValue)</div></pre></td></tr></table></figure><p>注意：Swift对类型要求异常严格，任何不同类型的数据不能直接运算（哪怕是Int和Double），不会做一些自动的转换来转换成Double。Swift不存在基本数据类型，Int和Double都是结构体其实，强转用Double(x)完成，或者在定义的时候直接指定变量的类型let x : Double = 10;（很少使用）</p><h3 id="二、控制流"><a href="#二、控制流" class="headerlink" title="二、控制流"></a>二、控制流</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><ul><li>Swift 中没有 C 语言中的非零即真概念</li><li>在逻辑判断时必须显示地指明具体的判断条件 true / false</li><li>if 语句条件的 () 可以省略</li><li>但是 {} 不能省略</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let num = 100</div><div class="line"></div><div class="line">if num &gt; 10 &#123;</div><div class="line">    print(&quot;大 \(num)&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;小 \(num)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="三目"><a href="#三目" class="headerlink" title="三目"></a>三目</h4><ul><li>Swift 中的 三目 运算保持了和 OC 一致的风格</li><li>提示：以下代码，可以按 cmd + shift + y，打开控制台，查看输出结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">num &gt; 10 ? print(&quot;大 \(num)&quot;) : print(&quot;小 \(num)&quot;)</div></pre></td></tr></table></figure><p><strong>或者</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">num &gt; 10 ? print(&quot;大 \(num)&quot;)  : () </div><div class="line">这样就对后面的不作处理。</div><div class="line">() 表示空执行。</div></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><ul><li>switch 不再局限于整数</li><li>switch 可以针对任意数据类型进行判断</li><li>每一个 case 后面必须有可以执行的语句</li><li>不再强制需要 break</li><li>如果没有任何需要执行的语句，可以使用 break<br>要保证处理所有可能的情况，不然编译器直接报错，不处理的条件可以放在 default 分支中</li><li>每一个 case 中定义的变量仅在当前 case 中有效，而 OC 中需要使用 {}</li><li>多值 case 可以使用 , 分隔</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let scoreString = &quot;优&quot;</div><div class="line"></div><div class="line">switch scoreString &#123;</div><div class="line">case &quot;优&quot;:</div><div class="line">    let name = &quot;学生&quot;</div><div class="line">    print(name + &quot;80~100分&quot;)</div><div class="line">case &quot;良&quot;, &quot;中&quot;: print(&quot;60~80分&quot;)</div><div class="line">case &quot;差&quot;: print(&quot;不及格&quot;)</div><div class="line">default: break</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>switch 的条件判断</strong></p><ul><li>switch 中可以使用 where 子句判断条件</li><li>如果只做条件判断，case 部分可以使用 _ 省略</li><li>提示：Swift 中可以使用 _ 忽略任何不关心的内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let score = 90</div><div class="line">switch score &#123;</div><div class="line">case _ where score &gt;= 80: print(&quot;优&quot;)</div><div class="line">case _ where score &gt;= 70: print(&quot;良&quot;)</div><div class="line">case _ where score &gt;= 60: print(&quot;中&quot;)</div><div class="line">default: print(&quot;差&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ul><li>swift取消了i++和++i和传统的for循环</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for i in 0...5 &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">for i in 0..&lt;5 &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>反序遍历</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> for i in (0..&lt;10).reversed() &#123;</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="三、可选项（Optional）"><a href="#三、可选项（Optional）" class="headerlink" title="三、可选项（Optional）"></a>三、可选项（Optional）</h3><h4 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h4><p>（1）定义变量时，如果是可选的，表示可以有值，也可以是nil，用“？”<br>（2）强行解包 “！”，程序员来注意！，并且要少用，可能会崩<br>（3）最常见的错误：解包的时候发现nil。fatal error: unexpectedly found nil while unwrapping an Optional value<br>（4）let可选的话，没有默认值，需要赋值。var可选的话，默认值为nil<br>（5）可选项在参与计算时候必须解包</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>Optional 是 Swift 的一大特色，也是 Swift 初学者最容易困惑的问题</li><li>定义变量时，在类型后面添加一个 ?，表示该变量是可选的</li><li>定义变量时，如果指定是可选的，表示该变量：<ul><li>可以有一个指定类型的值</li><li>也可以是 nil</li></ul></li></ul><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>格式1(自动推导)：var 变量名: Optional = 值</li><li>格式2(泛型)：var 变量名：Optional&lt;类型&gt; = 值</li><li>格式3(简化格式)：var 变量名: 类型? = 值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 格式1</div><div class="line">let x: Optional = 20</div><div class="line">// 格式2</div><div class="line">let y: Optional&lt;Int&gt; = 30</div><div class="line">// 格式3</div><div class="line">let z: Int? = 10</div><div class="line"></div><div class="line">print(x)</div><div class="line">print(y)</div><div class="line">print(z)</div></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><ul><li>变量可选项的默认值是 nil</li><li>常量可选项没有默认值，需要在定义时，或者构造函数中赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var x1: Int?</div><div class="line">print(x1)</div><div class="line"></div><div class="line">let x2: Int?</div><div class="line">// 常量可选项没有默认值，在赋值之前不能使用</div><div class="line">// print(x2)</div><div class="line">x2 = 100</div><div class="line">print(x2)</div></pre></td></tr></table></figure><h4 id="计算和强行解包"><a href="#计算和强行解包" class="headerlink" title="计算和强行解包"></a>计算和强行解包</h4><ul><li>可选值在参与计算前，必须解包 unwarping</li><li>只有解包(unwrap)后才能参与计算</li><li>在可选项后添加一个 !，表示强行解包<ul><li>如果有值，会取值，然后参与后续计算</li><li>如果为 nil，强行解包会导致崩溃</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(x! + y! + z!)</div></pre></td></tr></table></figure><p><strong>程序员要对每一个 ! 负责</strong></p><h4 id="可选解包"><a href="#可选解包" class="headerlink" title="可选解包"></a>可选解包</h4><ul><li>如果只是调用可选项的函数，而不需要参与计算，可以使用可选解包</li><li>在可选项后，使用 ? 然后再调用函数</li><li>使用可选解包可以：<ul><li>如果有值，会取值，然后执行后续函数</li><li>如果为 nil，不会执行任何函数</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var optionValue: Int?</div><div class="line">print(optionValue?.description)</div><div class="line">// 输出 nil</div><div class="line"></div><div class="line">optionValue = 10</div><div class="line">print(optionValue?.description)</div><div class="line">// 输出 Optional(&quot;10&quot;)</div></pre></td></tr></table></figure><p><strong>与强行解包对比，可选解包更安全，但是只能用于函数调用，而不能用于计算</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-9330530a1cac1a06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h3 id="可选项判断"><a href="#可选项判断" class="headerlink" title="可选项判断"></a>可选项判断</h3><h4 id="不强行解包的方法"><a href="#不强行解包的方法" class="headerlink" title="不强行解包的方法"></a>不强行解包的方法</h4><p>由于可选项的值可能为 nil，不允许直接参与运算，因此在实际开发中，经常需要判断可选项是否有值。</p><p>如果单纯使用 if，会让代码嵌套层次很深，不宜阅读和维护，为了解决这一问题，苹果提供了以下三种方式：</p><ul><li>??</li><li>if let / var</li><li>guard let / var</li></ul><h4 id=""><a href="#" class="headerlink" title="??"></a>??</h4><ul><li>?? 运算符可以用于判断可选项是否为 nil，如果是则使用后面的值替代</li></ul><p><strong>注意：?? 的优先级低，在使用时，应该注意使用 ()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let x: Int? = 10</div><div class="line">let y: Int? = 100</div><div class="line"></div><div class="line">print((x ?? 0) + (y ?? 0))</div></pre></td></tr></table></figure><h4 id="if-let-var"><a href="#if-let-var" class="headerlink" title="if let / var"></a>if let / var</h4><ul><li>使用 if let，一旦进入 if 分支，表示可选项一定有值</li><li>常量/变量的作用域仅在 {} 内部</li><li>使用 , 可以判断多个可选项是否有值</li><li>使用同名常量/变量，避免再次起名的烦恼</li><li>如果要在分支逻辑中修改值，可以使用 var，通常使用 let</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let name: String? = &quot;Mike&quot;</div><div class="line">let age: Int? = 18</div><div class="line"></div><div class="line">if let name = name,</div><div class="line">    let age = age &#123;</div><div class="line">    print(&quot;\(name) 今年 \(age) 岁&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;姓名或者年龄为 nil&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="guard-let-var"><a href="#guard-let-var" class="headerlink" title="guard let / var"></a>guard let / var</h4><ul><li>guard 是与 if let 相反的语法，Swift 2.0 推出</li><li>guard 同样可以判断可选项是否有值</li><li>多值判断使用 , 分隔</li><li>如果发现 nil，在 else 分支返回</li><li>分支结束后，所有的 常量/变量 都有值</li><li>相比较 if let，guard 语法的分支结构能节省一层</li><li>如果要在后续逻辑中修改值，可以使用 var，通常使用 let</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func demo(name: String?, age: Int?) &#123;</div><div class="line"></div><div class="line">    guard let name = name,</div><div class="line">        let age = age else &#123;</div><div class="line">            print(&quot;姓名或者年龄为 nil&quot;)</div><div class="line"></div><div class="line">            return</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    print(&quot;\(name) 今年 \(age) 岁&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">demo(name: name, age: age)</div></pre></td></tr></table></figure><h4 id="guard-let和if-let可以用同名变量接收。"><a href="#guard-let和if-let可以用同名变量接收。" class="headerlink" title="guard let和if let可以用同名变量接收。"></a>guard let和if let可以用同名变量接收。</h4><p>因为总会取名字，if let name = name这样就可以，注意后面使用的时候用非空的那个！并且iflet和guardlet可以依次判断，先判断是一个字典，再拿字典的数组，在判断数组的值，可以一条线判断出来。<br><img src="http://upload-images.jianshu.io/upload_images/1868951-75ff2d3c2381330b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h3><p>  用String，是一个结构体，具有绝大多数NSString功能，支持直接遍历</p><p>（1）遍历：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func demo3() &#123;</div><div class="line">    </div><div class="line">    // 字符串遍历（NSString不支持这么遍历）</div><div class="line">    let str = &quot;wowosnshi是&quot;</div><div class="line">    </div><div class="line">    for s in str.characters &#123;</div><div class="line">        print(s)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>（2）长度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 返回指定编码对应的字节数，每个汉字三个字节</div><div class="line">print(str.lengthOfBytes(using: .utf8))</div><div class="line"></div><div class="line">// 返回真正字符串长度</div><div class="line">print(str.characters.count)</div></pre></td></tr></table></figure></p><p>（3）拼接：要注意可选项拼接不解决会带上Optional，剩下的都可以拼接，再也不用看StringWithFormat了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let name = &quot;AA&quot;</div><div class="line"></div><div class="line">let age = 19</div><div class="line"></div><div class="line">let title : String? = &quot;sss&quot;</div><div class="line"></div><div class="line">print(&quot;\(name)\(age)\(title ?? &quot;&quot;)&quot;)</div></pre></td></tr></table></figure></p><p>（4）格式化：</p><ul><li>格式化成日期</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let h = 8 , m = 10, s = 44</div><div class="line"></div><div class="line">// OC中用stringWithFormat格式化日期，Swift中可以</div><div class="line"></div><div class="line">let strDate = String(format: &quot;%02d-%02d-%02d&quot;, h,m,s)</div><div class="line"></div><div class="line">print(strDate)</div></pre></td></tr></table></figure><p>（5）截取字符串：建议用NSStrin作中转，因为swift取串方法一直在改变</p><ul><li>NSString方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let str = &quot;红红火火恍恍惚惚&quot;</div><div class="line"></div><div class="line">let strOC = str as NSString</div><div class="line"></div><div class="line">strOC .substring(to: 1)</div><div class="line"></div><div class="line">strOC.substring(with: NSMakeRange(0, 2))</div></pre></td></tr></table></figure><h3 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h3><p>（1）就是中括号，注意数组的类型，并且基本数据类型不需要包装，可以直接方数组里，如果类型不一样（混合数组，但是基本不用），自动推导[NSObject]。在Swift中还有一个[AnyObject类型]，标示任意对象，因为在Swift中一个类可以没有任何父类。</p><p>（2）遍历：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 遍历1(按照下标遍历)</div><div class="line">for i in 0..&lt;array.count &#123;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 遍历2（遍历元素）</div><div class="line">for s in array &#123;</div><div class="line">    </div><div class="line">         </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 遍历3（同时遍历下标和元素）</div><div class="line">for e in array.enumerated() &#123;</div><div class="line">    </div><div class="line">    // let e: (offset: Int, element: String) e是一个元组        </div><div class="line">    print(&quot;\(e.offset), \(e.element)&quot;)</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 遍历4（同时遍历下标和元素）</div><div class="line">for (n,s) in array.enumerated() &#123;</div><div class="line">    </div><div class="line">    print(&quot;\(n),\(s)&quot;)</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 反序遍历</div><div class="line">for s in array.reversed() &#123;</div><div class="line">    </div><div class="line">            </div><div class="line">&#125;</div><div class="line">    </div><div class="line">// 反序索引下标(这样写才对，先枚举再反序)</div><div class="line">for (n,s) in array.enumerated().reversed() &#123;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>（3）增删改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">array.append(&quot;AA&quot;)</div><div class="line"></div><div class="line">array[1] = &quot;BBB&quot;</div><div class="line"></div><div class="line">array.remove(at: 2)</div></pre></td></tr></table></figure></p><p>（4）合并：用“+”号。但是要合并的数组的两个类型必须一致。</p><h3 id="六、字典"><a href="#六、字典" class="headerlink" title="六、字典"></a>六、字典</h3><p>一般是[String：NSObject]，对应键值对.由于3.0后大部分都是结构体了,AnyObject不好用了，Any范围更大<br>（1）字典数组：<br>（2）增删改：和数组都类似，就是两个字典合并不像数组直接相加，而是需要遍历</p><h3 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h3><p>（1）外部参数，当外部参数用_替代的时候，会在外部调用的时候忽略形参名<br><img src="http://upload-images.jianshu.io/upload_images/1868951-52cd1c900bdb5748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（2）函数的默认值（OC不具备），这个使Swift比OC灵活很多很多，一个方法可以做很多事，因为OC会有各种参数和组合，Swift只需写一个最多的参数，然后不需要的设定默认值就是了</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-d8fe7708a070bb29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（3）无返回值 ：直接省略 （） Void都可以</p><p>（4）闭包：类似Block，比Block还广泛。OC中Block是匿名函数，Swift中函数是特殊的闭包。闭包在整个开发中和Block的应用场景一样。用于控制器/自定义视图/异步执行完成的回调。这些回调的特点就是都是以参数回调处理结果，返回值为Void。</p><ul><li><p>定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   let biBao = &#123; (x: Int) -&gt; Int in</div><div class="line">            </div><div class="line">       return x + 100</div><div class="line">   &#125;</div><div class="line">        </div><div class="line">   print(biBao(10))</div></pre></td></tr></table></figure></li><li><p>GCD：将任务添加到队列，指定执行任务的函数。任务就是Block/闭包，队列以同步/异步的方式执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    func loadData(compeletion:@escaping ( _ result: [String])-&gt;()) -&gt; Void &#123;</div><div class="line">        </div><div class="line">        DispatchQueue.global().async &#123;</div><div class="line">            </div><div class="line">            print(&quot;耗时操作会获得一些结果 \(Thread.current)&quot;)</div><div class="line">            </div><div class="line">            Thread.sleep(forTimeInterval: 1.0)</div><div class="line">            </div><div class="line">            let json = [&quot;天气&quot;,&quot;不错&quot;,&quot;刮大风&quot;]</div><div class="line">            </div><div class="line">            // 主线程回调</div><div class="line">            DispatchQueue.main.async(execute: &#123;</div><div class="line">                </div><div class="line">                print(&quot;主线程更新UI \(Thread.current)&quot;)</div><div class="line">                </div><div class="line">                // 回调 -&gt; 通过参数传递 执行闭包</div><div class="line">                compeletion(json)</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">   </div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul><p>调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">        // 执行的适合我就拿到了值</div><div class="line">        loadData &#123; (result) in</div><div class="line">            </div><div class="line">            print(&quot;获取的新闻数据 \(result)&quot;)</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><ul><li><p>尾随闭包：如果函数的最后一个参数是闭包，那么参数就省略了，最后一个参数直接{}大括号包装</p></li><li><p>闭包的循环引用：</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-ba4dbd3e7430bd1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法1">　　　　　　　　</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-37bff51c1a762d9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法2"></p><p>（5）面向对象（各种构造函数）：（）就是allocInit，在Swift中对应init()。在swift中一个项目所有类都是共享的，可以直接访问，每一个类都默认有一个命名空间。A.name B.name God.name Dog.name。同一个类可以从属于不同的命名空间（假如有一个框架有Person类，做用户，还有一个框架做后台，也用Person。在OC中就只能靠前缀解决，HouTaiPerson，KuangJiaPerson。而Swift中的命名空间就是项目名。AAA项目有一个Person，那么AAA.Person就是AAA的Person类，此时再导入框架，那也是框架的.Person）<br><img src="http://upload-images.jianshu.io/upload_images/1868951-fe35f0c10b0f7e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>在自定义的Nsobjiect类中，has no initalizers 标示没有初始化器，初始化器可以有多个，默认是init。当这个类有属性的时候，属性要分配内存空间，就是说要有初始值。那么其实就是先给自己的属性分配，然后给父初始。其实这么一看，Swift和OC是相反的！</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-440dc9822b651550.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>思路：OC是先调用爸爸。就是Person，Person会再调用NSObject，就是先跑上去什么都不管，先初始化了NSObject，然后才往下走挨个初始化。Swift是把自己完全初始化，再上去初始化爸爸，这么看比OC快了一圈，性能要好。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-32291fce27beef6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>重载构造函数：（重写是父类有这个方法，override。重载是函数名相同，参数和个数不同。init就重写，init+参数就重载。OC是没有重载的！都是initWithXXXXX）。重载其实是最基本的方式，OC没有其实很low，但是Swift有。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0beee0b1eba57574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>注意：如果重载了构造函数并且没有实现父类的init，那么系统不再提供init构造函数了（默认是有的），因为默认的构造函数不能给本类的属性分配空间（你不自己写name = ，系统就没办法分配）</p><ul><li><p>KVC构造函数：只需记住下面4点<br><img src="http://upload-images.jianshu.io/upload_images/1868951-104ce1b663f76f78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>所以一般在模型中加个？ 然后用KVC实现（先调用init因为是运行时机制）</strong></p></li><li><p>模型中属性定义：基本数据类型 = 0，对象设置？<br>运行时中，基本类型设置？    属性设置私有都会让运行时拿不到，此时kvc就会出错。<br><img src="http://upload-images.jianshu.io/upload_images/1868951-0e8c14816279da28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li>如果子类没有重写父类方法，调用的时候就会直接调用父类的方法。当继承一个类，就继承所有属性和方法，包括KVC。当PERSON写好了KVC后，</li><li>整体<br><img src="http://upload-images.jianshu.io/upload_images/1868951-722a51e523596920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（6）便利构造函数：关键字Convenience（开发用的很少，因为模型都是框架转，UI不需要便利）<br>*目的：条件判断，只有满足条件才实例化对象，防止不必要的内存开销，简化对象创建。本身是不负责属性的创建和初始化的。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f0dc301dfbbf6fb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>　　<br>（7）deinit:类似OC的Dealloc<br><img src="http://upload-images.jianshu.io/upload_images/1868951-562bd1efec2cfa04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="八、分类：extension"><a href="#八、分类：extension" class="headerlink" title="八、分类：extension"></a>八、分类：extension</h3><p>便利构造函数 + 分类可以省略抽取很多代码。例如给UITextField/UIButton写分类，然后写便利构造函数，方便。</p><h3 id="九、Swift的类，结构体，枚举三种都有构造函数，都可以有方法，就像OC的类"><a href="#九、Swift的类，结构体，枚举三种都有构造函数，都可以有方法，就像OC的类" class="headerlink" title="九、Swift的类，结构体，枚举三种都有构造函数，都可以有方法，就像OC的类"></a>九、Swift的类，结构体，枚举三种都有构造函数，都可以有方法，就像OC的类</h3><h3 id="十、其它"><a href="#十、其它" class="headerlink" title="十、其它"></a>十、其它</h3><h4 id="懒加载："><a href="#懒加载：" class="headerlink" title="懒加载："></a>懒加载：</h4><p>在OC开发中，懒加载一般自定义控件。在Swift中，懒加载还是需要用的，可以保证控件延迟创建，还能避免处理控件解包。如果直接定义控件var label = UILabel，根据代码从上到下，会让控件在ViewDidLad之前就提前创建了。所以需要懒加载。OC中懒加载就是Get方法，Swift直接lazy var。当然也可以private lazy var来限定作用域。</p><p>（1）简单的懒加载：<br><img src="http://upload-images.jianshu.io/upload_images/1868951-018c8333a67c1f19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（2）完整的懒加载：（）就是函数执行，就是一个特殊的闭包，所以懒加载本质是一个闭包。一般不这么写。<br><img src="http://upload-images.jianshu.io/upload_images/1868951-203b83d0a055460e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>　　<br>（3）OC和Swift区别</p><ul><li>OC：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (UILabel *)label&#123;</div><div class="line">    //如果label等于nil就会创建!</div><div class="line">    if (_label == nil) &#123;</div><div class="line">        _label = [[UILabel alloc]init];</div><div class="line">        _label.text = @&quot;loirou&quot;;</div><div class="line">        [_label sizeToFit];</div><div class="line">        _label.center = self.view.center;</div><div class="line">    &#125;</div><div class="line">    return _label;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>OC是等于nil时候就懒加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[self.view addSubview:self.label];</div><div class="line">//释放label</div><div class="line">_label = nil;</div><div class="line"></div><div class="line">//会再次调用懒加载的代码</div><div class="line">NSLog(@&quot;%@&quot;,self.label);</div></pre></td></tr></table></figure><p>当label设nil的时候就在此调用。在ios6中，didReceiveMemoryWarning是不清理视图的。</p><ul><li>Swift：</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-4754ad62e9252aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>此时释放的时候就会报错。因为定义的时候没有？，就是一定有值得。<br>那么如果定义时候加？ 一旦label = nil，也不会在执行懒加载了！因为懒加载根本没写如果是空就创建。<br>懒加载只会在第一次调用的时候执行闭包。Swift中一定注意不要主动清理视图或控件，因为懒加载不会创建了（例如内存警告别干掉控件，干掉了在也用不成了，因为懒加载就一次）</p><h4 id="计算型属性（只读）："><a href="#计算型属性（只读）：" class="headerlink" title="计算型属性（只读）："></a>计算型属性（只读）：</h4><p>（1）getter/setter（开发不用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    // 开发一般不用，还给搞一个_name。</div><div class="line">    // swift一般不会重写getter和setter</div><div class="line">    private var _name: String? // 假装的一个值</div><div class="line">    var name: String? &#123; get&#123;return _name&#125;  set&#123;_name = newValue&#125;&#125; // get返回成员变量 set记录成员变量</div><div class="line"></div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        </div><div class="line">        demo()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>（2）计算型属性：readOnly只读：OC中重写get。Swift也是重写get，不管set就可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 只读，此时set赋值时候就会报错</div><div class="line"> var name: String? &#123; get&#123;return &quot;ABC&quot;&#125;&#125;</div><div class="line">// 还有一种简写：</div><div class="line"> var name: String? &#123; return &quot;ABC&quot;&#125;</div></pre></td></tr></table></figure><p>看这类属性，是本身不保存内容的，都是通过计算获得结果。就可以当我就是个没有参数只有返回值的函数！！我每次return值给你我的任务就完成了。每次你调用我这个属性的时候，我都会进行一次计算！都会执行我的代码然后return给你。我自身不存储的。</p><p>（3）懒加载和计算型属性的区别：<br><img src="http://upload-images.jianshu.io/upload_images/1868951-3d568e0dedf0e0a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（4）存储型属性：需要开辟空间，存储数据。一般的属性都是存储型属性（懒加载）</p><p>（5）存储和计算都可以？或者不加。看情况是不是必选</p><p>（四）Swift中设置模型数据：<br>Swift做好模型后。别的控件拿到模型后，由视图自己来显示。此时在didSet里写。就是替代OC的Setter方法。（OC的Setter要考虑_成员变量 = 值，而且如果是copy需要.copy，而Swift不需要考虑一切）</p><h4 id="命名空间："><a href="#命名空间：" class="headerlink" title="命名空间："></a>命名空间：</h4><ul><li>在同一个空间（项目），全局共享。用第三方时，如果直接拖拽，那就从属于一个空间，很有可能冲突，所以用Cocopod</li><li>动态获得命名空间（从info.plist加载），命名空间和项目名称有关系。info的Bundle name其实就是命名空间（一般写的很奇怪 #（ProdectNmae））。<br>打印info<br>print(Bundle.main.infoDictionary)<br><img src="http://upload-images.jianshu.io/upload_images/1868951-f0870f71a52c609a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 获取命名空间的值，可选 let str = </div><div class="line">Bundle.main.infoDictionary?[&quot;CFBundleName&quot;] as? String ?? &quot;&quot;                  </div><div class="line">let con = NSClassFromString(str + &quot;.&quot; + &quot;ViewController&quot;) as? UIViewController.Type</div></pre></td></tr></table></figure></p><h4 id="反射机制："><a href="#反射机制：" class="headerlink" title="反射机制："></a>反射机制：</h4><p>对于任何类都可以知道类的所有属性和方法，对于任何对象都可以调用任何属性和方法，这种动态获取的信息和动态调用对象属性方法的功能成java的反射机制（Swift也有了）</p><p>（1）在OC中利用反射机制</p><ul><li>利用<strong>NSClassFromString</strong>方法来使用字符串获取类</li><li>利用<strong>isMemberOfClass</strong>判断是否是某一个类</li><li>利用<strong>isKindOfClass</strong>判断是否是某一个类的子类</li><li>利用<strong>conformsToProtocol</strong>判断对象是否遵守某一个协议</li><li>利用<strong>respondsToSelector</strong>判断是否实现了某一个方法</li><li>利用<strong>performSelector</strong>或者<strong>objc_msgSend</strong>间接调用方法</li></ul><p>（2）在Swift中利用反射机制类似。工作中用的很多很多。<br>场景：AppDelegate（OC中也用过，利用NSClassFromString获得类，然后设置根控制器。但是Swift中多了一个命名空间写法。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123;</div><div class="line">        </div><div class="line">    window = UIWindow(frame: UIScreen.main.bounds)</div><div class="line">    </div><div class="line">    // 依据String名字拿到控制器(添加项目名称，命名空间，不能有数字和特殊符号)</div><div class="line">    // 返回的是AnyClass？ 需要as？强转</div><div class="line">    // 控制器添加Type类型</div><div class="line">    let rootControl = NSClassFromString(&quot;SwiftyDemo.ViewController&quot;) as? UIViewController.Type</div><div class="line">    </div><div class="line">    let vc = rootControl?.init()</div><div class="line">    </div><div class="line">    window?.rootViewController = vc</div><div class="line">    </div><div class="line">    window?.makeKeyAndVisible()</div><div class="line">    </div><div class="line">    return true</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>（3）第三方框架，用了很多反射机制和工厂方法，为了实现大量的解耦和封装，很麻烦。一个方法可能跳10个方法10个控制器才写了一个加法。但是如果涉及高级开发和封装，必须要经过这一步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特点&lt;br&gt;（1）优于OC，快速，安全&lt;br&gt;（2）取消了预编译指令包括宏定义（OC用的太多了）&lt;br&gt;（3）取消了OC指
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ios端app切图命名规范大全</title>
    <link href="http://yoursite.com/2017/06/15/tips/ios%E7%AB%AFapp%E5%88%87%E5%9B%BE%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2017/06/15/tips/ios端app切图命名规范大全/</id>
    <published>2017-06-15T06:37:00.000Z</published>
    <updated>2017-11-01T04:13:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.17xsj.com/shejijiaocheng/uisheji/4590.html" alt="ios端app切图命名规范大全"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://www.17xsj.com/shejijiaocheng/uisheji/4590.html&quot; alt=&quot;ios端app切图命名规范大全&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="tips" scheme="http://yoursite.com/categories/tips/"/>
    
    
      <category term="tips" scheme="http://yoursite.com/tags/tips/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>layer介绍</title>
    <link href="http://yoursite.com/2017/06/13/iOS/layer%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2017/06/13/iOS/layer介绍/</id>
    <published>2017-06-13T07:23:00.000Z</published>
    <updated>2017-10-31T09:51:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、CAEmitterLayer"><a href="#一、CAEmitterLayer" class="headerlink" title="一、CAEmitterLayer"></a>一、CAEmitterLayer</h4><p>CAEmitterLayer用来实现基于Core Animation的粒子发生器系统。每个粒子都是一个CAEmitterCell的实例。粒子绘制在背景色与border之上。</p><p>在属性中，可以指定Layer中的CAEmitterCell数组，每个cell定义了自己的一组属性，如速度、粒子发生率、旋转、缩放或者内容等。每个粒子也都有一个emitterCells属性，可以做为一个粒子发生器来运作。Layer还可以设置发生器位置、发生器形状、发射单元的位置等等。<br>下面是一段例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">self.view.backgroundColor = [UIColor colorWithRed:12/255.0f green:105/255.0f blue:244/255.0f alpha:1.0];</div><div class="line"></div><div class="line">//在实际应用中，我们一般会将其放到可视视图之外的地方，以便更好的模拟效果，不过这里为了测试属性，将其放在可视范围内</div><div class="line">CGRect rect = CGRectMake(0, 100, self.view.bounds.size.width, 50);</div><div class="line">//创建发射器</div><div class="line">CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];</div><div class="line">emitterLayer.frame = rect;</div><div class="line">[self.view.layer addSublayer:emitterLayer];</div><div class="line"></div><div class="line">//设置发射器类型</div><div class="line">emitterLayer.emitterShape = kCAEmitterLayerCuboid;</div><div class="line">emitterLayer.emitterPosition = CGPointMake(rect.size.width*0.5, rect.size.height*0.5);</div><div class="line">emitterLayer.emitterSize = rect.size;</div><div class="line"></div><div class="line">CAEmitterCell *emitterCell = [CAEmitterCell emitterCell];</div><div class="line">//设置粒子展现内容</div><div class="line">emitterCell.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;paopao&quot;].CGImage);</div><div class="line"></div><div class="line">//设置粒子创建速率，也就是每秒产生的个数</div><div class="line">emitterCell.birthRate = 100;</div><div class="line">//设置粒子的生命周期，也就是在屏幕上存在的时间</div><div class="line">emitterCell.lifetime = 3.5;</div><div class="line">//设置粒子声明周期范围</div><div class="line">emitterCell.lifetimeRange = 1.0;</div><div class="line">//设置y轴上的加速度</div><div class="line">emitterCell.yAcceleration = 70.0f;</div><div class="line">//设置x轴上的加速度</div><div class="line">emitterCell.xAcceleration = 10.0f;</div><div class="line">//设置粒子的初始速度</div><div class="line">emitterCell.velocity = 20;</div><div class="line">//设置粒子的初始角度 如果不设置这个值，我们发现粒子都是水平发射的</div><div class="line">emitterCell.emissionLongitude = -M_PI_2;</div><div class="line">//设置粒子的初始速度范围 在此例子中范围是 -180~220</div><div class="line">emitterCell.velocityRange = 200.0f;</div><div class="line">//设置粒子的初始角度范围 此例子的范围为 M_PI~0</div><div class="line">emitterCell.emissionRange = M_PI_2;</div><div class="line">//设置粒子的颜色</div><div class="line">//    emitterCell.color = [UIColor colorWithRed:0.9 green:1.0 blue:1.0 alpha:1.0].CGColor;</div><div class="line">//    //我们也可以设置随机颜色，并且限定范围。因为RGB的值最大为1.0,那Red来说，范围并不会变为0.6~1.3,而是0.6~1.0。相似的，如果是负值，则最小为0</div><div class="line">//    emitterCell.redRange = 0.3;</div><div class="line">//    emitterCell.greenRange = 0.3;</div><div class="line">//    emitterCell.blueRange = 0.3;</div><div class="line">//设置粒子的大小及其大小范围</div><div class="line">emitterCell.scale = 0.8;</div><div class="line">emitterCell.scaleRange = 0.8;</div><div class="line"></div><div class="line">//设置让粒子随着时间推移每秒减小15%,如果设置为正值则每秒增加</div><div class="line">emitterCell.scaleSpeed = -0.15;</div><div class="line"></div><div class="line">//设置粒子透明度的变化范围</div><div class="line">emitterCell.alphaRange = 0.75;</div><div class="line">//设置粒子变化速度</div><div class="line">emitterCell.alphaSpeed = -0.15;</div><div class="line">//将粒子赋给发射器</div><div class="line">emitterLayer.emitterCells = @[emitterCell];</div></pre></td></tr></table></figure></p><p>CAEmitterLayer通过emitterPosition指定了emitter的位置，在view的中间偏下的地方，并且形状为默认的一个点。renderMode定义了粒子的渲染方式，在这里让所有的粒子出现叠加增强的效果。birthRate让粒子每秒产生四个。</p><p>CAEmitterCell指定contents来定义了粒子的内容，emissionLongitude和emissionLatitude指定了经纬度，经度角代表了x-y轴平面上与x轴之间的夹角，纬度角代表了x-z轴平面上与x轴之间的夹角。emissionRange设置了一个范围，围绕着y轴负方向，建立了一个圆锥形，粒子从这个圆锥形的范围内打出。lifetime设置了粒子的存活时长，在1.6秒之后，粒子消失。birthRate定义每秒生成100个，与CAEmitterLayer的birtuRate相乘，即最终的粒子数量400个每秒。velcity指定了初速度，velcityRange设置初速度在300到500之间浮动，yAcceleration指定了沿y轴250的加速度，用于给粒子减速。color设置了粒子的颜色，并设置了每个色值的浮动范围，用于生成所有颜色的烟火。最后设置了名称，以后可以再次引用它。效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-a8f4e0d959ca1a3d.gif?imageMogr2/auto-orient/strip" alt="CAEmitterLayer.gif"></p><h4 id="二、CAGradientLayer"><a href="#二、CAGradientLayer" class="headerlink" title="二、CAGradientLayer"></a>二、CAGradientLayer</h4><p>CAGradientLayer用来绘制渐变色，指定几个颜色值、渐变结束位置，就能在layer中绘制出渐变效果。下面是一段例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">CAGradientLayer *layer = [CAGradientLayer layer];</div><div class="line">CGRect frame = self.view.frame;</div><div class="line">frame.origin = CGPointMake(0, 0);</div><div class="line">layer.frame = frame;</div><div class="line">layer.opacity = 0.5;</div><div class="line">layer.colors = @[(id)[UIColor redColor].CGColor,(id)[UIColor greenColor].CGColor,(id)[UIColor blueColor].CGColor];</div><div class="line">layer.locations = @[@0.2,@0.5,@0.8];</div><div class="line">layer.startPoint = CGPointMake(0, 0);</div><div class="line">layer.endPoint = CGPointMake(1, 1);</div><div class="line">[self.view.layer addSublayer:layer];</div></pre></td></tr></table></figure></p><p>例子中的layer是直接加载self.view.layer上的，位于emitterLayer上面,设置为半透明，在渐变色下显示出图片内容。colors指定渐变色选取红色、绿色和蓝色三色。locations设置了红色与绿色的渐变区域在20%与50%之间，小于20%的位置为红色，50%位置为绿色，绿色与蓝色的渐变区域在50%与80%之间，大于80%的位置为蓝色。startPoint设置为左上角，endPoint设置为右下角，颜色从左上角逐渐变到右下角。效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1cce0422d9fb3c5d.gif?imageMogr2/auto-orient/strip" alt="CAGradientLayer.gif"></p><h4 id="三、CAReplicatorLayer"><a href="#三、CAReplicatorLayer" class="headerlink" title="三、CAReplicatorLayer"></a>三、CAReplicatorLayer</h4><p>CAReplicatorLayer创建layer和它的sublayer的多个副本，副本可以设置transform来变形，或者设置颜色、透明度的变化。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//  背景 layer</div><div class="line">   CAReplicatorLayer * repLayer = [CAReplicatorLayer layer];</div><div class="line">   repLayer.frame = self.view.frame;</div><div class="line">   repLayer.backgroundColor = [UIColor clearColor].CGColor;</div><div class="line">   [self.view.layer addSublayer:repLayer];</div><div class="line">   </div><div class="line">   //  1、单个原点： 原始层</div><div class="line">   CALayer * dotLayer = [CALayer layer];</div><div class="line">   dotLayer.frame = CGRectMake(0, 0, 10, 10);</div><div class="line">   dotLayer.position = CGPointMake(59, 61);</div><div class="line">   dotLayer.cornerRadius = 5;</div><div class="line">   dotLayer.borderWidth = 1;</div><div class="line">   dotLayer.backgroundColor = [UIColor colorWithWhite:0.8 alpha:1].CGColor;</div><div class="line">   dotLayer.borderColor = [UIColor colorWithWhite:1.0 alpha:1].CGColor;</div><div class="line">   //  Rasterize 光栅栏 效果</div><div class="line">   dotLayer.shouldRasterize = YES;</div><div class="line">   //  加在 replicator layer 上的 layer 可以复制</div><div class="line">   [repLayer addSublayer:dotLayer];</div><div class="line">   </div><div class="line">   //  2、只是为一个点添加了动画</div><div class="line">   CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">   //  设置动画的路径 为 设置好的 贝塞尔曲线</div><div class="line">   animation.path = [self creatBezierPath];</div><div class="line">   animation.repeatCount = INFINITY;</div><div class="line">   animation.duration = 4;</div><div class="line">   [dotLayer addAnimation:animation forKey:nil];</div><div class="line">   </div><div class="line">   //  3、设置延时,拷贝数量</div><div class="line">   repLayer.instanceDelay = 0.1;</div><div class="line">   repLayer.instanceCount = 20;</div><div class="line">   </div><div class="line">   //  4、改变颜色、设置颜色的 偏移</div><div class="line">   repLayer.instanceColor = [UIColor greenColor].CGColor;</div><div class="line">   //repLayer.instanceGreenOffset = -0.03;</div></pre></td></tr></table></figure></p><p> 利用 pinterCode 软件 计算的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (CGPathRef)creatBezierPath &#123;</div><div class="line">    </div><div class="line">    UIBezierPath* bezierPath = UIBezierPath.bezierPath;</div><div class="line">    [bezierPath moveToPoint: CGPointMake(59, 61)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(65.21, 66.9)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(73.69, 65.77)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(75.25, 74.19)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(82.78, 78.27)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(79.09, 86)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(82.78, 93.73)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(75.25, 97.81)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(73.69, 106.23)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(65.21, 105.1)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(59, 111)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(52.79, 105.1)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(44.31, 106.23)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(42.75, 97.81)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(35.22, 93.73)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(38.91, 86)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(35.22, 78.27)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(42.75, 74.19)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(44.31, 65.77)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(52.79, 66.9)];</div><div class="line">    [bezierPath closePath];</div><div class="line">    </div><div class="line">    //  放大</div><div class="line">    CGAffineTransform scale = CGAffineTransformMakeScale(3, 3);</div><div class="line">    //  生成 CGPath 拷贝 （副本）</div><div class="line">    CGPathRef pathRef = CGPathCreateCopyByTransformingPath(bezierPath.CGPath, &amp;scale);</div><div class="line">    return pathRef;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/1868951-aa4040e681864ed8.gif?imageMogr2/auto-orient/strip" alt="CAReplicatorLayer.gif"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、CAEmitterLayer&quot;&gt;&lt;a href=&quot;#一、CAEmitterLayer&quot; class=&quot;headerlink&quot; title=&quot;一、CAEmitterLayer&quot;&gt;&lt;/a&gt;一、CAEmitterLayer&lt;/h4&gt;&lt;p&gt;CAEmitterLayer
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="动画与绘图" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>PHP案例-信息管理系统</title>
    <link href="http://yoursite.com/2017/05/24/Web/PHP%E6%A1%88%E4%BE%8B-%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/05/24/Web/PHP案例-信息管理系统/</id>
    <published>2017-05-24T03:40:00.000Z</published>
    <updated>2017-11-01T04:05:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>– Database: <code>test</code></p><p>– 表的结构 <code>message</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `message` (</div><div class="line">  `id` tinyint(1) NOT NULL PRIMARY KEY AUTO_INCREMENT,</div><div class="line">  `name` varchar(25) NOT NULL,</div><div class="line">  `sex` varchar(50) NOT NULL,</div><div class="line">  `age` tinyint(1) NOT NULL,</div><div class="line">  `classid` tinyint(1) NOT NULL</div><div class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure><h4 id="index-php"><a href="#index-php" class="headerlink" title="index.php"></a>index.php</h4><p><img src="http://upload-images.jianshu.io/upload_images/1868951-37a23780f6c00006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首页"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;学生信息管理&lt;/title&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        function doDel(id) &#123;</div><div class="line">            if (confirm(&quot;确定要删除么？&quot;)) &#123;</div><div class="line">                window.location = &apos;action.php?action=del&amp;id=&apos; + id;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;center&gt;</div><div class="line">    &lt;?php</div><div class="line">    include_once &quot;menu.php&quot;;</div><div class="line">    ?&gt;</div><div class="line">    &lt;h3&gt;浏览学生信息&lt;/h3&gt;</div><div class="line">    &lt;table width=&quot;600&quot; border=&quot;1&quot;&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;th&gt;ID&lt;/th&gt;</div><div class="line">            &lt;th&gt;姓名&lt;/th&gt;</div><div class="line">            &lt;th&gt;性别&lt;/th&gt;</div><div class="line">            &lt;th&gt;年龄&lt;/th&gt;</div><div class="line">            &lt;th&gt;班级&lt;/th&gt;</div><div class="line">            &lt;th&gt;操作&lt;/th&gt;</div><div class="line">        &lt;/tr&gt;</div><div class="line">        &lt;?php</div><div class="line">        //1.连接数据库</div><div class="line">        try &#123;</div><div class="line">            $pdo = new PDO(&quot;mysql:host=localhost;dbname=test;&quot;, &quot;root&quot;, &quot;&quot;);</div><div class="line">        &#125; catch (PDOException $e) &#123;</div><div class="line">            die(&quot;数据库连接失败&quot; . $e-&gt;getMessage());</div><div class="line">        &#125;</div><div class="line">        //2.解决中文乱码问题</div><div class="line">        $pdo-&gt;query(&quot;SET NAMES &apos;UTF8&apos;&quot;);</div><div class="line">        //3.执行sql语句，并实现解析和遍历</div><div class="line">        $sql = &quot;SELECT * FROM message &quot;;</div><div class="line">        foreach ($pdo-&gt;query($sql) as $row) &#123;</div><div class="line">            echo &quot;&lt;tr&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;id&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;name&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;sex&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;age&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;classid&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;</div><div class="line">                    &lt;a href=&apos;javascript:doDel(&#123;$row[&apos;id&apos;]&#125;)&apos;&gt;删除&lt;/a&gt;</div><div class="line">                    &lt;a href=&apos;edit.php?id=(&#123;$row[&apos;id&apos;]&#125;)&apos;&gt;修改&lt;/a&gt;</div><div class="line">                  &lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;/tr&gt;&quot;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ?&gt;</div><div class="line"></div><div class="line">    &lt;/table&gt;</div><div class="line">&lt;/center&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><h4 id="menu-php"><a href="#menu-php" class="headerlink" title="menu.php"></a>menu.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h2&gt;学生管理系统&lt;/h2&gt;</div><div class="line">&lt;a href=&quot;index.php&quot;&gt; 浏览学生&lt;/a&gt;</div><div class="line">&lt;a href=&quot;add.php&quot;&gt; 添加学生&lt;/a&gt;</div><div class="line">&lt;hr&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><h4 id="add-php"><a href="#add-php" class="headerlink" title="add.php"></a>add.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;学生信息管理&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;center&gt;</div><div class="line">    &lt;?php include(&quot;menu.php&quot;); ?&gt;</div><div class="line">    &lt;h3&gt;增加学生信息&lt;/h3&gt;</div><div class="line">    &lt;form method=&quot;post&quot; action=&quot;action.php?action=add&quot;&gt;</div><div class="line"></div><div class="line">        &lt;table&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;姓名&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input  name=&quot;name&quot; type=&quot;text&quot;/&gt;&lt;/td&gt;</div><div class="line"></div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;性别&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;/&gt; 男</div><div class="line">                    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;/&gt; 女</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;年龄&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;班级&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input  name=&quot;classid&quot; type=&quot;text&quot;/&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt; &lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;增加&quot;/&gt;  </div><div class="line">                    &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">        &lt;/table&gt;</div><div class="line"></div><div class="line">    &lt;/form&gt;</div><div class="line">&lt;/center&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1868951-40db8e8dca16bc41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加成功"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6fb2b56d2790f7c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加后"></p><h4 id="edit-php"><a href="#edit-php" class="headerlink" title="edit.php"></a>edit.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;学生信息管理&lt;/title&gt;</div><div class="line"></div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;center&gt;</div><div class="line">    &lt;?php</div><div class="line">    include_once &quot;menu.php&quot;;</div><div class="line">    //1.连接数据库</div><div class="line">    try &#123;</div><div class="line">        $pdo = new PDO(&quot;mysql:host=localhost;dbname=test;&quot;, &quot;root&quot;, &quot;&quot;);</div><div class="line">    &#125; catch (PDOException $e) &#123;</div><div class="line">        die(&quot;数据库连接失败&quot; . $e-&gt;getMessage());</div><div class="line">    &#125;</div><div class="line">    //2.防止中文乱码</div><div class="line">    $pdo-&gt;query(&quot;SET NAMES &apos;UTF8&apos;&quot;);</div><div class="line">    //3.拼接sql语句，取出信息</div><div class="line">    $sql = &quot;SELECT * FROM message WHERE id =&quot; . $_GET[&apos;id&apos;];</div><div class="line">    $stmt = $pdo-&gt;query($sql);//返回预处理对象</div><div class="line">    if ($stmt-&gt;rowCount() &gt; 0) &#123;</div><div class="line">        $stu = $stmt-&gt;fetch(PDO::FETCH_ASSOC);//按照关联数组进行解析</div><div class="line">    &#125; else &#123;</div><div class="line">        die(&quot;没有要修改的数据！&quot;);</div><div class="line">    &#125;</div><div class="line">    ?&gt;</div><div class="line">    &lt;form method=&quot;post&quot; action=&quot;action.php?action=edit&quot;&gt;</div><div class="line"></div><div class="line">        &lt;input type=&quot;hidden&quot; name=&quot;id&quot; id=&quot;id&quot; value=&quot;&lt;?php echo $stu[&apos;id&apos;]; ?&gt;&quot;/&gt;</div><div class="line">        &lt;table&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;姓名&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input id=&quot;name&quot; name=&quot;name&quot; type=&quot;text&quot; value=&quot;&lt;?php echo $stu[&apos;name&apos;] ?&gt;&quot;/&gt;&lt;/td&gt;</div><div class="line"></div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;性别&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; &lt;?php echo ($stu[&apos;sex&apos;] == &quot;男&quot;) ? &quot;checked&quot; : &quot;&quot; ?&gt;/&gt; 男</div><div class="line">                    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; &lt;?php echo ($stu[&apos;sex&apos;] == &quot;女&quot;) ? &quot;checked&quot; : &quot;&quot; ?&gt;/&gt; 女</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;年龄&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; id=&quot;age&quot; value=&quot;&lt;?php echo $stu[&apos;age&apos;] ?&gt;&quot;/&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;班级&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input id=&quot;classid&quot; name=&quot;classid&quot; type=&quot;text&quot; value=&quot;&lt;?php echo $stu[&apos;classid&apos;] ?&gt;&quot;/&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt; &lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;修改&quot;/&gt;  </div><div class="line">                    &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">        &lt;/table&gt;</div><div class="line"></div><div class="line">    &lt;/form&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/center&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><h4 id="action-php"><a href="#action-php" class="headerlink" title="action.php"></a>action.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">//1.连接数据库</div><div class="line">try&#123;</div><div class="line">    $pdo = new PDO(&quot;mysql:host=localhost;dbname=test;&quot;,&quot;root&quot;,&quot;&quot;);</div><div class="line">&#125;catch(PDOException $e)&#123;</div><div class="line">    die(&quot;数据库连接失败&quot;.$e-&gt;getMessage());</div><div class="line">&#125;</div><div class="line"></div><div class="line">//2.通过action的值做地应操作</div><div class="line"></div><div class="line">switch($_GET[&apos;action&apos;])&#123;</div><div class="line">    case &quot;add&quot;://增加操作</div><div class="line">        $name = $_POST[&apos;name&apos;];</div><div class="line">        $sex = $_POST[&apos;sex&apos;];</div><div class="line">        $age = $_POST[&apos;age&apos;];</div><div class="line">        $classid = $_POST[&apos;classid&apos;];</div><div class="line"></div><div class="line">        $sql = &quot;insert into message values(null,&apos;&#123;$name&#125;&apos;,&apos;&#123;$sex&#125;&apos;,&apos;&#123;$age&#125;&apos;,&apos;&#123;$classid&#125;&apos;)&quot;;</div><div class="line">        $rw = $pdo-&gt;exec($sql);</div><div class="line">        if($rw &gt; 0)&#123;</div><div class="line">            echo &quot;&lt;script&gt;alert(&apos;增加成功&apos;);window.location=&apos;index.php&apos;&lt;/script&gt;&quot;;</div><div class="line">        &#125;else&#123;</div><div class="line">            echo &quot;&lt;script&gt;alert(&apos;增加失败&apos;);window.history.back();&lt;/script&gt;&quot;;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case &quot;del&quot;; //删除操作</div><div class="line">        $id = $_GET[&apos;id&apos;];</div><div class="line">        $sql = &quot;delete from message where id=&#123;$id&#125;&quot;;</div><div class="line">        $pdo-&gt;exec($sql);</div><div class="line">        header(&quot;Location:index.php&quot;);</div><div class="line">        break;</div><div class="line"></div><div class="line">    case &quot;edit&quot;:</div><div class="line"></div><div class="line">        //1.获取表单信息</div><div class="line">        $name = $_POST[&apos;name&apos;];</div><div class="line">        $sex = $_POST[&apos;sex&apos;];</div><div class="line">        $age = $_POST[&apos;age&apos;];</div><div class="line">        $classid = $_POST[&apos;classid&apos;];</div><div class="line">        $id = $_POST[&apos;id&apos;];</div><div class="line"></div><div class="line">        $sql = &quot;update message set name=&apos;&#123;$name&#125;&apos;,sex=&apos;&#123;$sex&#125;&apos;,age=&#123;$age&#125;,classid=&#123;$classid&#125; where id=&#123;$id&#125;&quot;;</div><div class="line">        $rw = $pdo-&gt;exec($sql);</div><div class="line">        if($rw&gt;0)&#123;</div><div class="line">            echo &quot;&lt;script&gt;alert(&apos;修改成功&apos;);window.location=&apos;index.php&apos;&lt;/script&gt;&quot;;</div><div class="line">        &#125;else&#123;</div><div class="line">           echo &quot;&lt;script&gt;alert(&apos;增加失败&apos;);window.history.back();&lt;/script&gt;&quot;;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– Database: &lt;code&gt;test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;– 表的结构 &lt;code&gt;message&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Github上Fork代码，及源码修改</title>
    <link href="http://yoursite.com/2017/05/15/iOS/Github%E4%B8%8AFork%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%8A%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-/"/>
    <id>http://yoursite.com/2017/05/15/iOS/Github上Fork代码，及源码修改-/</id>
    <published>2017-05-15T07:19:00.000Z</published>
    <updated>2017-10-31T09:41:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中经常遇到这种情况，你使用的第三方库不能完全满足自己项目需要，只能修改源码来解决。<br>我们以前的解决办法是，添加到项目中直接修改源码。这样就有一个问题，不能和源库同步，当作者更新后你不能（pod update）更新，否则自己原来的修改就被冲掉了。所以只能选择不更新，或者更新后重新修改源码。</p><p>当第三方库更新时如何同步更新？Git的Fork功能解决了这种问题，当你fork别人的开源代码后，你可以随意的修改。当然你对自己的修改满意还可以请求合并到（pull request）原作者项目中去。</p><p>今天具体讲解如何在Github上Fork别人的代码，进行二次开发。下面以<strong>iOS-Charts</strong>为例，<a href="http://lvesli.com/2016/06/06/iOS-Charts/" target="_blank" rel="external">上一篇文章</a>中我对这个开源库做了介绍。</p><p>1.首先你要有自己的Github账号<br>2.进入<a href="https://github.com/danielgindi/Charts" target="_blank" rel="external">https://github.com/danielgindi/Charts</a> 你要Fork项目的首页点击右上角Fork<br>3.到自己项目列表就可以看到刚刚Fork的项目了</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-eb564f0a66f08f66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>现在你就可以当做自己的项目，随意的更改了。如果修改完之后你想和原来库合并，贡献自己的代码，就点击自己项目中的“New Pull Request”请求合并。作者同意后就可以在项目中看到自己贡献的代码了。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e44c5466ea2baf09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面讲解本文的重点，如何修改源码满足自己项目需求。修改时注意一下几点：</p><pre><code>1.改源码首先当然是读懂源码了，读懂后才知道从何下手。2.查看源码时一开始不止如何下手，对于一些UI控件我的解决方式是采用“注释法”，先把不知道的代码注释掉然后运行查看效果，通过对比界面可以简单直接的看到代码在操控那里。3.修改时要考虑如何最小的改动满足自己需求，可以尝试添加子类或者分类的形式解决。4.实在没办法只能修改源码了，修改源码的地方最好做上标记，方便自己查看、修改。</code></pre><p>举个例子，我们想要修改点击Charts高亮时的高亮线的形式，改之前的效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-bdd195925ef6629a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>我们想要隐藏掉水平高亮线，只显示垂直高亮线，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-a9b2f46c390be392.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>通过查看源码我们可以知道<strong>LineChartDateSet</strong>的属性<strong>drawVerticalHighlightIndicatorEnabled</strong>是控制是否显示垂直高亮线的，我们简单推理，通过搜索这个属性我们应该能找到如何绘制高亮线的代码。</p><p>通过全局搜索 <strong>drawVerticalHighlightIndicatorEnabled</strong>结果如下图:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-dc82f7b9a7c9aba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>并没有找到绘制高亮线的代码，查看属性定义的地方发现<strong>drawVerticalHighlightIndicatorEnabled</strong>是存储属性，还有一个对应的计算性属性<strong>isVerticalHighlightIndicatorEnabled</strong>，我们接下来全局搜索<strong>isVerticalHighlightIndicatorEnabled</strong> ,结果如下：</p><p>通过注意查看，我们可以确定<strong>LineScatterCandleRadarChartRenderer.swift</strong>有绘制高亮线的地方，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-929885ec3fe15e82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以发现35-38行是控制如何绘制竖直高亮线的代码，我们注释掉，</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-b4f0c4e929b17c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>换成使用图片来绘制的代码，修改成如下代码（前提准备一张高亮图”highlight_line”）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CGContextSaveGState(context);</div><div class="line">//获得高亮线图片</div><div class="line">let lineImage = NSUIImage(named: &quot;highlight_line&quot;)</div><div class="line">//绘制</div><div class="line">lineImage?.drawInRect(CGRectMake(point.x-5.0/2.0, viewPortHandler.contentTop, 5, viewPortHandler.contentBottom - viewPortHandler.contentTop))</div><div class="line"></div><div class="line">CGContextRestoreGState( context );</div></pre></td></tr></table></figure><p>运行看下效果轻松搞定。</p><p>文章转载自:<a href="http://lvesli.com/?p=184&amp;utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">lvesli</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS开发中经常遇到这种情况，你使用的第三方库不能完全满足自己项目需要，只能修改源码来解决。&lt;br&gt;我们以前的解决办法是，添加到项目中直接修改源码。这样就有一个问题，不能和源库同步，当作者更新后你不能（pod update）更新，否则自己原来的修改就被冲掉了。所以只能选择不
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>动画切换效果之push、pop、present、dismiss</title>
    <link href="http://yoursite.com/2017/05/08/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/%E5%8A%A8%E7%94%BB%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E4%B9%8Bpush%E3%80%81pop%E3%80%81present%E3%80%81dismiss/"/>
    <id>http://yoursite.com/2017/05/08/动画与绘图/动画切换效果之push、pop、present、dismiss/</id>
    <published>2017-05-08T02:55:03.000Z</published>
    <updated>2017-10-30T05:48:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候页面跳转或视图切换的时候,需要做成特定的效果,常见的push、pop、present、dismiss效果如下,注意要添加<strong><caanimationdelegate></caanimationdelegate></strong>代理</p><h4 id="push默认动画效果"><a href="#push默认动画效果" class="headerlink" title="push默认动画效果"></a>push默认动画效果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    CATransition *transition = [CATransition animation];</div><div class="line">    transition.duration = 0.3f;</div><div class="line">    transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    transition.type = kCATransitionPush;</div><div class="line">    transition.subtype = kCATransitionFromRight;</div><div class="line">    transition.delegate = self;</div><div class="line">    [self.contentView.layer addAnimation:transition forKey:nil];</div><div class="line">    [self.contentView addSubview:self.productDetailController.view];</div><div class="line"></div><div class="line">```  </div><div class="line">#### pop默认动画效果</div></pre></td></tr></table></figure><pre><code>CATransition *transition = [CATransition animation];transition.duration = 0.3f;transition.timingFunction = [CAMediaTimingFunctionfunctionWithName:kCAMediaTimingFunctionEaseInEaseOut];transition.type = kCATransitionPush;transition.subtype = kCATransitionFromLeft;transition.delegate = self;[self.view.superview.layer addAnimation:transition forKey:nil];[self.view removeFromSuperview];</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### present默认动画效果</div></pre></td></tr></table></figure><pre><code>CATransition *transition = [CATransition animation];transition.duration = 0.4f;transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];transition.type = kCATransitionMoveIn;transition.subtype = kCATransitionFromTop;transition.delegate = self;[[self currentNavigationController].view.layer addAnimation:transition forKey:nil];[[self currentNavigationController] pushViewController:playVC animated:NO];</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#### dismiss默认动画效果</div></pre></td></tr></table></figure><pre><code>CATransition *transition = [CATransition animation];transition.duration = 0.3f;transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];transition.type = kCATransitionReveal;transition.subtype = kCATransitionFromBottom;transition.delegate = self;[self.navigationController.view.layer addAnimation:transition forKey:nil];[self.navigationController popViewControllerAnimated:NO];</code></pre><p>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候页面跳转或视图切换的时候,需要做成特定的效果,常见的push、pop、present、dismiss效果如下,注意要添加&lt;strong&gt;&lt;caanimationdelegate&gt;&lt;/caanimationdelegate&gt;&lt;/strong&gt;代理&lt;/p&gt;
&lt;h4 id=
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="动画与绘图" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>HTTP笔记</title>
    <link href="http://yoursite.com/2017/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/04/07/计算机网络/HTTP笔记/</id>
    <published>2017-04-07T06:47:00.000Z</published>
    <updated>2017-10-30T05:51:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>“你知道当我们在网页浏览器（Web browser）的地址栏中输入 URL 时，Web 页面是如何呈现的吗？”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-48cf5d50116ffd8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="过程.png"></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议（HyperText Transfer Protocol）即超文本传输协议是用于服务器传输到客户端浏览器的传输协议。Web上，服务器和客户端利用HTTP协议进行通信会话。</p><p>在Web上，HTTP协议使用TCP协议而不是UDP协议的原因在于一个网页必须传送很多数据，而且保证其完整性。TCP协议提供传输控制，按顺序组织数据和错误纠正的一系列功能。</p><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><pre><code>1、客户端与服务器需要建立连接。（比如某个超级链接，HTTP就开始了。）2、建立连接后，发送请求。3、服务器接到请求后，响应其响应信息。4、客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</code></pre><p>忽略掉连接过程是这样的:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-058c281b84838c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作过程.png"></p><h3 id="URI、URL与RFC"><a href="#URI、URL与RFC" class="headerlink" title="URI、URL与RFC"></a>URI、URL与RFC</h3><p>先看看官方的解释：<br>URI：uniform resource identifier 统一资源标识符<br>URL：uniform resource location 统一资源定位符</p><p>URI用字符串标识某一互联网资源，而URL表示资源的地点。可见URL是URI的子集。</p><p>URI要使用涵盖全部必要信息的URI、绝对URL以及相对URL。相对URL是指从浏览器中基本URI处理的URL，来先看下URI的格式:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-eb2b672fed8c4be9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="URI格式.png"></p><p>RFC：reqeust for comments 征求修正意见书<br>RFC素有网络知识圣经之称，规定了网络中协议的基本内容。因此许多的不同系统的应用程序才可以互相访问。</p><h3 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h3><p>请求行-请求方法</p><ul><li>GET            获取资源</li><li>POST          传输实体主体</li><li>PUT            传输文件</li><li>HEAD         获取报文首部</li><li>DELETE     删除文件</li><li>OPTIONS   请求查询服务器的性能，或者查询与资源相关的选项和需求 </li><li>TRACE        请求服务器回送收到的请求信息，主要用于测试或诊断</li><li>CONNECT  要求用隧道协议连接代理(SSL：Secure Sockets Layer安全套接层，TLS：Transport Layer Security传输层安全)</li></ul><h3 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h3><p><a href="https://segmentfault.com/a/1190000004014583" target="_blank" rel="external">看别人总结的吧</a><br><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external">还有这篇</a></p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-94b9b3e85b4abde1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="状态码类别.png"></p><p>常见的状态码</p><pre><code>200 OK请求成功（其后是对GET和POST请求的应答文档。）304 Not Modified未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。404 Not Found服务器无法找到被请求的页面。500 Internal Server Error请求未完成。服务器遇到不可预知的情况。</code></pre><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。</p><p>请求我博客园首页时发送的报文内容:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-2e62214fed2f76cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报文.png"></p><p>　其中最常使用的属性是：</p><ul><li>URL, 即http访问的地址</li><li>request method, 报文的请求方式</li><li>Remote Address,远程地址</li><li>status code, 状态码以及状态短语</li><li>Connection, 连接方式</li><li>Content-Type头：便是接收方实体的介质类型。</li><li>Accept Encoding, 内容编码</li><li>Date头域：时间描述</li><li>Referer头域：允许客户端指定请求URL的资源地址。</li><li>Cookie, 添加的cookie内容</li><li>Host, 目标主机</li><li>User-Agent, 客户端浏览器的相关信息</li><li>Set-Cookie, 指定想要在Cookie中保存的内容</li></ul><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>“HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-cf9c8252e3979368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通信一次断开一次.png"></p><p>“为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-4e13a9ac5f083e57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="持久连接.png"></p><p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。<br>在 HTTP/1.1 中，所有的连接默认都是持久连接</p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>“持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p><p>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-5f1fa307c9c4ca54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-16 下午3.41.33.png"></p><p>比如，当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。</p><h3 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h3><p>由于某些报文的内容过大，因此在传输时，为了减少传输的时间，会采取一些压缩的措施。</p><p>例如上面的报文信息中，Accept-Encoding就定义了内容编码的格式：gzip,deflate</p><p>有下面几种方式：</p><ul><li>gzip：GNU压缩格式</li><li>compress：UNIX系统的标准压缩格式</li><li>deflate：是一种同时使用了LZ77和哈弗曼编码的无损压缩格式</li><li>identity：不进行压缩</li></ul><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p><p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。</p><p>对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0a2a457a44dd55e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-16 下午4.13.32.png"></p><p>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。</p><p>byte 范围的指定形式如下。</p><ul><li><p>5001~10 000 字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=5001-10000</div></pre></td></tr></table></figure></li><li><p>从 5001 字节之后全部的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=5001-</div></pre></td></tr></table></figure></li><li><p>从一开始到 3000 字节和 5000~7000 字节的多重范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=-3000, 5000-7000</div></pre></td></tr></table></figure></li></ul><p>针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</p><p>如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。”</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</p><p>假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。</p><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><p>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-89c6414d2822a545.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Cookie.png"></p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP 主要有这些不足，例举如下。</p><ul><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改”</li></ul><p>这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题。</p><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p><p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f647e66bc61d89e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SSL.png"></p><p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。</p><p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-aec3c3a7c56e95da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTPS通信.png"></p><p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p><p>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p><p>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p><p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p><p>步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p><p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p><p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p><p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p><p>步骤 9： 服务器同样发送 Finished 报文。</p><p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p><p>步骤 11： 应用层协议通信，即发送 HTTP 响应。</p><p>步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p><p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><h3 id="HTTP认证"><a href="#HTTP认证" class="headerlink" title="HTTP认证"></a>HTTP认证</h3><p>　　有一些网址或者服务需要用户的身份信息，因此需要随时知道这些消息，但是肯定不能每次都让用户输入用户密码，因此关于认证就有下面几种方式：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-7742dd7b79eca737.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="032135393488858.jpeg"></p><p>其中BASIC认证是最简单的认证，大致过程如下：<br>1 、客户端访问某URL。<br>2 、服务器端返回401状态码，提示用户输入用户名密码。<br>3 、用户输入用户名密码，通过BASE64编码传输。<br>4 、服务器通过认证，返回状态码200</p><p>通过上面的过程，就可以发现BASIC的问题：</p><ul><li>仅仅通过BASE64编码，其实还是属于明文传输，安全性不高</li><li>有的浏览器不支持注销</li></ul><p>鉴于上面BASIC的问题，DIGEST做了补充，它的过程与上面类似：<br>1 、客户端访问<br>2 、服务器端返回质询码<br>3 、客户端发送响应码</p><p>这里通过随机的生成质询码来作为计算的一种方式，客户端依据这个质询码生成响应码，进行验证。<br>这样就弥补了明文传输用户密码的风险。</p><p>SSL客户端验证，这个比较普遍了！</p><p>像支付宝啊，邮政网银啊之类的，在登录时，都需要下载一个数字认证的东西，这个东西就属于一种SSL客户端的验证。</p><p>很显然它的缺点就是需要客户去手动的安装，这个对于一般的用户来说，代价有点高。</p><p>最后一种是应用最普遍的，通过表单记录用户的身份信息，可以使用cookie或者session的方式保存用户信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“你知道当我们在网页浏览器（Web browser）的地址栏中输入 URL 时，Web 页面是如何呈现的吗？”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1868951-48cf5d5011
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP-IP笔记(八)应用层协议</title>
    <link href="http://yoursite.com/2017/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%AC%94%E8%AE%B0(%E5%85%AB)%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2017/03/21/计算机网络/TCP-IP笔记(八)应用层协议/</id>
    <published>2017-03-21T02:30:00.000Z</published>
    <updated>2017-10-30T05:52:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP的应用层涵盖了OSI参考模型中第5、第6、第7层的所有功能,不仅包含了管理通信连接的会话层功能、转换数据格式的标识层功能,还包括与对端主机交互的应用层功能在内的所有功能。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-07276cc0a56fa5bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模型.png"><br>利用网络的应用程序有很多,包括Web浏览器、电子邮件、远程登录、文件传输、网络管理等。能够让这些应用进行特定通信处理的正式应用协议。</p><p>接下来介绍下应用层常见的协议:</p><ul><li><p>DNS：域名系统。DNS是因特网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。</p><ul><li><p>因特网的域名结构<br>如：  mail.cctv.com    三级域名,二级域名,顶级域名</p><p> 现在顶级域名TLD（Top Level Domain）共分为三大类：<br>　　　　1.国家顶级域名nTLD：如cn表示中国，us为美国<br>　　　　2.通用顶级域名gTLD：如com（公司企业）、net（网络服务机构）、int（国际组织）<br>　　　　3.基础结构域名：只有一个，即arpa，用于反向域名解析</p></li><li><p>域名服务器<br>　　完成域名到IP地址的解析工作。包括：<br>　　　　1.根域名服务器（root name server）：最高层次的域名服务器，知道所有顶级域名服务器的域名和IP地址。<br>　　　　2.顶级域名服务器：负责管理在该顶级域名服务器注册的所有二级域名。<br>　　　　3.权限域名服务器：负责一个区的域名服务器。<br>　　　　4.本地域名服务器：是自己可以设置的服务器，用于管理自己分发的域名。</p></li></ul></li></ul><ul><li><p>FTP：文件传输协议。FTP是因特网上使用得最广泛的文件传送协议。FTP提供交互式的访问，允许客户指明文件类型与格式，并允许文件具有存取权限。FTP其于TCP。</p></li><li><p>HTTP：超文本传送协议。是面向事务的应用层协议，它是万维网上能够可靠地交换文件的重要基础。http使用面向连接的TCP作为运输层协议，保证了数据的可靠传输。</p></li><li><p>SMTP：电子邮件协议。即简单邮件传送协议。SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。SMTP通信的三个阶段：建立连接、邮件传送、连接释放。</p></li><li><p>POP3：邮件读取协议。POP3(Post Office Protocol 3)协议通常被用来接收电子邮件。</p></li><li><p>SNMP：简单网络管理协议。由三部分组成：SNMP本身、管理信息结构SMI和管理信息MIB。SNMP定义了管理站和代理之间所交换的分组格式。SMI定义了命名对象类型的通用规则，以及把对象和对象的值进行编码。MIB在被管理的实体中创建了命名对象，并规定类型。</p></li></ul><p>TCP支持的应用协议主要有：Telnet （远程终端协议）、FTP（文件传输协议）、POP3（邮件读取协议）、SMTP（电子邮件协议）等。</p><p>UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP/IP的应用层涵盖了OSI参考模型中第5、第6、第7层的所有功能,不仅包含了管理通信连接的会话层功能、转换数据格式的标识层功能,还包括与对端主机交互的应用层功能在内的所有功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP-IP笔记(七)TCP详解</title>
    <link href="http://yoursite.com/2017/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%AC%94%E8%AE%B0(%E4%B8%83)TCP%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/03/17/计算机网络/TCP-IP笔记(七)TCP详解/</id>
    <published>2017-03-17T02:11:00.000Z</published>
    <updated>2017-10-30T05:52:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP的特点及其目的"><a href="#TCP的特点及其目的" class="headerlink" title="TCP的特点及其目的"></a>TCP的特点及其目的</h3><p>  为了通过数据包实现可靠性传输,需要考虑很多事情,例如数据的破坏、丢包、重复记忆分片顺序混乱等问题。如不能解决这些问题,也就无从谈起可靠传输。<br>TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p><h3 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h3><p>在TCP中,当发送端的数据到达接收主机时,接收端主机会番号一个已收到消息的通知。这个消息叫做确认应答–ACK(Positive Acknowled-gement 意指已经接收。)</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-91892d00cf216bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正常的数据传输.png"></p><p>TCP通过肯定的确认应答(ACK)实现可靠的数据传输。当发送端将数据发生之后会等待对端的确认应答。如果有确认应答,说明数据已经成功到达对端。反之,则数据丢失的可能性很大。</p><p>当然,在一定时间内没有等到确认应答,发送端就可以认为数据已经丢失,并进行重发。由此,即使产生了丢包,仍然能够保证数据能够到达对端,实现可靠传输。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-b6cb6c12465ed4f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据包丢失的情况.png"></p><p>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到,知识返回的确认应答在途中丢失。这种情况也会导致发送端因没有收到确认应答,而认为数据没有到达目的地,从而进行重新发送,如下图:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6588851c3553d3d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="确认应答丢失的情况.png"><br>此外,也有可能因为一些其他原因导致确认应答延迟到达,在源主机重发数据以后才到达的情况也屡见不鲜。此时,源发送主机只需重发数据即可,但是对目标主机,反复收到相同的数据,确是一种”灾难”。而为了对上层应用提供可靠的传输,必须得放弃重复的数据包。</p><p>为此,必须引入一种机制,它能够识别出是否已经接收数据,又能够判断是否需要接收。<br>上述这些确认应答处理、重发控制以及重复控制等功能都可以通过<strong>序列号</strong>实现。<br>序列号是按顺序给发送数据的每一个字节(8位字节)都标上号码的编号。<br>接收到查询接收数据TCP首部中的序列号和数据的长度,将自己下一步应该接收的序号作为确认应答返送回去。<br>就这样,通过序列号和确认应答号,TCP可以实现可靠传输。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6453ddc87ed87740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送数据.png"></p><h3 id="重发超时"><a href="#重发超时" class="headerlink" title="重发超时"></a>重发超时</h3><p>重发超时是指在重发数据之前,等待确认应答到来的那个特定时间间隔。如果超过了这个时间仍未收到确认应答,发送端将进行数据重发。</p><p>在BSD的Unix以及Windows系统中,超时都以0.5秒为单位进行控制,因此重发超时都是0.5秒的整数倍。不过,由于最初的数据包还不知从往返时间,所以其重发超时一般设置为6秒左右。</p><p>数据被重发之后如还是收不到确认应答,则进行再次发送。此时,等待确认应答的时间将会以2倍、4倍的指数函数延长。</p><p>此外,数据也不会被无限、反复地重发。达到一定重发次数之后,如果人没有任何确认应答返回,就会判断为网络或对端主机发生了异常,强制关闭连接。并且通知应用通信异常强行终止。</p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>TCP提供面向有连接的通信传输。面向有链接是指在数据通信开始之前先做好通信两端之间的准备工作。<br>一个连接的建立与断开,正常过程至少需要来回发送7个包才能完成。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-425ec4bbedcbf6d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP连接的建立与断开.png"></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。这就是面试中经常会被问到的TCP三次握手。只是了解TCP三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。 </p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-3f85c6bc89d1824c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP三次握手.png"></p><ol><li><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p></li><li><p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p></li><li><p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p></li></ol><p>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：</p><pre><code>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</code></pre><p>在书中同时举了一个例子，如下：</p><blockquote><p>   已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。</p></blockquote><p>这就很明白了，<strong>防止了服务器端的一直等待而浪费资源。</strong></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次挥手”。</p><p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-7734f69f8b86c584.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP四次挥手.png"></p><ol><li><p>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p></li><li><p>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p></li><li><p>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p></li><li><p>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p></li></ol><p>至此，TCP的四次挥手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。    </p><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>那四次挥手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p>如果要正确的理解四次挥手的原理，就需要了解四次挥手过程中的状态变化。</p><ul><li><p>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</p></li><li><p>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</p></li><li><p>CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</p></li><li><p>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</p></li><li><p>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</p></li><li><p>CLOSED: 表示连接中断。</p></li></ul><h3 id="TCP以段为单位发送数据"><a href="#TCP以段为单位发送数据" class="headerlink" title="TCP以段为单位发送数据"></a>TCP以段为单位发送数据</h3><p>TCP在传送大量数据时,是以MSS(Maximum Segment Size 最大消息长度)的大小将数据进行分割发送。进行重发是也是以MSS为单位。<br>MSS是在三次握手的时候,在两端主机之间被计算得出剧好两端的主机在发出建立连接的请求是,会在TCP首部中写入MSS选项,告诉对方自己的接口能够适的MSS的大小。然后会在两者之间选择一个较小的值投入使用。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-c9efbb3f75cb0026.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选较小的MSS.png"></p><h3 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h3><p>TCP以1个段为单位,每发一个段进行一次确认应答的处理。<br>如图:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-16ace958aa720fcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="按数据包进行确认应答.png"></p><p>为了解决通信性能的问题,TCP引入了<strong>窗口</strong>这个概念。<br>确认应答不再以每个分段,而是以更大的单位进行确认时,转发时间将会被大幅度的缩短。也就是说,发送端主机,在发送了一个段以后不必要一直等待确认应答,而是继续发送。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-a95b6a70a6b2561b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用滑动窗口方式并行处理.png"></p><p>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中的窗口大小为4个段。<br>这个机制实现了使用大量的缓冲区,通过对多个段同时进行确认应答的功能。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f9c5f50664cee2ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-15 下午2.08.17.png"><br>如上图中,发送数据中高亮圈起的部分正是前面所提到的窗口。<br>在收到确认应答后,将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也被称为滑动窗口控制。</p><h3 id="窗口控制与重发控制"><a href="#窗口控制与重发控制" class="headerlink" title="窗口控制与重发控制"></a>窗口控制与重发控制</h3><p>在未使用窗口控制时,没有收到确认应答的数据都会被重发。而是用了窗口控制,某些确认应答即使丢失也无需重发</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-dcd5eefd4a7098f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="没有确认应答也不受影响.png"></p><p>其次,我们来考虑一下某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序号以外的数据时,会针对当前位置收到的数据返回确认应答。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-88fa4df7026201ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重发控制.png"></p><p>当某一报文段丢失后,发送端会一直收到序号为1001的确认应答,这个确认应答提醒发送端,”我想接收的是从1001开始的数据”。</p><p>因此,当窗口比较大时,又出现报文段丢失是,同一序号的确认应答会不断重复的返回。<br>当发送端主机如果连续3次收到同一个确认应答,就会将其所对应的数据进行重发。</p><p>这种机制,比之前提到超时管理更搞笑,因此也被称作高速重发控制。</p><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p>流控制是TCP提供的一种可以让发送端根据接受端的实际接收能力控制发送的数据量的机制。<br>具体操作是,接收端主机箱发送端主机通知自己可以接收数据的大小,于是发送端会发送不超过这个限度的数据。该大小限度就被称作窗口大小。<br>TCP首部中,专门有一个字段用来通知窗口大小。<br>接收主机将自己可以接收的缓存区大小放入这个字段中通知给发送端。这个字段的值越大,说明网络的吞吐量越高。<br>不过,当接收端的缓冲区面临数据溢出时,窗口大小的值也会随之呗设置为一个更小的值通知给发送端,从而控制数据发送量。<br>也就是说,发送端主机会根据接收端主机的指示,对发送数据的量进行控制。这也就形成了一个完整的TCP流控制(流量控制)</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-bac76fbc083e437a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流量控制.png"><br>如上图,当接收端从3001号开始的数据段后其缓冲区即满,不得不暂时停止接收数据。之后,在收到发送窗口更新通知后通信才得以继续进行。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>有了窗口控制,首发主机之间可以不再以一个数据段为单位发送确认应答,也能够连续发送大量数据包。但是如果在通信刚开始时就发送大量数据,也有可能会引发其他问题。<br>TCP为了防止该问题的出现,在通信一开始时就会通过一个叫做慢启动的算法得出的数值,对发送数据量进行控制。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-20db3532f42cbafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-15 下午2.39.30.png"><br>首先,为了在发送端调节所要发送数据的量,定义了一个叫做”拥堵窗口”的概念。于是在慢启动的时候,将这个拥堵窗口的大小设置为1个数据段(1MSS)发送数据,之后每收到一次确认应答(ACK),拥堵窗口的值就加1。在发送数据包时,将拥堵窗口的大小与接收端主机通知的窗口大小做比较,然后按照它们当中较小那个值,发送比其还要小的数据量。<br>如果重发采用超时机制,那么拥塞窗口的初始值可以设置为1以后再进行慢启动修正。有了上述这些机制,就可以有限的减少通信开始时连续发包导致的网络拥堵,还可以避免网络拥塞情况的发生。<br>不过,随着包的每次往返,拥塞窗口也会以1、2、4等指数函数的增长,拥堵状况激增甚至导致网络拥塞的发生。为了防止这些,引入了慢启动阀值的概念。只要拥塞窗口的值超出这个阀值,在每收到一次确认应答时,只允许以下面这种比例方法拥塞窗口:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-b36ac71de7daf1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公式.png"><br><img src="http://upload-images.jianshu.io/upload_images/1868951-c71265a3e7831314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拥塞窗口的大小.png"><br>当TCP通信开始以后,网络吞吐量会逐渐上升,但是随着网络拥堵的发生吞吐量也会急剧下降。于是会再次进入吞吐量慢慢上升的过程。因此所谓TCP的吞吐量的特点就好像是在逐步占领网络带宽的感觉。</p><h3 id="提高网络利用率的规范"><a href="#提高网络利用率的规范" class="headerlink" title="提高网络利用率的规范"></a>提高网络利用率的规范</h3><ul><li>Nagle算法</li><li>延迟确认应答</li><li>捎带应答</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP的特点及其目的&quot;&gt;&lt;a href=&quot;#TCP的特点及其目的&quot; class=&quot;headerlink&quot; title=&quot;TCP的特点及其目的&quot;&gt;&lt;/a&gt;TCP的特点及其目的&lt;/h3&gt;&lt;p&gt;  为了通过数据包实现可靠性传输,需要考虑很多事情,例如数据的破坏、丢包、重
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP-IP笔记(六)TCP与UDP</title>
    <link href="http://yoursite.com/2017/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%AC%94%E8%AE%B0(%E5%85%AD)TCP%E4%B8%8EUDP/"/>
    <id>http://yoursite.com/2017/03/17/计算机网络/TCP-IP笔记(六)TCP与UDP/</id>
    <published>2017-03-17T01:27:00.000Z</published>
    <updated>2017-10-30T05:53:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于来到了传输层,这个面试问的最多了😁</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>TCP/IP中有两个具有代表性的传输层协议,分别为:</p><ul><li>TCP: 提供可靠的通信传输</li><li>UDP:用于让广播和细节控制交给应用的通信传输<br>根据通信的具体特征,选择合适的传输层协议非常重要。</li></ul><p><strong>套接字(Socket):</strong><br>使用TCP或UDP时,会广泛使用到套接字(socket)的API。套接字原本是由BSD UNIX开发的,但是后被移植到了Windows的Winsock以及嵌入式操作系统中。<br>应用程序利用套接字,可以设置对端的IP地址、端口号,并实现数据的发送与接收。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-8fda5539e2a827c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Socket.png"></p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>数据链路和IP中的地址,分别指的是MAC地址和IP地址。<br>前者用来识别同一链路中不同的计算机,后者用来识别TCP/IP网络中互连的主机和路由器。</p><p>同样的,在传输层中也有类似于地址的概念,那就是端口号。</p><p>端口号用来识别同一台计算机中进行通信的不同应用程序。因此,它也被称为程序地址。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-afc4629f1a207553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="端口号.png"></p><p>另:仅凭目标端口识别某一个通信是远远不够的。通常采用5个信息来识别一个通信。它们分别是:</p><ul><li>源IP地址</li><li>目标IP地址</li><li>协议号 :在IP协议部分我们提到IP首部中有一个协议字段,用来标识网络层(IP)的上层所采用的是哪一种传输层协议。根据这个字段的协议号,就可以识别IP传输的数据部分究竟是TCP的内容,还是UDP的内容。</li><li>源端口号</li><li>目标端口号</li></ul><h4 id="端口号如何确定"><a href="#端口号如何确定" class="headerlink" title="端口号如何确定"></a>端口号如何确定</h4><ul><li>标准既定的端口号<br>也叫静态方法。是指每个应用程序都有其指定的端口号。但不是说可以随意使用任何一个端口号。每个端口号都有其对应的使用目的。<br>例如,HTTP、TELNET、FTP等应用协议使用的知名端口号:</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-2816627c3f993fc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="知名端口号.png"></p><ul><li>时序分配法<br>也叫动态分配法。服务端有必要确定监听端口号,但是客户端没必要确定端口号。<br>这种方法下,客户端不用自己设置端口号,而全权交给操作系统进行分配。操作系统可以为每个应用程序分配互不冲突的端口号。这种动态机制,即使同一个客户端程序发起多个TCP连接,识别这些通信连接的部分数字也不会全部相同。动态端口号取值范围在49152到65535之间。</li></ul><h4 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h4><p>端口号由其使用的传输层协议决定。因此,不同的传输协议可以使用相同的端口号。例如,TCP与UDP使用同一个端口号,但使用目的各不相同。这是因为端口号上的处理会根据每个传输协议的不同而进行的。<br>数据到达IP层后,会先检查IP首部中的协议号,再传给相应协议的模块。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP是User Datagram Protocol 的缩写。<br>UDP是利用IP提供面向无连接的通信服务,不提供复杂的控制机制。<br>并且它是将应用程序发来的数据在收到的那一刻,立刻按照鸳鸯发送到网络上的一种机制。<br>即使是出现网络拥堵的情况下,UDP也无法进行流量控制等避免网络拥堵的行为。此外,传输途中即使出现丢包,UDP也不负责重发。甚至当出现包的到达顺序乱掉是也没有纠正的功能。</p><p>如果需要这些细节控制,那么不得不交有采用UDP的应用程序去处理。<br>由于UDP面向无连接,他可以随时发送数据。再加上UDP本身的处理既简单又高效,因此常用于以下几个方面:</p><ul><li>包总量较小的通信(DNS、SNMP等)</li><li>视频、音频等多媒体通信(即时通信)</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信(广播、多播)</li></ul><h4 id="UDP-首部"><a href="#UDP-首部" class="headerlink" title="UDP 首部"></a>UDP 首部</h4><p>如下图,除去数据的部分就是UDP的首部。<br>UDP的首部源端口号,目标端口号,包长和校验和组成。<br><img src="http://upload-images.jianshu.io/upload_images/1868951-80b631d1cdcf682a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP 首部.png"></p><ul><li>源端口号: 标识发送端端口号,字段长16位。该字段可以不设置,缺省值为0,可用于不需要返回的通信中。</li><li>目标端口号: 标识接收端端口号,字段长16位。</li><li>包长度: 指UDP首部的长度和数据的长度之和。为8位字节。</li><li>检验和: 校验和用来判断数据在传输过程中是否损坏。计算这个校验和的时候，不仅考虑源端口号和目标端口号，还要考虑 IP 首部中的源 IP 地址，目标 IP 地址和协议号（这些又称为 UDP 伪首部）。这是因为以上五个要素用于识别通信时缺一不可，如果校验和只考虑端口号，那么另外三个要素收到破坏时，应用就无法得知。这有可能导致不该收到包的应用收到了包，改收到包的应用反而没有收到。</li></ul><p>这个概念同样适用于即将介绍的 TCP 首部,但是TCP的校验和无法关闭。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>与UDP不同,TCP则”人如其名”,可以说是对”传输、发送、通信”进行”控制”的”协议”。<br>TCP充分实现了数据传输时各种控制功能,可以进行丢包是的重发控制,还可以对次序乱掉的分包进行顺序控制。<br>此外,TCP作为一种面向连接的协议,只有在确认通信对端存在时才会发送数据,从而可以控制通信流量的浪费。</p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>连接是指各种设备、线路,或网络中进行通信的两个应用程序为了相互传递消息而专有的、虚拟的通信线路,也叫做虚拟电路。</p><p>一旦建立了连接,进行通信的应用程序只是用这个虚拟的通信线路发送和接收数据,就可以保障信息的传输。应用程序不用顾虑IP网络上可能发生的各种问题,依然可以转发数据。<br>TCP则负责控制链接的建立、断开、保持等管理工作。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-680b8aff0c72ad73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="连接.png"></p><h4 id="TCP-首部"><a href="#TCP-首部" class="headerlink" title="TCP 首部"></a>TCP 首部</h4><p>和 UDP 首部相比，TCP 首部要复杂得多。解析这个首部的时间也相应的会增加，这是导致 TCP 连接的效率低于 UDP 的原因之一。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-560e4e1aa9e4964a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP 首部.png"></p><p>其中某些关键字段解释如下：</p><ul><li><p>序列号: 字段长32位。它表示发送数据的位置，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。</p></li><li><p>确认应答号: 字段长32位。它等于下一次应该接收到的数据的序列号。假设发送端的序列号为 s，发送数据的长度为 l，那么接收端返回的确认应答号也是 s + l。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。</p></li><li><p>数据偏移: TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示 TCP 首部的长度为 20 字节。</p></li><li><p>保留: 该字段为以后拓展时使用,其长度为4位。一般设置为0,但即使受到的包在该字段不为0,此包也不会被丢弃。</p></li><li><p>控制位: 改字段长度为 8 比特，分别有 8 个控制标志。依次是 CWR，ECE，URG，ACK，PSH，RST，SYN 和 FIN。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0eebc3e6bf64ab02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控制位.png"></p><p>CWR: 与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时,则通知对方已将拥塞窗口缩小。</p><p>ECE: 表示ECN-Echo。置为1会通知通信对方,从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE置为1。 </p><p>URG: 此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；</p><p>ACK: 此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；</p><p> PSH: 这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</p><p> RST: 这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</p><p> SYN: 表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；</p><p>FIN: 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</p><ul><li><p>窗口大小：该字段长16位。用于表示从应答号开始能够接受多少个 8 位字节。如果窗口大小为 0，可以发送窗口探测。</p></li><li><p>紧急指针: 仅在 URG 控制位为 1 时有效。表示紧急数据的末尾在 TCP 数据部分中的位置。通常在暂时中断通信时使用（比如输入 Ctrl + C）。</p></li><li><p>选项: 该字段长度最大为40字节,用于提高TCP的传输性能。选项字段尽量调整其为32位的整数倍。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1558ed07037c992a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选项.png"></p><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><p>TCP是面向连接的、传输可靠(保证数据正确性且保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。</p><p>　　TCP是一种流模式的协议，是面向连接的，也就是说，在连接持续的过程中，Socket 中收到的数据都是由同一台主机发出的（劫持什么的不考虑），因此，知道保证数据是有序的到达就行了，至于每次读取多少数据不关心。</p><p>　　TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。<br>　　UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。</p><p>　　关于TCP是一种流模式的协议，UDP是一种数据报模式的协议，这里要说明一下，TCP是面向连接的，也就是说，在连接持续的过程中，socket 中收到的数据都是由同一台主机发出的（劫持什么的不考虑），因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。</p><p>　　而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一 起，这样的数据是没有意义的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;终于来到了传输层,这个面试问的最多了😁&lt;/p&gt;
&lt;h3 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h3&gt;&lt;p&gt;TCP/IP中有两个具有代表性的传输层协议,分别为:&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
