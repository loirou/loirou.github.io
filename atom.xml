<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛洛爱吃肉</title>
  
  <subtitle>学海无涯,进一步有进一步的欢喜.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-27T02:28:02.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>loirou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/10/27/hello-world/"/>
    <id>http://yoursite.com/2017/10/27/hello-world/</id>
    <published>2017-10-27T02:28:02.000Z</published>
    <updated>2017-10-27T02:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重置mac网络设置</title>
    <link href="http://yoursite.com/2017/10/24/iOS/%E9%87%8D%E7%BD%AEmac%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%89%AF%E6%9C%AC%205/"/>
    <id>http://yoursite.com/2017/10/24/iOS/重置mac网络设置的副本 5/</id>
    <published>2017-10-24T03:22:00.000Z</published>
    <updated>2017-10-30T06:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1868951-a5e6281a5fdcf2a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-10-24 上午11.19.27.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1868951-a5e6281a5fdcf2a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
      <category term="tips" scheme="http://yoursite.com/categories/tips/"/>
    
    
      <category term="tips" scheme="http://yoursite.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>重置mac网络设置</title>
    <link href="http://yoursite.com/2017/10/24/tips/%E9%87%8D%E7%BD%AEmac%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%89%AF%E6%9C%AC%204/"/>
    <id>http://yoursite.com/2017/10/24/tips/重置mac网络设置的副本 4/</id>
    <published>2017-10-24T03:22:00.000Z</published>
    <updated>2017-10-30T06:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1868951-a5e6281a5fdcf2a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-10-24 上午11.19.27.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1868951-a5e6281a5fdcf2a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
      <category term="tips" scheme="http://yoursite.com/categories/tips/"/>
    
    
      <category term="tips" scheme="http://yoursite.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>重置mac网络设置</title>
    <link href="http://yoursite.com/2017/10/24/tips/%E9%87%8D%E7%BD%AEmac%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/10/24/tips/重置mac网络设置/</id>
    <published>2017-10-24T03:22:00.000Z</published>
    <updated>2017-10-30T06:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1868951-a5e6281a5fdcf2a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-10-24 上午11.19.27.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1868951-a5e6281a5fdcf2a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
      <category term="tips" scheme="http://yoursite.com/categories/tips/"/>
    
    
      <category term="tips" scheme="http://yoursite.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>iOS的内存管理</title>
    <link href="http://yoursite.com/2017/10/24/iOS/iOS%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/10/24/iOS/iOS的内存管理/</id>
    <published>2017-10-24T03:22:00.000Z</published>
    <updated>2017-11-01T03:04:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　在Objective-C 这种面向对象的语言里,内存管理是个重要的概念。要想用一门语言写出内存使用效率高而且又没有bug的代码,就得掌握其内存管理模型的种种细节。</p><p>　　一旦理解了这些规则,你就会发现,其实Objective-C 的内存管理没那么复杂,而且有了”自动引用计数”(Automatic Reference Counting,ARC)之后,就变得更为简单了。ARC几乎把所有内存管理事宜都交给编译器来决定,开发者只需关注于业务逻辑。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>　　Objective-C 中的内存管理,也就是引用计数。可以用开关房间的灯为例来说明引用计数机制。</p><p>　 　假设办公室的照明设备只有一个。上班进入办公室的人需要照明。所以要把灯打开。而对于下班离开办公室的人来说,已经不需要照明了,所以需要把灯关掉。若 是很多人上下班,每个人都开灯或是关灯,那么办公室的情况又将如何呢?最早下班离开的人如果关了灯,那就会让办公室还没走的所有人的将处于一片黑暗之中。</p><p>　　解决这一问题的办法是使办公室在还有至少1人的情况下保持开灯状态,而在无人时保持关灯状态。</p><p>　　(1)最早进入办公室的人开灯。</p><p>　　(2)之后进入办公室的人,需要照明。</p><p>　　(3)下班离开办公室的人,不需要照明。</p><p>　　(4)最后离开办公室的人关灯(此时已无人需要照明)。</p><p>　　为判断是否还有人在办公室里,这里导入计数功能来计算”需要照明的人数”。下面让我们来看一看这一功能是如何运作的。</p><p>　　(1)第一个人进入办公室,”需要照明的人数”加1。计数值从0变成了1,因此要开灯。</p><p>　　(2)第二个人进入办公室,”需要照明的人数”加1。计数值从1变成了2。</p><p>　　(3)每当有人下班离开办公室时,”需要照明的人数”就减1。如计数值从2变成了1。</p><p>　　(4)最后一个人下班离开办公室时,”需要照明的人数”就减1。计数值从1变成了0,因此要关灯。</p><p>　　这样就能在不需要照明的时候保持关灯状态。办公室中仅有的照明设备也得到了很好的管理。</p><p>　　在 Objective-C 中,”对象”相当于办公室的照明设备。在现实世界中办公室的照明设备只有一个,但在Objective-C的世界里,虽然计算机资源有限,但一台计算机可以同时处理好几个对象。</p><p>　　此外,”对象的使用环境”相当于上班进入办公室的人。虽然这里的”环境”有时也指在运行中的程序代码、变量、变量作用域、对象等,但在概念上就是使用对象的环境。上班进入办公室的人对办公室照明设备发出的动作,与 Objective-C 的对应关系如下:</p><p>对照明设备所做的动作    对OC对象所做的动作</p><table><thead><tr><th style="text-align:center">对照明设备所做的动作</th><th style="text-align:center">对OC对象所做的动作</th></tr></thead><tbody><tr><td style="text-align:center">开灯</td><td style="text-align:center">生成对象</td></tr><tr><td style="text-align:center">需要照明</td><td style="text-align:center">持有对象</td></tr><tr><td style="text-align:center">不需要照明</td><td style="text-align:center">释放对象</td></tr><tr><td style="text-align:center">关灯</td><td style="text-align:center">销毁对象</td></tr></tbody></table><p>　　使用引用计数功能计算需要照明的人数,使办公室的照明得到了很好的管理。同样,使用引用计数功能,对象也能得到很好的管理,这就是 Objective-C 的内存管理。</p><h3 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><p>　　首先来学习引用计数式内存管理的思考方式。看到”引用计数”这个名称,我们便会不自觉地联想到”某处有某物多少多少”而将注意力放在计数上。但其实,更加客观、正确的思考方式是:</p><ul><li>自己生成的对象,自己持有。</li><li>非自己生成的对象,自己也能持有。</li><li>不再需要自己持有的对象时释放。</li><li>非自己持有的对象无法释放。</li></ul><p>引用计数式的内存管理的思考方式仅此而已。按照这个思路,完全不必考虑引用计数。</p><p>　　上文出现了”生成”、”持有”、”释放”三个词。而在Objective-C内存管理中还要加上”废弃”一词。各个词表示的 Objective-C方法如表</p><table><thead><tr><th style="text-align:left">对象操作</th><th style="text-align:left">Objective-C方法</th></tr></thead><tbody><tr><td style="text-align:left">生成并持有对象</td><td style="text-align:left">alloc/new/copy/mutableCopy等方法</td></tr><tr><td style="text-align:left">持有对象</td><td style="text-align:left">retain方法</td></tr><tr><td style="text-align:left">释放对象</td><td style="text-align:left">release方法</td></tr><tr><td style="text-align:left">销毁对象</td><td style="text-align:left">dealloc方法</td></tr></tbody></table><p>　　这些有关Objective-C内存管理的方法,实际上不包括在该语言中,而是包含在Cocoa框架中用于OSX、iOS应用开发。</p><h3 id="ARC规则"><a href="#ARC规则" class="headerlink" title="ARC规则"></a>ARC规则</h3><p>　　“引用计数式内存管理”的本质部分在ARC中并没有改变。就像”自动引用计数”这个名称表示的那样,ARC只是自动地帮助我们处理”引用计数”的相关部分。</p><p>所有权修饰符</p><p>　　Objective-C编程为了处理对象,可将变量类型定义为id类型或各种对象类型。</p><p>　　所谓对象类型就是指向NSObject这样的Objective-C类的指针,例如”NSObject<em>“。id类型用于隐藏对象类型的类名部分,相当于C语言中常用的”void</em>“。</p><p>　　ARC有效时,id类型和对象类型同C语言其他类型不同,其类型上必须附加所有权修饰符。所有权修饰符一共有4种。</p><ul><li>__strong修饰符</li><li>__weak修饰符</li><li>__unsafe_unretained修饰符</li><li>__autoreleasing修饰符</li></ul><p><strong>__strong修饰符</strong></p><p>　　__strong修饰符是id类型和对象类型默认的所有权修饰符。也就是说,以下源代码中的id变量,实际上被附加了所有权修饰符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id obj = [[NSObject alloc]init];</div></pre></td></tr></table></figure><p>　　id和对象类型在没有明确指明所有权修饰符时,默认为__strong修饰符。上面的源代码与以下相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id __strong obj = [[NSObject alloc]init];</div></pre></td></tr></table></figure><p>　　该源代码在ARC无效时又该如何表述呢?</p><p>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* ARC无效 */</div><div class="line">id obj = [[NSObject alloc]init];</div></pre></td></tr></table></figure></p><p>　　该源代码一看则明,目前在表面上并没有任何变化。再看看下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">id __strong obj = [[NSObject alloc]init];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　此源代码明确指定了C语言的变量的作用域。ARC无效时,该源代码可记述如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* ARC无效 */</div><div class="line">&#123;</div><div class="line">id obj = [[NSObject alloc]init];</div><div class="line">[obj release];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　为了释放生成并持有的对象,增加了调用release方法的代码。该源代码进行的动作同先前ARC有效时的动作完全一样。</p><p>　　如此源代码所示,附有__strong修饰符的变量obj在超出其变量作用域时,即在该变量被废弃时,会释放其被赋予的对象。</p><p>　　如”<strong>strong”这个名称所示,</strong>strong修饰符表示对对象的”强引用”。持有强引用的变量在超出其作用域时被废弃,随着强引用的失效,引用的对象会随之释放。</p><p>　　下面关注一下源代码中关于对象的所有者的部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">id __strong obj = [[NSObject alloc]init];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　此源代码就是之前自己生成并持有对象的源代码,该对象的所有者如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">/*</div><div class="line">* 自己生成并持有对象 </div><div class="line">*/</div><div class="line">id __strong obj = [[NSObject alloc]init];</div><div class="line">/*</div><div class="line">* 因为变量obj为强引用</div><div class="line">* 所以自己持有对象 </div><div class="line">*/</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">* 因为变量obj超出其作用域,强引用失效,</div><div class="line">* 所以自动地释放自己持有的对象。</div><div class="line">* 对象的所有者不存在,因此废弃改对象。</div><div class="line">*/</div></pre></td></tr></table></figure><p>此外,对象的所有者和对象的生命周期是明确的。那么在取得非自己生成并持有的对象时又会如何呢?</p><p>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">id __strong obj = [NSMutableArray array];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>　　在NSMutableArray类的array类方法的源代码中取得非自己生成并持有的对象,具体如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">/*</div><div class="line">* 取得非自己生成并持有的对象</div><div class="line">*/</div><div class="line"></div><div class="line">id __strong obj = [NSMutableArray array];</div><div class="line"></div><div class="line">/*</div><div class="line">* 因为变量obj为强引用,</div><div class="line">* 所以自己持有对象</div><div class="line">*/</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">* 因为变量obj超出其作用域,强引用失效,</div><div class="line">* 所以自动地释放自己持有的对象 </div><div class="line">*/</div></pre></td></tr></table></figure><p>在这里对象的所有者和对象的生存周期也是明确的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">/*</div><div class="line">* 自己生成并持有的对象</div><div class="line">*/</div><div class="line"></div><div class="line">id __strong obj = [[NSObject alloc]init];</div><div class="line"></div><div class="line">/*</div><div class="line">* 因为变量obj为强引用,</div><div class="line">* 所以自己持有对象</div><div class="line">*/</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">* 因为变量obj超出其作用域,强引用失效,</div><div class="line">* 所以自动地释放自己持有的对象。</div><div class="line">* 对象的所有者不存在,因此废弃该对象。</div><div class="line">*/</div></pre></td></tr></table></figure><p>当然,附有__strong修饰符的变量之间可以相互赋值。</p><p>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">id __strong obj0 = [[NSObject alloc]init];</div><div class="line"></div><div class="line">id __strong obj1 = [[NSObject alloc]init];</div><div class="line"></div><div class="line">id __strong obj2 = nil;</div><div class="line"></div><div class="line">obj0 = obj1;</div><div class="line"></div><div class="line">obj2 = obj0;</div><div class="line"></div><div class="line">obj1 = nil;</div><div class="line"></div><div class="line">obj0 = nil;</div><div class="line"></div><div class="line">obj2 = nil;</div></pre></td></tr></table></figure></p><p>下面来看一下生成并持有对象的强引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">id __strong obj0 = [[NSObject alloc]init]; /* 对象A */</div><div class="line"></div><div class="line">/*</div><div class="line">* obj0 持有对象A的强引用</div><div class="line">*/</div><div class="line"></div><div class="line">id __strong obj1 = [[NSObject alloc]init];/* 对象B */</div><div class="line"></div><div class="line">/*</div><div class="line">* obj1 持有对象的B强引用</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">id __strong obj2 = nil;</div><div class="line"></div><div class="line">/*</div><div class="line">* obj2 不持有任何对象</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">obj0 = obj1;</div><div class="line"></div><div class="line">/*</div><div class="line">* obj0 持有由 obj1 赋值的对象B的强引用</div><div class="line">* 因为 obj0 被赋值,所以原先持有的对对象A的强引用失效。</div><div class="line">* 对象A的持有者不存在,因此废弃对象A。</div><div class="line">*</div><div class="line">* 此时,持有对象B的强引用的变量为</div><div class="line">* obj0 和 obj1</div><div class="line">*/</div><div class="line"></div><div class="line">obj2 = obj0;</div><div class="line"></div><div class="line">/*</div><div class="line">* obj2 持有由 obj0 赋值的对象B的强引用</div><div class="line">*</div><div class="line">* 此时,持有对象B的强引用的变量为</div><div class="line">* obj0 , obj1 和 obj2</div><div class="line">*/</div><div class="line"></div><div class="line">obj1 = nil;</div><div class="line"></div><div class="line">/*</div><div class="line">* 因为 nil 被赋予了 obj1 , 所以对对象B的强引用失效。</div><div class="line">*</div><div class="line">* 此时,持有对象B的强引用的变量为</div><div class="line">* obj0 和 obj2</div><div class="line">*/</div><div class="line"></div><div class="line">obj0 = nil;</div><div class="line"></div><div class="line">/*</div><div class="line">* 因为 nil 被赋予了 obj0 , 所以对对象B的强引用失效。</div><div class="line">*</div><div class="line">* 此时,持有对象B的强引用的变量为</div><div class="line">* obj2</div><div class="line">*/</div><div class="line"></div><div class="line">obj2 = nil;</div><div class="line"></div><div class="line">/*</div><div class="line">* 因为 nil 被赋予了 obj2 , 所以对对象B的强引用失效。</div><div class="line">* 对象B的所有者不存在,因此废弃对象B。</div><div class="line">*/</div></pre></td></tr></table></figure><p>通过上面这些不难发现,__strong修饰符的变量,不仅只在变量作用域中,在赋值上也能够正确地管理器对象的所有者。</p><p>　　当然,即便是 Objective-C类成员变量,也可以在方法参数上,使用附有__strong修饰符的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@interface Test : NSObject</div><div class="line">&#123;</div><div class="line">id __strong _obj; </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setObject:(id __strong)obj;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Test</div><div class="line">- (id)init</div><div class="line">&#123;</div><div class="line">self = [super init];</div><div class="line">return self; </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setObject:(id __strong)obj</div><div class="line">&#123;</div><div class="line">_obj = obj; </div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure><p>　　接着试着使用该类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">id __strong test = [[Test alloc]init];</div><div class="line">[test setObject:[NSObject alloc]init];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>　　该例中生成并持有对象的状态记录如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">id __strong test = [Test alloc]init];</div><div class="line">/*</div><div class="line">* test 持有Test对象的强引用</div><div class="line">*/</div><div class="line"></div><div class="line">[test setObject:[NSObject alloc]init];</div><div class="line"></div><div class="line">/*</div><div class="line">* Test 对象的_obj成员</div><div class="line">* 持有NSObject对象的强引用</div><div class="line">*/ </div><div class="line">&#125;</div><div class="line">/*</div><div class="line">* 因为test变量超出其作用域,强引用失效,</div><div class="line">* 所以自动释放Test对象</div><div class="line">* Test对象的所有者不存在,因此废弃该对象。</div><div class="line">*</div><div class="line">* 废弃Test对象的同时,</div><div class="line">* Test对象的 _obj成员也被废弃,</div><div class="line">* NSObject 对象的强引用失效</div><div class="line">* 自动释放NSObject对象</div><div class="line">* NSObject对象的所有者不存在,因此废弃该对象。</div><div class="line">*/</div></pre></td></tr></table></figure><p>　　像这样,无需额外工作便可以使用与类成员变量以及方法参数中。</p><p>　　另外,<strong>strong修饰符通后面要讲的</strong>weak修饰符和__autoreleasing修饰符一起,可以保证将附有这些修饰符的自动变量初始化为nil。</p><p>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id __strong obj0;</div><div class="line">id __weak obj1;</div><div class="line">id __autoreleasing obj2;</div></pre></td></tr></table></figure></p><p>　　以下源代码与上相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id __strong obj0 = nil;</div><div class="line">id __weak obj1 = nil;</div><div class="line">id __autoreleasing obj2 = nil;</div></pre></td></tr></table></figure><p>　　正如苹果宣称的那样,通过__strong修饰符,不必再次键入retain或者release,完美的满足了”引用计数式内存管理的思考方式”:</p><ul><li>自己生成的对象,自己所持有</li><li>非自己生成的对象,自己也能持有</li><li>不再需要自己持有的对象时释放</li><li>非自己持有的对象无法释放</li></ul><p>　 　前两项”自己生成的对象,自己持有”和””非自己生成的对象,自己也能持有”只需通过对带<strong>strong修饰符的变量赋值便可达成。通过废弃带 </strong>strong修饰符的变量(变量作用域结束或是成员变量所属对象废弃)或者对变量赋值,都可以做到”不在需要自己持有的对象时释放”。最后一项”非自 己持有的对象无法释放”,由于不必再次键入release,所以原本就不会执行。这些都满足于引用计数式内存管理的思考方式。</p><p>　　因为id类型和对象类型的所有权修饰符默认为<strong>strong修饰符,所以不需要写上”</strong>strong”。使ARC有效及简单的编程遵循了Objective-C内存管理的思考方式。</p><p><strong>__weak修饰符</strong></p><p>　　看起来好通过<strong>strong修饰符编译器就能够完美的进行内存管理。但是遗憾的是,仅通过</strong>strong修饰符是不能解决有些重大问题的。</p><p>　　这里提到的重大问题就是引用计数式内存管理中必然会发生的”循环引用”的问题。</p><p>　　例如,前面出现的带有__strong修饰符的成员变量在持有对象时,很容易发生循环引用问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@interface Test : NSObject</div><div class="line">&#123;</div><div class="line">id __strong _obj; </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setObject:(id __strong)obj;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Test</div><div class="line">- (id)init</div><div class="line">&#123;</div><div class="line">self = [super init];</div><div class="line">return self; </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setObject:(id __strong)obj</div><div class="line">&#123;</div><div class="line">_obj = obj; </div><div class="line">&#125;</div><div class="line">@end</div><div class="line">```　</div><div class="line"></div><div class="line">以下为循环引用。</div></pre></td></tr></table></figure><p>{<br>id test0 = [[Test alloc] init];<br>id test1 = [[Test alloc] init];<br>[test0 setObject:test1];<br>[test1 setObject:test0];<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">为便于理解,下面写出了生成并持有对象的状态。</div></pre></td></tr></table></figure></p><p>{<br>id test0 = [[Test alloc] init]; /<em> 对象A </em>/</p><p>/*</p><ul><li>test0 持有对象A的强引用<br>*/</li></ul><p>id test1 = [[Test alloc] init];/<em> 对象B </em>/</p><p>/*</p><ul><li>test1 持有对象B的强引用<br>*/</li></ul><p>[test0 setObject:test1];</p><p>/*</p><ul><li>Test对象A的_obj成员变量持有Test对象B的强引用<br>*</li><li>此时,持有Test对象B的强引用变量为</li><li>Test对象A的_obj和test1<br>*/</li></ul><p>[test1 setObject:test0];</p><p>/*</p><ul><li>Test对象B的_obj成员变量持有Test对象A的强引用<br>*</li><li>此时,持有Test对象A的强引用变量为</li><li>Test对象B的_obj和test0<br><em>/<br>}<br>/</em></li><li>因为test0变量超出其作用域,强引用失效,</li><li>所以自动释放Test对象A。</li><li></li><li>因为test1变量超出其作用域,强引用失效,</li><li>所以自动释放Test对象B。<br>*</li><li>此时,持有Test对象A的强引用的变量为</li><li>Test对象B的_obj。<br>*</li><li>此时,持有Test对象B的强引用的变量为</li><li>Test对象A的_obj。<br>*</li><li>发生内存泄漏。<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　循环引用容易发生内存泄漏。所谓内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。</div><div class="line"></div><div class="line">　　此代码的本意是赋予变量test0的对象A和赋予标量test1的对象B在超出期变量作用域时被释放,即在对象不被任何变量持有的状态下予以废弃。但是,循环引用使得对象不能被再次废弃。</div><div class="line"></div><div class="line">　　向下面这种情况,虽然只有一个对象,但在该对象持有其自身时,也会发生循环引用。</div></pre></td></tr></table></figure></li></ul><p>id test = [[Test alloc]init];<br>[test setObject:test];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　怎么样才能避免循环引用呢?看到__strong修饰符就会意识到了,既然有strong,就应该会有与之对应的weak。也就是说,__weak修饰符可以避免循环引用。</div><div class="line"></div><div class="line">　　__weak修饰符与__strong修饰符相反,提供弱引用。弱引用不能持有对象实例。我们来看下面的代码:</div></pre></td></tr></table></figure></p><p>id __weak obj = [[NSObject alloc]init];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　变量obj上附加了__weak修饰符。实际上如果编译以上代码,编译器会发出警告。</div><div class="line"></div><div class="line">　 　此源代码将自己生成并持有的对象赋值给附有__weak修饰符的变量obj。即变量obj持有对象的弱引用。因此,为了不以自己持有的状态来保存自己生 成并持有的对象,生成的对象会立即释放。编译器会发出警告。如果像下面这样,将对象赋值给附有__strong修饰符的变量之后再赋值给附有__weak 修饰符的变量,就不会发出警告了。</div></pre></td></tr></table></figure></p><p>{<br>id <strong>strong obj0 = [[NSObject alloc]init];<br>id </strong>weak obj1 = obj0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下面确认对象的持有状况。</div></pre></td></tr></table></figure></p><p>{<br>　/<em>　　</em> 自己生成并持有对象<br>　　*/ </p><p>　　id <strong>strong obj0 = [[NSObject alloc]init];<br>　　<br>　　/<em>　　</em> 因为obj0变量为强引用<br>　　<em> 所以自己持有对象　　</em>/<br>　　id </strong>weak obj1 = obj0;</p><p>　　/<em>　　</em> obj1变量持有生成对象的弱引用<br>　　<em>/<br>}<br>/</em></p><ul><li>因为obj0变量超出其作用域,强引用失效,</li><li>所以自动释放自己持有的对象</li><li>因为对象的所有者不存在,所以废弃该对象<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　因为带__weak修饰符的变量(即弱引用)不持有对象,所以在超出其变量作用域时,对象即被释放。如果像下面这样将先前发生循环引用的类成员变量改成附有__weak修饰符的成员变量的话,该现象便可避免。</div></pre></td></tr></table></figure></li></ul><p>@interface Test : NSObject<br>{<br>id __weak _obj;<br>}</p><ul><li>(void)setObject:(id __strong)obj;<br>@end<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">__weak修饰符还有一个优点。在持有某个对象的弱引用时,若该对象被废弃,则此弱引用将自动失效且处于nil被赋值的状态(空弱引用)。如以下代码所示。</div></pre></td></tr></table></figure></li></ul><p>　　id <strong>weak obj1 = nil;<br>{<br>id </strong>strong obj0 = [[NSObject alloc]init];<br>obj1 = obj0;<br>NSLog(@”A: %@”,obj1);<br>}<br>NSLog(@”B: %@”,obj1);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">此源代码执行结果如下:</div></pre></td></tr></table></figure></p><p>A: <nsobject: 0x753e180=""><br>B: (null)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下面我们来确认一下对象的持有情况,看看为什么得到这样的执行结果。</div></pre></td></tr></table></figure></nsobject:></p><p>id __weak obj1 = nil;<br>{<br>/*</p><ul><li>自己生成并持有对象<br>*/</li></ul><p>id __strong obj0 = [[NSObject alloc]init];</p><p>/*</p><ul><li>因为obj0变量为强引用</li><li>所以自己持有对象<br>*/</li></ul><p>obj1 = obj0;</p><p>/*</p><ul><li>obj1变量持有对象的弱引用<br>*/</li></ul><p>NSLog(@”A: %@”,obj1);</p><p>/*</p><ul><li>输出obj1变量持有的弱引用的对象<br>*/<br>}</li></ul><p>/*</p><ul><li>因为obj0变量超出其作用域,强引用失效</li><li>所以自动释放自己持有的对象</li><li>因为对象无持有者,所以废弃该对象<br>*</li><li>废弃对象的同时</li><li>持有该对象弱引用的obj1变量的弱引用失效,nil赋值给obj1。<br><em></em><br>*/</li></ul><p>NSLog(@”B: %@”,obj1);<br>/*</p><ul><li>输出赋值给obj1变量中的nil<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">像这样,使用__weak,修饰符可避免循环引用。通过检查附有__weak修饰符的变量是否为nil,可以判断被赋值的对象是否已被废弃。</div><div class="line"></div><div class="line">**__unsafe_unretained修饰符**</div><div class="line"></div><div class="line">　　__unsafe_unretained修饰符正如其名unsafe所示,是不安全的所有权修饰符。尽管ARC式的内存管理是编程器的工作,但附有__unsafe_unretained修饰符的变量不属于编译器的内存管理对象。这一点在使用时需要注意。</div></pre></td></tr></table></figure></li></ul><p>id __unsafe_unretained obj = [[NSObject alloc]init];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　该源代码将自己生成并持有的对象赋值给附有__unsafe_unretained修饰符的变量中。虽然使用了unsafe变量,但编译器不会忽略,而是给与适当的警告。</div><div class="line"></div><div class="line">　　附有__unsafe_unretained修饰符的变量同附有__weak修饰符的变量一样,因为自己生成并持有的对象不能继续为自己所有,所以生成的对象会立即被释放。到这里,__unsafe_unretained修饰符和__weak修饰符是一样的,下面我们来看看源代码的差异。</div></pre></td></tr></table></figure></p><p>id <strong>unsafe_unretained obj1 = nil;<br>{<br>id </strong>strong obj0 = [[NSObject alloc]init];<br>obj1 = obj0;<br>NSLog(@”A: %@”,obj1);<br>}</p><p>NSLog(@”B: %@”,obj1);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">该源代码的执行结果为:</div></pre></td></tr></table></figure></p><p>A: <nsobject: 0x753e180=""><br>B: <nsobject: 0x753e180=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　</div><div class="line">我们还像以前那样,通过确认对象的持有情况来理解发生了什么。</div></pre></td></tr></table></figure></nsobject:></nsobject:></p><p>id __unsafe_unretained obj1 = nil;<br>{<br>/*</p><ul><li>自己生成并持有对象<br>*/</li></ul><p>id __strong obj0 = [[NSObject alloc]init];</p><p>/*</p><ul><li>因为obj0变量为强引用</li><li>所以自己持有对象<br>*/</li></ul><p>obj1 = obj0;</p><p>/*</p><ul><li>虽然 obj0 变量赋值给 obj1</li><li>但是obj1 变量既不持有对象的强引用也不持有对象的弱引用<br>*/</li></ul><p>NSLog(@”A: %@”,obj1);</p><p>/*</p><ul><li>输出obj1变量表示的对象<br>*/<br>}</li></ul><p>/*</p><ul><li>因为obj0变量超出其作用域,强引用失效</li><li>所以自动释放自己持有的对象</li><li>因为对象无持有者,所以废弃该对象。<br>*/</li></ul><p>NSLog(@”B: %@”,obj1);<br>/*</p><ul><li>输出赋值给obj1变量表示的对象</li><li></li><li>obj1变量表示的对象</li><li>已经被废弃(悬垂指针)!</li><li>错误访问!<br>*/ <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　也就是说,最后一行的NSLog只是碰巧正常运行而已。虽然访问了已经被废弃的对象,但应用程序在个别运行状态下才会崩溃。</div><div class="line"></div><div class="line">　　在使用__unsafe_unretained修饰符时,赋值给附有__strong修饰符的变量时有必要确保被复制的对象确实存在。</div><div class="line"></div><div class="line">**__autoreleasing修饰符**</div><div class="line"></div><div class="line">　　ARC有效时不能使用autorelease方法,也不能使用NSAutoreleasePool类。这样一来,虽然autorelease无法直接使用,但实际上,ARC有效时autorelease功能是起作用的。</div><div class="line"></div><div class="line">　　ARC无效时会像下面这样来使用:</div></pre></td></tr></table></figure></li></ul><p>　/<em> ARC无效 </em>/<br>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc]init];<br>id obj = [[NSObject alloc]init];<br>[obj autorelease];<br>[pool drain];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　ARC有效时,该源代码也能写成下面这样:</div></pre></td></tr></table></figure></p><p>@autoreleasepool {<br>id __autoreleasing obj = [[NSObject alloc]init];<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　指定&quot;@autoreleasepool块&quot;来替代&quot;NSAutoreleasePool类对象生成、持有以及废弃&quot;这一范围。</div><div class="line"></div><div class="line">　　另外ARC有效时,要通过将对象赋值给附加了__autoreleasing修饰符的变量来替代调用autorelease方法。对象赋值给附有__autoreleasing修饰符的变量等价于ARC无效时调用对象的autorelease方法,即对象被注册到autoreleasepool中。</div><div class="line"></div><div class="line">　　也就是说可以理解为,在ARC有效时,用@autoreleasepool块替代NSAutoreleasePool类,用附有__autoreleasing修饰符的变量替代autorelease方法。</div><div class="line"></div><div class="line">　　但是显示地附加__autoreleasing修饰符同显式的附加__strong修饰符一样罕见。</div><div class="line"></div><div class="line">　　取得非自己生成并持有的对象时,如同一下源代码,虽然可以使用alloc/new/copy/mutableCopy以外的方法来取得对象,但该对象已被注册到了autoreleasepool。这同在ARC无效时取得调用了autorelease方法的对象是一样的。这是由于编译器会检查方法名是否以alloc/new/copy/mutableCopy开始,如果不是则自动将返回值的对象注册到autoreleasepool。另外init方法返回值的对象不注册到autoreleasepool。</div></pre></td></tr></table></figure></p><p>@autoreleasepool {<br>id __strong obj = [NSMutableArray array];<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　我们再来看看该源代码中对象的所有状况。</div></pre></td></tr></table></figure></p><p>@autoreleasepool {<br>/*</p><ul><li>取得非自己生成并持有的对象<br>*/</li></ul><p>id __strong obj = [NSMutableArray array];</p><p>/*</p><ul><li>因为变量obj为强引用</li><li>所以自己持有对象<br>*</li><li>并且该对象</li><li>由编译器判断其方法名</li><li>自动注册到autoreleasepool<br><em>/<br>}<br>/</em></li><li>因为变量obj超出其作用域,强引用失效,</li><li>所以自动释放自己持有的对象<br>*</li><li>同时随着@autoreleasepool块的结束</li><li>注册到autoreleasepool中的</li><li>所有对象被自动释放<br>*</li><li>因为对象的所有者不存在,所以废弃对象<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　</div><div class="line">　　像这样不使用__autoreleasing修饰符也能使对象注册到autoreleasepool。以下为取得非自己生成并持有对象时被调用方法的源代码示例。</div></pre></td></tr></table></figure></li></ul><ul><li><p>(id)array<br>{<br>return [[NSMutableArray alloc]init];<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　该源代码也没有使用__autoreleasing修饰符,可写成以下形式。</div></pre></td></tr></table></figure></li><li><p>(id)array<br>{<br>id obj = [[NSMutableArray alloc]init]<br>return obj;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　因为没有显式指定所有权修饰符,所以id obj同附有__strong修饰符的id _strong obj是完全一样的。由于return使得对象变量超出期作用域,所以该强引用对应的自己持有的对象会被自动释放,但该对象作为函数的返回值,编译器会自动将其注册到autoreleasepool。</div><div class="line"></div><div class="line">　　以下为使用__weak修饰符的例子。虽然__weak修饰符是为了避免循环引用而使用的,但在访问附有__weak修饰符的变量时,实际上必定要访问注册到autoreleasepool的对象。</div></pre></td></tr></table></figure></li></ul><p>　id __weak obj1 = obj0;<br>NSLog(@”class = %@ “,[obj1 class]);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">以下源代码与此相同。</div></pre></td></tr></table></figure></p><p>id <strong>weak obj1 = obj0;<br>id </strong>autoreleasing tmp = obj1;<br>NSLog(@”class = %@ “,[tmp class]);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">为什么在访问__weak修饰符的变量时必须要访问注册到autoreleasepool的对象呢?这是因为__weak修饰符只持有对象的弱引用,而在访问引用对象的过程中,该对象有可能被废弃。如果把要访问的对象注册到autoreleasepool中,那么在@autoreleasepool块结束之前都能确保该对象存在。因此,在使用附有__weak修饰符的变量时就必定要使用注册到autoreleasepool中的对象。</div><div class="line"></div><div class="line">　　最后一个非显式地使用__autoreleasing修饰符的例子,同前面讲述的id obj和id __strong obj完全一样。那么id的指针id *obj又如何呢?可以由id __strong obj的例子类推出id __strong *obj吗? 其实,推出来的是id __autoreleasing *obj。同样的,对象的指针NSObject **obj便成为了NSObject* __autoreleasing *obj。</div><div class="line"></div><div class="line">　　像这样,id的指针或对象的指针在没有显式的指定时会被附加上__autoreleasing修饰符。</div><div class="line"></div><div class="line">　　比如,为了得到详细的错误信息,经常会在方法的参数中传递NSError对象的指针,而不是函数返回值。Cocoa框架中,大多数方法也是使用这种方法,如NSString的stringWithContentsOfFile:encoding:error类方法等。使用该方式的源代码如下所示。</div></pre></td></tr></table></figure></p><p>NSError *error = nil;<br>BOOL result = [obj performOperationWithError:&amp;error];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">该方法的声明为:</div></pre></td></tr></table></figure></p><ul><li><p>(BOOL) performOperationWithError:(NSError **)error;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">同前面讲述的一样,id的指针或对象的指针会默认附加上__autoreleasing修饰符,所以等同于以下源代码。</div></pre></td></tr></table></figure></li><li><p>(BOOL) performOperationWithError:(NSError <em> __autoreleasing</em>)error;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">参数中持有对象指针的方法,虽然为响应其执行结果,需要生成NSError类对象,但也必须符合内存管理的思考方式。</div><div class="line"></div><div class="line">　　作为alloc/new/copy/mutableCopy方法返回值取得的对象是自己生成并持有的,其他情况下便是取得非自己生成并持有的对象。因此,使用附有__autoreleasing修饰符的变量作为对象取得参数,与出alloc/new/copy/mutableCopy外其他方法的返回值取得对象完全一样,都会注册到autoreleasepool,并取得非自己生成并持有的对象。</div><div class="line"></div><div class="line">　　比如,performOperationWithError方法的源代码应该是下面这样:</div></pre></td></tr></table></figure></li><li><p>(BOOL) performOperationWithError:(NSError <em> __autoreleasing</em>)error{<br>/<em> 错误发生 </em>/<br>*error = [[NSError alloc]initWithDomain:MyAppDomain code:errorCode userInfo:nil];</p></li></ul><p>return NO;</p><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">因为声明为 NSError *__autoreleasing * 类型的error作为*error被赋值,所以能够返回注册到autoreleasepool中的对象。</div><div class="line"></div><div class="line">然而,下面的源代码会产生编译器错误。</div></pre></td></tr></table></figure></p><p>NSError <em>error = nil;<br>NSError *</em>pError = &error;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">　　赋值给对象指针时,所有权修饰符必须一致。</div><div class="line"></div><div class="line">　　此时,对象指针必须附加__strong修饰符</div></pre></td></tr></table></figure></p><p>NSError <em>error = nil;<br>NSError </em> __strong *pError = &error;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* 编译正常 */</div><div class="line">当然对于其他所有权修饰符也是一样。</div></pre></td></tr></table></figure></p><p>NSError <strong>weak <em>error = nil;<br>NSError </em></strong>weak <em>pError = &error;<br>/</em> 编译正常 <em>/<br>NSError __unsafe_unretained </em>unsafeError = nil;<br>NSError <em>__unsafe_unretained </em>pUnsafeError = &unsafeError;<br>/<em> 编译正常 </em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">前面的方法参数中使用了附有__autoreleasing修饰符的对象指针类型。</div></pre></td></tr></table></figure></p><ul><li>(BOOL) performOperationWithError:(NSError <em> __autoreleasing</em>)error;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然而调用方法却使用了附有__strong修饰符的对象指针类型。</div></pre></td></tr></table></figure></li></ul><p>NSError __strong *error = nil;<br>BOOL result = [obj performOperationWithError:&amp;error];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">对象指针赋值时,其所有权修饰符必须一致,但为什么该源代码没有警告就顺利通过编译了呢?实际上,编译器自动地将该源代码转化成了下面这种形式。</div><div class="line"></div><div class="line">```　　</div><div class="line">NSError __strong *error = nil;</div><div class="line">NSError __autoreleasing *tmp = error;</div><div class="line">BOOL result = [obj performOperationWithError:&amp;tmp];　</div><div class="line">error = tmp;</div></pre></td></tr></table></figure></p><p>当然也可以显式的指定方法参数中对象的指针类型的所有权修饰符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL) performOperationWithError:(NSError * __strong*)error;</div></pre></td></tr></table></figure><p>　　<br>向该源代码声明的一样,对象不注册到autoreleasepool也能够传递。但是前面也说过,只有作为alloc/new/copy/mutableCopy方法的返回值而取得对象时,能够自己生成并持有对象。其他情况即为”取得非自己生成并持有的对象”,这些务必牢记。为了在使用参数取得对象时,贯彻内存管理的思考方式,我们要将参数声明为附有__autoreleasing修饰符的对象指针类型。</p><p>　　另外,虽然可以非显式的指定<strong>autoreleasing修饰符,但在显式的指定</strong>autorelesing修饰符时,必须注意对象变量要为自动变量(包括局部变量、函数以及方法参数)。</p><p>　　下面,我们换个话题,详细了解下@autoreleasepool。如以下源代码所示,ARC无效时,可将NSAutoreleasepool对象嵌套使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* ARC无效 */</div><div class="line">NSAutoreleasePool *pool0 = [[NSAutoreleasePool alloc]init];</div><div class="line">NSAutoreleasePool *pool1 = [[NSAutoreleasePool alloc]init];</div><div class="line">NSAutoreleasePool *pool2 = [[NSAutoreleasePool alloc]init];</div><div class="line">id obj = [[NSObject alloc]init];</div><div class="line">[obj autorelease];</div><div class="line">[pool2 drain];</div><div class="line">[pool1 drain];</div><div class="line">[pool0 drain];</div><div class="line">``` </div><div class="line">　　</div><div class="line">同样的,@autoreleasepool块也可以嵌套使用。</div></pre></td></tr></table></figure><p>@autoreleasepool {<br>@autoreleasepool {<br>@autoreleasepool {<br>id __autoreleasing obj = [[NSObject alloc]init];<br>}<br>}<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">比如 ,在iOS应用程序模板中,向下面的main函数一样,@autoreleasepool块包含了全部程序。</div></pre></td></tr></table></figure></p><p>int main(int argc, char * argv[]) {<br>@autoreleasepool {<br>return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));<br>}<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSRunLoop等实现不论ARC有效还是无效,均能够随时释放注册到autoreleasepool中的对象。</div><div class="line"></div><div class="line">　　另外,即使ARC无效时,@autoreleasepool块也能够使用,如以下所示:</div></pre></td></tr></table></figure></p><p>@autoreleasepool{<br>id obj= [[NSObject alloc]init];<br>[obj autorelease];<br>}<br>```</p><p>因为autoreleasepool范围以块级源代码表示,提高了程序的可读性,所以无论ARC 是否有效都推荐使用@autoreleasepool块,另外调试用的非公开函数_obj_autoreleasePoolPrint()都可使用,利用这一函数可有效地帮助我们调试注册到autoreleasepool上的对象。</p><p><strong>规则</strong></p><p>在ARC有效的情况下,编译源代码,必须遵循一定的规则。下面就是具体的ARC规则:</p><ul><li>不能使用retain/release/retain/autorelease</li><li>不能使用NSAllocateObject/NSDeallocateObject</li><li>须遵守内存管理的方法命名规则</li><li>不要显示调用dealloc</li><li>使用@autoreleasepool块替代NSAutoreleasePool</li><li>不能使用区域(NSZone)</li><li>对象型变量不能作为C语言结构体(struct/union)的成员</li><li>通过”__bridge” 显式转换”id”和”void*”</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　在Objective-C 这种面向对象的语言里,内存管理是个重要的概念。要想用一门语言写出内存使用效率高而且又没有bug的代码,就得掌握其内存管理模型的种种细节。&lt;/p&gt;
&lt;p&gt;　　一旦理解了这些规则,你就会发现,其实Objective-C 的内存管理没那么复杂,而且有
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>缓存网易云音乐</title>
    <link href="http://yoursite.com/2017/09/28/tips/%E7%BC%93%E5%AD%98%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    <id>http://yoursite.com/2017/09/28/tips/缓存网易云音乐/</id>
    <published>2017-09-28T08:33:00.000Z</published>
    <updated>2017-10-30T06:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1868951-1ba8f4f4aea735d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1868951-1ba8f4f4aea735d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
      <category term="tips" scheme="http://yoursite.com/categories/tips/"/>
    
    
      <category term="tips" scheme="http://yoursite.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>日期小demo</title>
    <link href="http://yoursite.com/2017/09/28/iOS/%E6%97%A5%E6%9C%9F%E5%B0%8Fdemo/"/>
    <id>http://yoursite.com/2017/09/28/iOS/日期小demo/</id>
    <published>2017-09-28T08:26:00.000Z</published>
    <updated>2017-10-31T09:56:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>有个项目需求是做个在日期上选择的,就是这种:<br><img src="http://upload-images.jianshu.io/upload_images/1868951-f9743a36922cc91e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需求"></p><p>网上看了几个日期的demo都太厚重了,移植起来太麻烦,然后打算自己写。</p><p>就先写个简化的demo看看,主要有几个关键点:</p><ul><li>首先要根据当前日期获取这个月有几天</li><li>然后判断这个月份第一天是周几</li><li>再根据上面两个数据在合理的位置显示数据</li><li>还要记录下当前的日期方便切换月份</li><li>如果调接口的话其实根据后台给数据比对下对应的日期展示数据即可</li></ul><p>其中有一个容易迷糊的是获取的星期天是第一天,下标是1<br>所以我们的数组是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_weekdays = [NSArray arrayWithObjects: [NSNull null],@&quot;星期日&quot;, @&quot;周一&quot;, @&quot;周二&quot;, @&quot;周三&quot;, @&quot;周四&quot;, @&quot;周五&quot;, @&quot;周六&quot;, nil];</div></pre></td></tr></table></figure><p>好吧,看下写出来的效果:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-05c9fbf48e14ddd7.gif?imageMogr2/auto-orient/strip" alt="demo"></p><p>总的来说没什么难度,就是要熟悉下关于日期的api.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//3.获取这个月总天数,填充数据源</div><div class="line"> NSRange range = [calendar rangeOfUnit:NSCalendarUnitDay inUnit:NSCalendarUnitMonth forDate:self.currentDate];</div><div class="line"> NSUInteger numberOfDaysInMonth = range.length;</div><div class="line"> NSLog(@&quot;%lu&quot;, (unsigned long)numberOfDaysInMonth);</div><div class="line"> </div><div class="line"> //4.获取这个月的第一天为周几</div><div class="line"> NSCalendar *cal = [NSCalendar currentCalendar];</div><div class="line"> NSDateComponents *comps = [cal</div><div class="line">                            components:NSCalendarUnitYear | NSCalendarUnitMonth</div><div class="line">                            fromDate:self.currentDate];</div><div class="line"> lastMonthComps.day = 1;</div><div class="line"> NSDate *firstDay = [cal dateFromComponents:comps];</div><div class="line"> NSCalendarUnit calendarUnit = NSCalendarUnitWeekday;</div><div class="line"> NSDateComponents *firsComponents = [cal components:calendarUnit fromDate:firstDay];</div><div class="line"> </div><div class="line"> NSLog(@&quot;%@&quot;, [_weekdays objectAtIndex:firsComponents.weekday]);</div></pre></td></tr></table></figure><p><a href="https://github.com/loirou/datePicker" target="_blank" rel="external">demo完整代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有个项目需求是做个在日期上选择的,就是这种:&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1868951-f9743a36922cc91e.png?imageMogr2/auto-orient/str
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS混合开发研究</title>
    <link href="http://yoursite.com/2017/09/15/iOS/iOS%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2017/09/15/iOS/iOS混合开发研究/</id>
    <published>2017-09-15T01:41:00.000Z</published>
    <updated>2017-10-31T09:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/oc-bowen/p/5423902.html" target="_blank" rel="external">iOS-Hybrid</a><br><a href="http://www.jianshu.com/p/b88944250b25" target="_blank" rel="external">写给移动开发者的 React Native 指南</a><br><a href="http://eteng-wiki.github.io/HAC-WIKI/buildEnv/" target="_blank" rel="external">Cordova教程</a><br><a href="http://www.chongchonggou.com/g_41684204.html" target="_blank" rel="external">在已有 Xcode 项目中 加入Cordova框架</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/oc-bowen/p/5423902.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS-Hybrid&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC与JS交互</title>
    <link href="http://yoursite.com/2017/09/11/iOS/OC%E4%B8%8EJS%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2017/09/11/iOS/OC与JS交互/</id>
    <published>2017-09-11T09:09:00.000Z</published>
    <updated>2017-10-31T09:39:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/markstray/p/5757828.html" target="_blank" rel="external"><a href="http://www.cnblogs.com/markstray/p/5757828.html" target="_blank" rel="external">OC与JS交互前言</a></a></p><p><a href="http://www.cnblogs.com/markstray/p/5757238.html" target="_blank" rel="external"><a href="http://www.cnblogs.com/markstray/p/5757238.html" target="_blank" rel="external">OC与JS交互之UIWebView</a></a></p><p><a href="http://www.cnblogs.com/markstray/p/5757244.html" target="_blank" rel="external"><a href="http://www.cnblogs.com/markstray/p/5757244.html" target="_blank" rel="external">OC与JS交互之WebViewJavascriptBridge</a></a></p><p><a href="http://www.cnblogs.com/markstray/p/5757255.html" target="_blank" rel="external"><a href="http://www.cnblogs.com/markstray/p/5757255.html" target="_blank" rel="external">OC与JS交互之JavaScriptCore</a></a></p><p><a href="http://www.cnblogs.com/markstray/p/5757264.html" target="_blank" rel="external"><a href="http://www.cnblogs.com/markstray/p/5757264.html" target="_blank" rel="external">OC与JS交互之WKWebView</a></a></p><p><a href="http://www.brighttj.com/ios/ios-user-safari-debug-webview.html" target="_blank" rel="external">使用safari对webview进行调试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/markstray/p/5757828.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/markstray/p/5757
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS如何使屏幕一直保持亮屏？</title>
    <link href="http://yoursite.com/2017/08/23/iOS/iOS%E5%A6%82%E4%BD%95%E4%BD%BF%E5%B1%8F%E5%B9%95%E4%B8%80%E7%9B%B4%E4%BF%9D%E6%8C%81%E4%BA%AE%E5%B1%8F%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/08/23/iOS/iOS如何使屏幕一直保持亮屏？/</id>
    <published>2017-08-23T08:05:00.000Z</published>
    <updated>2017-10-31T09:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>播放视频页面</p><p>加入一行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UIApplicationsharedApplication]setIdleTimerDisabled:YES];</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;播放视频页面&lt;/p&gt;
&lt;p&gt;加入一行代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UIButton点击状态</title>
    <link href="http://yoursite.com/2017/08/23/iOS/UIButton%E7%82%B9%E5%87%BB%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2017/08/23/iOS/UIButton点击状态/</id>
    <published>2017-08-23T08:03:00.000Z</published>
    <updated>2017-10-31T09:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>类似问题 <a href="http://www.cocoachina.com/bbs/read.php?tid-254503-page-1.html" target="_blank" rel="external">http://www.cocoachina.com/bbs/read.php?tid-254503-page-1.html</a></p><p>需求:在UIControlStateNormal 和selected 两种状态下文字颜色分别为白色和红色<br>每次点击的时候把这个按钮的isSelected设为yes 或no<br>当我当前选中的按钮为buttonA时，再点击这个按钮buttonA，<br>按钮的颜色会在点击的时候变回白色，松开鼠标又变回了红色</p><p>找到解决方法了,在这个地方<a href="http://commandshift.co.uk/blog/2013/04/16/uibutton-control-states/" target="_blank" rel="external">http://commandshift.co.uk/blog/2013/04/16/uibutton-control-states/</a></p><p>原来UIControlStateSelected ｜ UIControlStateHighlighted 和 UIControlStateSelected 是两种不同的状态, 在isSelected状态时再点击按钮就变成了UIControlStateSelected ｜ UIControlStateHighlighted的状态.我前面一直自顾自以为前面的状态包含了后面这种状态,都没想到把两个方法放在一起试.总结一下方法就是,设置成在这两种情况下的颜色都为红色,问题解决. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[self.button setBackgroundImage:normal forState:UIControlStateNormal];</div><div class="line">[self.button setBackgroundImage:highlighted forState:UIControlStateHighlighted];</div><div class="line">[self.button setBackgroundImage:selected forState:UIControlStateSelected];</div><div class="line">[self.button setBackgroundImage:selectedHighlighted forState:UIControlStateSelected | UIControlStateHighlighted];</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类似问题 &lt;a href=&quot;http://www.cocoachina.com/bbs/read.php?tid-254503-page-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cocoachina.com/bbs
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS在控制器中监听是否点击Home键以及重新进入界面的方法</title>
    <link href="http://yoursite.com/2017/07/31/iOS/iOS%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E7%9B%91%E5%90%AC%E6%98%AF%E5%90%A6%E7%82%B9%E5%87%BBHome%E9%94%AE%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%96%B0%E8%BF%9B%E5%85%A5%E7%95%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/07/31/iOS/iOS在控制器中监听是否点击Home键以及重新进入界面的方法/</id>
    <published>2017-07-31T02:18:00.000Z</published>
    <updated>2017-10-31T09:36:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一步:<br>创建2个NSNotificationCenter监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillResignActive:)</div><div class="line">name:UIApplicationWillResignActiveNotification object:nil]; //监听是否触发home键挂起程序.</div><div class="line">    </div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationDidBecomeActive:)</div><div class="line">name:UIApplicationDidBecomeActiveNotification object:nil]; //监听是否重新进入程序程序.</div></pre></td></tr></table></figure></p><p>第二步:<br>实现2个NSNotificationCenter所触发的事件方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)applicationWillResignActive:(NSNotification *)notification</div><div class="line"></div><div class="line">&#123;</div><div class="line">    printf(&quot;按理说是触发home按下\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidBecomeActive:(NSNotification *)notification</div><div class="line">&#123;</div><div class="line">    printf(&quot;按理说是重新进来后响应\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注: 在home键触发后,AppDelegate响应的方法为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    /*</div><div class="line">     Use this method to release shared resources, save user data, invalidate timers, </div><div class="line"></div><div class="line">     and store enough application state information to restore your application to its current state in case it is terminated later.</div><div class="line">     If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</div><div class="line">     */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一步:&lt;br&gt;创建2个NSNotificationCenter监听&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div cl
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS获取Label高度的几种方法与对比</title>
    <link href="http://yoursite.com/2017/07/31/iOS/iOS%E8%8E%B7%E5%8F%96Label%E9%AB%98%E5%BA%A6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2017/07/31/iOS/iOS获取Label高度的几种方法与对比/</id>
    <published>2017-07-31T02:18:00.000Z</published>
    <updated>2017-10-31T09:46:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在设置 UILabel 的 Frame 高度时，不能简单的设置为字体的 font size。否则会将字体的一部分裁剪掉。因为 UILabel 在不同的字体设置下，对 Frame 的高度要求也不一样，大多数情况下都比Font的高度设置要高一些。</p><h4 id="一、sizeThatFits"><a href="#一、sizeThatFits" class="headerlink" title="一、sizeThatFits"></a>一、sizeThatFits</h4><p>使用 view 的 sizeThatFits 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// return &apos;best&apos; size to fit given size. does not actually resize view. Default is return existing view size</div><div class="line">- (CGSize)sizeThatFits:(CGSize)size;</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UILabel *testLabel = [[UILabel alloc] init];</div><div class="line">testLabel.font = [UIFont systemFontOfSize:30];</div><div class="line">testLabel.text = @&quot;Today is a fine day&quot;;</div><div class="line">CGSize size = [testLabel sizeThatFits:CGSizeMake(200, 30)];</div><div class="line">NSLog(@&quot;size = %@&quot;, NSStringFromCGSize(size));</div></pre></td></tr></table></figure><p>输出: <strong>size = {246.33333333333334, 36}</strong></p><h4 id="二、sizeToFit"><a href="#二、sizeToFit" class="headerlink" title="二、sizeToFit"></a>二、sizeToFit</h4><p>使用 view 的 sizeToFit 方法。</p><p>注意：sizeToFit 会改变 view 原来的 bounds，而 sizeThatFits 不会。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// calls sizeThatFits: with current view bounds and changes bounds size.</div><div class="line">- (void)sizeToFit;</div></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UILabel *testLabel = [[UILabel alloc] init];</div><div class="line">testLabel.font = [UIFont systemFontOfSize:30];</div><div class="line">testLabel.text = @&quot;Today is a fine day&quot;;</div><div class="line">[testLabel sizeToFit];</div><div class="line">NSLog(@&quot;size = %@&quot;, NSStringFromCGSize(testLabel.frame.size));</div></pre></td></tr></table></figure><p>输出：<strong>size = {246.33333333333334, 36}</strong></p><h4 id="三、sizeWithAttributes"><a href="#三、sizeWithAttributes" class="headerlink" title="三、sizeWithAttributes"></a>三、sizeWithAttributes</h4><p>使用 NSString 的 sizeWithAttributes 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (CGSize)sizeWithAttributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attrs NS_AVAILABLE(10_0, 7_0);</div></pre></td></tr></table></figure><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString *text = @&quot;Today is a fine day&quot;;</div><div class="line">UIFont *font = [UIFont systemFontOfSize:30];</div><div class="line">CGSize size = [text sizeWithAttributes:@&#123;</div><div class="line">           NSFontAttributeName : font</div><div class="line">           &#125;];</div><div class="line">NSLog(@&quot;size = %@&quot;, NSStringFromCGSize(size));</div></pre></td></tr></table></figure><p>输出：<strong>size = {246.3134765625, 35.80078125}</strong></p><h4 id="四、boundingRectWithSize"><a href="#四、boundingRectWithSize" class="headerlink" title="四、boundingRectWithSize"></a>四、boundingRectWithSize</h4><p>使用 NSString 的 boundingRectWithSize 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (CGRect)boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attributes context:(nullable NSStringDrawingContext *)context NS_AVAILABLE(10_11, 7_0);</div></pre></td></tr></table></figure><p>参数的意义：<br>1、size<br>限制最大宽高, 虽然是自适应，但是需要限制最大的宽度和高度。<br>2、options<br>类型为 NSStringDrawingOptions，用来指明绘制字符串时的渲染选项。<br>各个选项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSInteger, NSStringDrawingOptions) &#123;</div><div class="line"> // The specified origin is the line fragment origin, not the base line origin</div><div class="line"> // 整个文本将以每行组成的矩形为单位计算整个文本的尺寸</div><div class="line"> NSStringDrawingUsesLineFragmentOrigin = 1 &lt;&lt; 0, </div><div class="line"> </div><div class="line"> // Uses the font leading for calculating line heights</div><div class="line"> // 使用字体的行间距来计算文本占用的范围，即每一行的底部到下一行的底部的距离计算</div><div class="line"> NSStringDrawingUsesFontLeading = 1 &lt;&lt; 1, </div><div class="line"> </div><div class="line"> // Uses image glyph bounds instead of typographic bounds</div><div class="line"> // 将文字以图像符号计算文本占用范围，而不是排版的边界</div><div class="line"> NSStringDrawingUsesDeviceMetrics = 1 &lt;&lt; 3,</div><div class="line"> </div><div class="line"> // Truncates and adds the ellipsis character to the last visible line if the text doesn&apos;t fit into the bounds specified.</div><div class="line"> // Ignored if NSStringDrawingUsesLineFragmentOrigin is not also set.</div><div class="line"> // 如果文本内容超出指定的矩形限制，文本将被截去并在最后一个字符后加上省略号。</div><div class="line"> // 如果 NSStringDrawingUsesLineFragmentOrigin 没有设置，则该选项不生效</div><div class="line"> NSStringDrawingTruncatesLastVisibleLine NS_ENUM_AVAILABLE(10_5, 6_0) = 1 &lt;&lt; 5, </div><div class="line">&#125; NS_ENUM_AVAILABLE(10_0, 6_0);</div></pre></td></tr></table></figure><p>3、attributes<br>应用于字符串的文本属性。</p><p>4、context<br>NSStringDrawingContext 类型，控制调整字间距和缩放的比例，用于文本绘制时使用。该参数传入 nil 即可。</p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSString *text = @&quot;Today is a fine day&quot;;</div><div class="line">UIFont *font = [UIFont systemFontOfSize:30];</div><div class="line">CGRect suggestedRect = [text boundingRectWithSize:CGSizeMake(800, MAXFLOAT)</div><div class="line">            options:NSStringDrawingUsesFontLeading</div><div class="line">           attributes:@&#123; NSFontAttributeName : font &#125;</div><div class="line">            context:nil];</div><div class="line">NSLog(@&quot;size = %@&quot;, NSStringFromCGSize(suggestedRect.size));</div></pre></td></tr></table></figure><p>输出： <strong>size = {200, 35.80078125}</strong></p><h4 id="四种方式对比"><a href="#四种方式对比" class="headerlink" title="四种方式对比:"></a>四种方式对比:</h4><p>在设置字体为 30 的情况下，前两种使用 view 的方法返回 <strong>size = {246.33333333333334, 36}</strong> ，后两种使用 NSString 的方法返回 <strong>size = {246.3134765625, 35.80078125}</strong> 。使用 view 方法比使用  NSString 方法的返回的值略大。<br>我猜测其原因都是因为，文本渲染引擎在渲染一行文本的时候都需要在label的顶部和底部预留一小部分空间，应该是出于排版美观方面的考量。<br>在显示不同的 font size 的字体时，获得的字符串高度比 font size 大的值是不同的。<br>比如 font size 为 13 时，算出高度为 16，font size 为 20 时，算出高度为 24。<br>所以平常设置 UILabel 高度的时候，也不能简单的在 font height 基础之上加随意值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;在设置 UILabel 的 Frame 高度时，不能简单的设置为字体的 font size。否则会将字体的一部分裁剪掉。因为 UILabel
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS崩溃解决记录</title>
    <link href="http://yoursite.com/2017/07/31/iOS/iOS%E5%B4%A9%E6%BA%83%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2017/07/31/iOS/iOS崩溃解决记录/</id>
    <published>2017-07-31T01:30:00.000Z</published>
    <updated>2017-10-31T09:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Terminating-app-due-to-uncaught-exception-‘CALayerInvalidGeometry’-reason-‘CALayer-position-contains-NaN-nan-40"><a href="#Terminating-app-due-to-uncaught-exception-‘CALayerInvalidGeometry’-reason-‘CALayer-position-contains-NaN-nan-40" class="headerlink" title="Terminating app due to uncaught exception ‘CALayerInvalidGeometry’, reason: ‘CALayer position contains NaN: [nan 40]"></a>Terminating app due to uncaught exception ‘CALayerInvalidGeometry’, reason: ‘CALayer position contains NaN: [nan 40]</h4><p>栈信息打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">2015-10-20 10:01:12.871 Putaoji[49129:1691777] *** Terminating app due to uncaught exception &apos;CALayerInvalidGeometry&apos;, reason: &apos;CALayer position contains NaN: [nan 40]&apos;</div><div class="line">*** First throw call stack:</div><div class="line">(</div><div class="line">    0   CoreFoundation                      0x000000010df49f65 __exceptionPreprocess + 165</div><div class="line">    1   libobjc.A.dylib                     0x000000010d244deb objc_exception_throw + 48</div><div class="line">    2   CoreFoundation                      0x000000010df49e9d +[NSException raise:format:] + 205</div><div class="line">    3   QuartzCore                          0x000000010cc2f7e6 _ZN2CA5Layer12set_positionERKNS_4Vec2IdEEb + 152</div><div class="line">    4   QuartzCore                          0x000000010cc2f959 -[CALayer setPosition:] + 44</div><div class="line">    5   QuartzCore                          0x000000010cc2ffbd -[CALayer setFrame:] + 650</div><div class="line">    6   UIKit                               0x000000010e9673f7 -[UIView(Geometry) setFrame:] + 356</div><div class="line">    7   UIKit                               0x000000010ec50422 -[UIButton _setFrame:deferLayout:] + 125</div><div class="line">    8   UIKit                               0x000000010ec50522 -[UIButton setFrame:] + 178</div><div class="line">    9   Putaoji                             0x000000010ae41132 -[PTJInviteFriendsViewController createShareButtonWithFrame:atIndex:title:imageName:] + 690</div><div class="line">    10  Putaoji                             0x000000010ae4004b -[PTJInviteFriendsViewController setupUI] + 2715</div><div class="line">    11  Putaoji                             0x000000010ae3f5a4 -[PTJInviteFriendsViewController viewDidLoad] + 228</div><div class="line">    12  UIKit                               0x000000010ea59931 -[UIViewController loadViewIfRequired] + 1344</div><div class="line">    13  UIKit                               0x000000010ea5f923 -[UIViewController __viewWillAppear:] + 120</div><div class="line">    14  UIKit                               0x000000010ea8f18a -[UINavigationController _startCustomTransition:] + 1177</div><div class="line">    15  UIKit                               0x000000010ea9e7c7 -[UINavigationController _startDeferredTransitionIfNeeded:] + 712</div><div class="line">    16  UIKit                               0x000000010ea9f67d -[UINavigationController __viewWillLayoutSubviews] + 57</div><div class="line">    17  UIKit                               0x000000010ec3763d -[UILayoutContainerView layoutSubviews] + 248</div><div class="line">    18  UIKit                               0x000000010e97f11c -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 710</div><div class="line">    19  QuartzCore                          0x000000010cc3836a -[CALayer layoutSublayers] + 146</div><div class="line">    20  QuartzCore                          0x000000010cc2cbd0 _ZN2CA5Layer16layout_if_neededEPNS_11TransactionE + 366</div><div class="line">    21  QuartzCore                          0x000000010cc2ca4e _ZN2CA5Layer28layout_and_display_if_neededEPNS_11TransactionE + 24</div><div class="line">    22  QuartzCore                          0x000000010cc211d5 _ZN2CA7Context18commit_transactionEPNS_11TransactionE + 277</div><div class="line">    23  QuartzCore                          0x000000010cc4e9f0 _ZN2CA11Transaction6commitEv + 508</div><div class="line">    24  UIKit                               0x000000010e8f853a _afterCACommitHandler + 174</div><div class="line">    25  CoreFoundation                      0x000000010de759d7 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23</div><div class="line">    26  CoreFoundation                      0x000000010de75947 __CFRunLoopDoObservers + 391</div><div class="line">    27  CoreFoundation                      0x000000010de6b59b __CFRunLoopRun + 1147</div><div class="line">    28  CoreFoundation                      0x000000010de6ae98 CFRunLoopRunSpecific + 488</div><div class="line">    29  GraphicsServices                    0x0000000112b04ad2 GSEventRunModal + 161</div><div class="line">    30  UIKit                               0x000000010e8ce676 UIApplicationMain + 171</div><div class="line">    31  Putaoji                             0x000000010af306ff main + 111</div><div class="line">    32  libdyld.dylib                       0x000000010fe9d92d start + 1</div><div class="line">)</div><div class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</div><div class="line">(lldb)</div></pre></td></tr></table></figure><p><a href="http://www.jianshu.com/p/456f96564567" target="_blank" rel="external">解决方法：</a><br>意思是说程序崩溃是CALayer的位置中含有不存在的数,说白了就是你的View.frame 中计算的时候，有的地方除以0了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Terminating-app-due-to-uncaught-exception-‘CALayerInvalidGeometry’-reason-‘CALayer-position-contains-NaN-nan-40&quot;&gt;&lt;a href=&quot;#Terminati
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础语法</title>
    <link href="http://yoursite.com/2017/07/31/iOS/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2017/07/31/iOS/Swift基础语法/</id>
    <published>2017-07-31T01:20:00.000Z</published>
    <updated>2017-10-31T09:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>特点<br>（1）优于OC，快速，安全<br>（2）取消了预编译指令包括宏定义（OC用的太多了）<br>（3）取消了OC指针和不安全访问的使用（看不到星星了）<br>（4）舍弃 Objective-C 早期应用 Smalltalk 的语法，全面改为点语法<br>（5）3.0中对Foundation框架做了很多改变，去除了NS，将绝大部分class转换成struct结构体（为了考虑性能和安全性，绝大部分使用结构体来代替以前的类，但是在实际使用感觉不到）<br>（6）可以使用现有的 Cocoa 和 Cocoa Touch 框架<br>, 以前是OC调UIKit，现在就是Swift调UIKit，这点事没问题的<br>（7）Swift因为语法的严谨性可以让很多错误提前遇到，这样很少出现bug让程序停在main导致无法找到<br>（8）@UIApplicationMain是程序的入口<br>（9）只有.h没有.m<br>（10）所有的代码都包括在{}里，默认方法func都有缩进！<br>（11）语法的allocinit替换成（）</p></li><li><p>PlayGround<br>（1）可以看苹果官方自带的tips和100个tips，都在Placground来使用</p></li><li><p>基础点<br>（1）不适用self. 在闭包或者编译器提示的时候再使用<br>（2）分号是用来分割语句的，如果一行洗很多，就可以加分号，一般时候可以不加<br>（3）#function打印执行的函数<br>（4）添加标记用到// MARK: - 选择，如果是接下来要做的可以用// TODO：和// FIXME：这些非常有用</p></li></ul><h3 id="一、常量和变量"><a href="#一、常量和变量" class="headerlink" title="一、常量和变量"></a>一、常量和变量</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>let 定义常量，一经赋值不允许再修改</li><li><p>var 定义变量，赋值之后仍然可以修改<br>常量和变量的细节</p><ul><li>使用 : 类型，仅仅只定义类型</li><li>常量有一次设置的机会</li><li>应该尽量先选择常量，只有在必须修改时，才需要修改为 var</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 定义常量并且直接设置数值</div><div class="line">let x: Int = 10</div><div class="line">// 常量数值一经设置，不能修改，以下代码会报错</div><div class="line">// x = 30</div><div class="line"></div><div class="line">let y: Int</div><div class="line">// 常量有一次设置的机会，以下代码没有问题，因为 `y` 还没有被设置数值</div><div class="line">y = 10</div><div class="line"></div><div class="line">// 一旦设置之后，则不能再次修改，以下代码会报错，因为 `y` 已经被设置了数值</div><div class="line">// y = 50</div><div class="line"></div><div class="line">print(x + y)</div><div class="line"></div><div class="line">// 变量设置数值之后，可以继续修改数值</div><div class="line">var z: Int</div><div class="line">z = 100</div><div class="line">z = 200</div><div class="line"></div><div class="line">print(x + y + z)</div></pre></td></tr></table></figure><h4 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h4><p>Swift 能够根据右边的代码，推导出变量的准确类型<br>只有相同类型的值才能够进行运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 整数默认的类型是 Int</div><div class="line">let intValue = 200</div><div class="line">// 小数的默认类型是 Double</div><div class="line">let doubleValue = 10.5</div><div class="line"></div><div class="line">// 如果要对不同类型的数据进行计算，必须要显式的转换</div><div class="line">print(intValue + Int(doubleValue))</div><div class="line">print(Double(intValue) + doubleValue)</div></pre></td></tr></table></figure><p>注意：Swift对类型要求异常严格，任何不同类型的数据不能直接运算（哪怕是Int和Double），不会做一些自动的转换来转换成Double。Swift不存在基本数据类型，Int和Double都是结构体其实，强转用Double(x)完成，或者在定义的时候直接指定变量的类型let x : Double = 10;（很少使用）</p><h3 id="二、控制流"><a href="#二、控制流" class="headerlink" title="二、控制流"></a>二、控制流</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><ul><li>Swift 中没有 C 语言中的非零即真概念</li><li>在逻辑判断时必须显示地指明具体的判断条件 true / false</li><li>if 语句条件的 () 可以省略</li><li>但是 {} 不能省略</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let num = 100</div><div class="line"></div><div class="line">if num &gt; 10 &#123;</div><div class="line">    print(&quot;大 \(num)&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;小 \(num)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="三目"><a href="#三目" class="headerlink" title="三目"></a>三目</h4><ul><li>Swift 中的 三目 运算保持了和 OC 一致的风格</li><li>提示：以下代码，可以按 cmd + shift + y，打开控制台，查看输出结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">num &gt; 10 ? print(&quot;大 \(num)&quot;) : print(&quot;小 \(num)&quot;)</div></pre></td></tr></table></figure><p><strong>或者</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">num &gt; 10 ? print(&quot;大 \(num)&quot;)  : () </div><div class="line">这样就对后面的不作处理。</div><div class="line">() 表示空执行。</div></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><ul><li>switch 不再局限于整数</li><li>switch 可以针对任意数据类型进行判断</li><li>每一个 case 后面必须有可以执行的语句</li><li>不再强制需要 break</li><li>如果没有任何需要执行的语句，可以使用 break<br>要保证处理所有可能的情况，不然编译器直接报错，不处理的条件可以放在 default 分支中</li><li>每一个 case 中定义的变量仅在当前 case 中有效，而 OC 中需要使用 {}</li><li>多值 case 可以使用 , 分隔</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let scoreString = &quot;优&quot;</div><div class="line"></div><div class="line">switch scoreString &#123;</div><div class="line">case &quot;优&quot;:</div><div class="line">    let name = &quot;学生&quot;</div><div class="line">    print(name + &quot;80~100分&quot;)</div><div class="line">case &quot;良&quot;, &quot;中&quot;: print(&quot;60~80分&quot;)</div><div class="line">case &quot;差&quot;: print(&quot;不及格&quot;)</div><div class="line">default: break</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>switch 的条件判断</strong></p><ul><li>switch 中可以使用 where 子句判断条件</li><li>如果只做条件判断，case 部分可以使用 _ 省略</li><li>提示：Swift 中可以使用 _ 忽略任何不关心的内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let score = 90</div><div class="line">switch score &#123;</div><div class="line">case _ where score &gt;= 80: print(&quot;优&quot;)</div><div class="line">case _ where score &gt;= 70: print(&quot;良&quot;)</div><div class="line">case _ where score &gt;= 60: print(&quot;中&quot;)</div><div class="line">default: print(&quot;差&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ul><li>swift取消了i++和++i和传统的for循环</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for i in 0...5 &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">for i in 0..&lt;5 &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>反序遍历</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> for i in (0..&lt;10).reversed() &#123;</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="三、可选项（Optional）"><a href="#三、可选项（Optional）" class="headerlink" title="三、可选项（Optional）"></a>三、可选项（Optional）</h3><h4 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h4><p>（1）定义变量时，如果是可选的，表示可以有值，也可以是nil，用“？”<br>（2）强行解包 “！”，程序员来注意！，并且要少用，可能会崩<br>（3）最常见的错误：解包的时候发现nil。fatal error: unexpectedly found nil while unwrapping an Optional value<br>（4）let可选的话，没有默认值，需要赋值。var可选的话，默认值为nil<br>（5）可选项在参与计算时候必须解包</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>Optional 是 Swift 的一大特色，也是 Swift 初学者最容易困惑的问题</li><li>定义变量时，在类型后面添加一个 ?，表示该变量是可选的</li><li>定义变量时，如果指定是可选的，表示该变量：<ul><li>可以有一个指定类型的值</li><li>也可以是 nil</li></ul></li></ul><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>格式1(自动推导)：var 变量名: Optional = 值</li><li>格式2(泛型)：var 变量名：Optional&lt;类型&gt; = 值</li><li>格式3(简化格式)：var 变量名: 类型? = 值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 格式1</div><div class="line">let x: Optional = 20</div><div class="line">// 格式2</div><div class="line">let y: Optional&lt;Int&gt; = 30</div><div class="line">// 格式3</div><div class="line">let z: Int? = 10</div><div class="line"></div><div class="line">print(x)</div><div class="line">print(y)</div><div class="line">print(z)</div></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><ul><li>变量可选项的默认值是 nil</li><li>常量可选项没有默认值，需要在定义时，或者构造函数中赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var x1: Int?</div><div class="line">print(x1)</div><div class="line"></div><div class="line">let x2: Int?</div><div class="line">// 常量可选项没有默认值，在赋值之前不能使用</div><div class="line">// print(x2)</div><div class="line">x2 = 100</div><div class="line">print(x2)</div></pre></td></tr></table></figure><h4 id="计算和强行解包"><a href="#计算和强行解包" class="headerlink" title="计算和强行解包"></a>计算和强行解包</h4><ul><li>可选值在参与计算前，必须解包 unwarping</li><li>只有解包(unwrap)后才能参与计算</li><li>在可选项后添加一个 !，表示强行解包<ul><li>如果有值，会取值，然后参与后续计算</li><li>如果为 nil，强行解包会导致崩溃</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(x! + y! + z!)</div></pre></td></tr></table></figure><p><strong>程序员要对每一个 ! 负责</strong></p><h4 id="可选解包"><a href="#可选解包" class="headerlink" title="可选解包"></a>可选解包</h4><ul><li>如果只是调用可选项的函数，而不需要参与计算，可以使用可选解包</li><li>在可选项后，使用 ? 然后再调用函数</li><li>使用可选解包可以：<ul><li>如果有值，会取值，然后执行后续函数</li><li>如果为 nil，不会执行任何函数</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var optionValue: Int?</div><div class="line">print(optionValue?.description)</div><div class="line">// 输出 nil</div><div class="line"></div><div class="line">optionValue = 10</div><div class="line">print(optionValue?.description)</div><div class="line">// 输出 Optional(&quot;10&quot;)</div></pre></td></tr></table></figure><p><strong>与强行解包对比，可选解包更安全，但是只能用于函数调用，而不能用于计算</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-9330530a1cac1a06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h3 id="可选项判断"><a href="#可选项判断" class="headerlink" title="可选项判断"></a>可选项判断</h3><h4 id="不强行解包的方法"><a href="#不强行解包的方法" class="headerlink" title="不强行解包的方法"></a>不强行解包的方法</h4><p>由于可选项的值可能为 nil，不允许直接参与运算，因此在实际开发中，经常需要判断可选项是否有值。</p><p>如果单纯使用 if，会让代码嵌套层次很深，不宜阅读和维护，为了解决这一问题，苹果提供了以下三种方式：</p><ul><li>??</li><li>if let / var</li><li>guard let / var</li></ul><h4 id=""><a href="#" class="headerlink" title="??"></a>??</h4><ul><li>?? 运算符可以用于判断可选项是否为 nil，如果是则使用后面的值替代</li></ul><p><strong>注意：?? 的优先级低，在使用时，应该注意使用 ()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let x: Int? = 10</div><div class="line">let y: Int? = 100</div><div class="line"></div><div class="line">print((x ?? 0) + (y ?? 0))</div></pre></td></tr></table></figure><h4 id="if-let-var"><a href="#if-let-var" class="headerlink" title="if let / var"></a>if let / var</h4><ul><li>使用 if let，一旦进入 if 分支，表示可选项一定有值</li><li>常量/变量的作用域仅在 {} 内部</li><li>使用 , 可以判断多个可选项是否有值</li><li>使用同名常量/变量，避免再次起名的烦恼</li><li>如果要在分支逻辑中修改值，可以使用 var，通常使用 let</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let name: String? = &quot;Mike&quot;</div><div class="line">let age: Int? = 18</div><div class="line"></div><div class="line">if let name = name,</div><div class="line">    let age = age &#123;</div><div class="line">    print(&quot;\(name) 今年 \(age) 岁&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;姓名或者年龄为 nil&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="guard-let-var"><a href="#guard-let-var" class="headerlink" title="guard let / var"></a>guard let / var</h4><ul><li>guard 是与 if let 相反的语法，Swift 2.0 推出</li><li>guard 同样可以判断可选项是否有值</li><li>多值判断使用 , 分隔</li><li>如果发现 nil，在 else 分支返回</li><li>分支结束后，所有的 常量/变量 都有值</li><li>相比较 if let，guard 语法的分支结构能节省一层</li><li>如果要在后续逻辑中修改值，可以使用 var，通常使用 let</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func demo(name: String?, age: Int?) &#123;</div><div class="line"></div><div class="line">    guard let name = name,</div><div class="line">        let age = age else &#123;</div><div class="line">            print(&quot;姓名或者年龄为 nil&quot;)</div><div class="line"></div><div class="line">            return</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    print(&quot;\(name) 今年 \(age) 岁&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">demo(name: name, age: age)</div></pre></td></tr></table></figure><h4 id="guard-let和if-let可以用同名变量接收。"><a href="#guard-let和if-let可以用同名变量接收。" class="headerlink" title="guard let和if let可以用同名变量接收。"></a>guard let和if let可以用同名变量接收。</h4><p>因为总会取名字，if let name = name这样就可以，注意后面使用的时候用非空的那个！并且iflet和guardlet可以依次判断，先判断是一个字典，再拿字典的数组，在判断数组的值，可以一条线判断出来。<br><img src="http://upload-images.jianshu.io/upload_images/1868951-75ff2d3c2381330b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h3><p>  用String，是一个结构体，具有绝大多数NSString功能，支持直接遍历</p><p>（1）遍历：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func demo3() &#123;</div><div class="line">    </div><div class="line">    // 字符串遍历（NSString不支持这么遍历）</div><div class="line">    let str = &quot;wowosnshi是&quot;</div><div class="line">    </div><div class="line">    for s in str.characters &#123;</div><div class="line">        print(s)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>（2）长度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 返回指定编码对应的字节数，每个汉字三个字节</div><div class="line">print(str.lengthOfBytes(using: .utf8))</div><div class="line"></div><div class="line">// 返回真正字符串长度</div><div class="line">print(str.characters.count)</div></pre></td></tr></table></figure></p><p>（3）拼接：要注意可选项拼接不解决会带上Optional，剩下的都可以拼接，再也不用看StringWithFormat了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let name = &quot;AA&quot;</div><div class="line"></div><div class="line">let age = 19</div><div class="line"></div><div class="line">let title : String? = &quot;sss&quot;</div><div class="line"></div><div class="line">print(&quot;\(name)\(age)\(title ?? &quot;&quot;)&quot;)</div></pre></td></tr></table></figure></p><p>（4）格式化：</p><ul><li>格式化成日期</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let h = 8 , m = 10, s = 44</div><div class="line"></div><div class="line">// OC中用stringWithFormat格式化日期，Swift中可以</div><div class="line"></div><div class="line">let strDate = String(format: &quot;%02d-%02d-%02d&quot;, h,m,s)</div><div class="line"></div><div class="line">print(strDate)</div></pre></td></tr></table></figure><p>（5）截取字符串：建议用NSStrin作中转，因为swift取串方法一直在改变</p><ul><li>NSString方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let str = &quot;红红火火恍恍惚惚&quot;</div><div class="line"></div><div class="line">let strOC = str as NSString</div><div class="line"></div><div class="line">strOC .substring(to: 1)</div><div class="line"></div><div class="line">strOC.substring(with: NSMakeRange(0, 2))</div></pre></td></tr></table></figure><h3 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h3><p>（1）就是中括号，注意数组的类型，并且基本数据类型不需要包装，可以直接方数组里，如果类型不一样（混合数组，但是基本不用），自动推导[NSObject]。在Swift中还有一个[AnyObject类型]，标示任意对象，因为在Swift中一个类可以没有任何父类。</p><p>（2）遍历：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 遍历1(按照下标遍历)</div><div class="line">for i in 0..&lt;array.count &#123;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 遍历2（遍历元素）</div><div class="line">for s in array &#123;</div><div class="line">    </div><div class="line">         </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 遍历3（同时遍历下标和元素）</div><div class="line">for e in array.enumerated() &#123;</div><div class="line">    </div><div class="line">    // let e: (offset: Int, element: String) e是一个元组        </div><div class="line">    print(&quot;\(e.offset), \(e.element)&quot;)</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 遍历4（同时遍历下标和元素）</div><div class="line">for (n,s) in array.enumerated() &#123;</div><div class="line">    </div><div class="line">    print(&quot;\(n),\(s)&quot;)</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 反序遍历</div><div class="line">for s in array.reversed() &#123;</div><div class="line">    </div><div class="line">            </div><div class="line">&#125;</div><div class="line">    </div><div class="line">// 反序索引下标(这样写才对，先枚举再反序)</div><div class="line">for (n,s) in array.enumerated().reversed() &#123;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>（3）增删改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">array.append(&quot;AA&quot;)</div><div class="line"></div><div class="line">array[1] = &quot;BBB&quot;</div><div class="line"></div><div class="line">array.remove(at: 2)</div></pre></td></tr></table></figure></p><p>（4）合并：用“+”号。但是要合并的数组的两个类型必须一致。</p><h3 id="六、字典"><a href="#六、字典" class="headerlink" title="六、字典"></a>六、字典</h3><p>一般是[String：NSObject]，对应键值对.由于3.0后大部分都是结构体了,AnyObject不好用了，Any范围更大<br>（1）字典数组：<br>（2）增删改：和数组都类似，就是两个字典合并不像数组直接相加，而是需要遍历</p><h3 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h3><p>（1）外部参数，当外部参数用_替代的时候，会在外部调用的时候忽略形参名<br><img src="http://upload-images.jianshu.io/upload_images/1868951-52cd1c900bdb5748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（2）函数的默认值（OC不具备），这个使Swift比OC灵活很多很多，一个方法可以做很多事，因为OC会有各种参数和组合，Swift只需写一个最多的参数，然后不需要的设定默认值就是了</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-d8fe7708a070bb29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（3）无返回值 ：直接省略 （） Void都可以</p><p>（4）闭包：类似Block，比Block还广泛。OC中Block是匿名函数，Swift中函数是特殊的闭包。闭包在整个开发中和Block的应用场景一样。用于控制器/自定义视图/异步执行完成的回调。这些回调的特点就是都是以参数回调处理结果，返回值为Void。</p><ul><li><p>定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   let biBao = &#123; (x: Int) -&gt; Int in</div><div class="line">            </div><div class="line">       return x + 100</div><div class="line">   &#125;</div><div class="line">        </div><div class="line">   print(biBao(10))</div></pre></td></tr></table></figure></li><li><p>GCD：将任务添加到队列，指定执行任务的函数。任务就是Block/闭包，队列以同步/异步的方式执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    func loadData(compeletion:@escaping ( _ result: [String])-&gt;()) -&gt; Void &#123;</div><div class="line">        </div><div class="line">        DispatchQueue.global().async &#123;</div><div class="line">            </div><div class="line">            print(&quot;耗时操作会获得一些结果 \(Thread.current)&quot;)</div><div class="line">            </div><div class="line">            Thread.sleep(forTimeInterval: 1.0)</div><div class="line">            </div><div class="line">            let json = [&quot;天气&quot;,&quot;不错&quot;,&quot;刮大风&quot;]</div><div class="line">            </div><div class="line">            // 主线程回调</div><div class="line">            DispatchQueue.main.async(execute: &#123;</div><div class="line">                </div><div class="line">                print(&quot;主线程更新UI \(Thread.current)&quot;)</div><div class="line">                </div><div class="line">                // 回调 -&gt; 通过参数传递 执行闭包</div><div class="line">                compeletion(json)</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">   </div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul><p>调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">        // 执行的适合我就拿到了值</div><div class="line">        loadData &#123; (result) in</div><div class="line">            </div><div class="line">            print(&quot;获取的新闻数据 \(result)&quot;)</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><ul><li><p>尾随闭包：如果函数的最后一个参数是闭包，那么参数就省略了，最后一个参数直接{}大括号包装</p></li><li><p>闭包的循环引用：</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-ba4dbd3e7430bd1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法1">　　　　　　　　</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-37bff51c1a762d9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法2"></p><p>（5）面向对象（各种构造函数）：（）就是allocInit，在Swift中对应init()。在swift中一个项目所有类都是共享的，可以直接访问，每一个类都默认有一个命名空间。A.name B.name God.name Dog.name。同一个类可以从属于不同的命名空间（假如有一个框架有Person类，做用户，还有一个框架做后台，也用Person。在OC中就只能靠前缀解决，HouTaiPerson，KuangJiaPerson。而Swift中的命名空间就是项目名。AAA项目有一个Person，那么AAA.Person就是AAA的Person类，此时再导入框架，那也是框架的.Person）<br><img src="http://upload-images.jianshu.io/upload_images/1868951-fe35f0c10b0f7e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>在自定义的Nsobjiect类中，has no initalizers 标示没有初始化器，初始化器可以有多个，默认是init。当这个类有属性的时候，属性要分配内存空间，就是说要有初始值。那么其实就是先给自己的属性分配，然后给父初始。其实这么一看，Swift和OC是相反的！</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-440dc9822b651550.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>思路：OC是先调用爸爸。就是Person，Person会再调用NSObject，就是先跑上去什么都不管，先初始化了NSObject，然后才往下走挨个初始化。Swift是把自己完全初始化，再上去初始化爸爸，这么看比OC快了一圈，性能要好。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-32291fce27beef6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>重载构造函数：（重写是父类有这个方法，override。重载是函数名相同，参数和个数不同。init就重写，init+参数就重载。OC是没有重载的！都是initWithXXXXX）。重载其实是最基本的方式，OC没有其实很low，但是Swift有。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0beee0b1eba57574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>注意：如果重载了构造函数并且没有实现父类的init，那么系统不再提供init构造函数了（默认是有的），因为默认的构造函数不能给本类的属性分配空间（你不自己写name = ，系统就没办法分配）</p><ul><li><p>KVC构造函数：只需记住下面4点<br><img src="http://upload-images.jianshu.io/upload_images/1868951-104ce1b663f76f78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>所以一般在模型中加个？ 然后用KVC实现（先调用init因为是运行时机制）</strong></p></li><li><p>模型中属性定义：基本数据类型 = 0，对象设置？<br>运行时中，基本类型设置？    属性设置私有都会让运行时拿不到，此时kvc就会出错。<br><img src="http://upload-images.jianshu.io/upload_images/1868951-0e8c14816279da28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li>如果子类没有重写父类方法，调用的时候就会直接调用父类的方法。当继承一个类，就继承所有属性和方法，包括KVC。当PERSON写好了KVC后，</li><li>整体<br><img src="http://upload-images.jianshu.io/upload_images/1868951-722a51e523596920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（6）便利构造函数：关键字Convenience（开发用的很少，因为模型都是框架转，UI不需要便利）<br>*目的：条件判断，只有满足条件才实例化对象，防止不必要的内存开销，简化对象创建。本身是不负责属性的创建和初始化的。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f0dc301dfbbf6fb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>　　<br>（7）deinit:类似OC的Dealloc<br><img src="http://upload-images.jianshu.io/upload_images/1868951-562bd1efec2cfa04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="八、分类：extension"><a href="#八、分类：extension" class="headerlink" title="八、分类：extension"></a>八、分类：extension</h3><p>便利构造函数 + 分类可以省略抽取很多代码。例如给UITextField/UIButton写分类，然后写便利构造函数，方便。</p><h3 id="九、Swift的类，结构体，枚举三种都有构造函数，都可以有方法，就像OC的类"><a href="#九、Swift的类，结构体，枚举三种都有构造函数，都可以有方法，就像OC的类" class="headerlink" title="九、Swift的类，结构体，枚举三种都有构造函数，都可以有方法，就像OC的类"></a>九、Swift的类，结构体，枚举三种都有构造函数，都可以有方法，就像OC的类</h3><h3 id="十、其它"><a href="#十、其它" class="headerlink" title="十、其它"></a>十、其它</h3><h4 id="懒加载："><a href="#懒加载：" class="headerlink" title="懒加载："></a>懒加载：</h4><p>在OC开发中，懒加载一般自定义控件。在Swift中，懒加载还是需要用的，可以保证控件延迟创建，还能避免处理控件解包。如果直接定义控件var label = UILabel，根据代码从上到下，会让控件在ViewDidLad之前就提前创建了。所以需要懒加载。OC中懒加载就是Get方法，Swift直接lazy var。当然也可以private lazy var来限定作用域。</p><p>（1）简单的懒加载：<br><img src="http://upload-images.jianshu.io/upload_images/1868951-018c8333a67c1f19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（2）完整的懒加载：（）就是函数执行，就是一个特殊的闭包，所以懒加载本质是一个闭包。一般不这么写。<br><img src="http://upload-images.jianshu.io/upload_images/1868951-203b83d0a055460e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>　　<br>（3）OC和Swift区别</p><ul><li>OC：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (UILabel *)label&#123;</div><div class="line">    //如果label等于nil就会创建!</div><div class="line">    if (_label == nil) &#123;</div><div class="line">        _label = [[UILabel alloc]init];</div><div class="line">        _label.text = @&quot;loirou&quot;;</div><div class="line">        [_label sizeToFit];</div><div class="line">        _label.center = self.view.center;</div><div class="line">    &#125;</div><div class="line">    return _label;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>OC是等于nil时候就懒加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[self.view addSubview:self.label];</div><div class="line">//释放label</div><div class="line">_label = nil;</div><div class="line"></div><div class="line">//会再次调用懒加载的代码</div><div class="line">NSLog(@&quot;%@&quot;,self.label);</div></pre></td></tr></table></figure><p>当label设nil的时候就在此调用。在ios6中，didReceiveMemoryWarning是不清理视图的。</p><ul><li>Swift：</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1868951-4754ad62e9252aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>此时释放的时候就会报错。因为定义的时候没有？，就是一定有值得。<br>那么如果定义时候加？ 一旦label = nil，也不会在执行懒加载了！因为懒加载根本没写如果是空就创建。<br>懒加载只会在第一次调用的时候执行闭包。Swift中一定注意不要主动清理视图或控件，因为懒加载不会创建了（例如内存警告别干掉控件，干掉了在也用不成了，因为懒加载就一次）</p><h4 id="计算型属性（只读）："><a href="#计算型属性（只读）：" class="headerlink" title="计算型属性（只读）："></a>计算型属性（只读）：</h4><p>（1）getter/setter（开发不用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    // 开发一般不用，还给搞一个_name。</div><div class="line">    // swift一般不会重写getter和setter</div><div class="line">    private var _name: String? // 假装的一个值</div><div class="line">    var name: String? &#123; get&#123;return _name&#125;  set&#123;_name = newValue&#125;&#125; // get返回成员变量 set记录成员变量</div><div class="line"></div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        </div><div class="line">        demo()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>（2）计算型属性：readOnly只读：OC中重写get。Swift也是重写get，不管set就可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 只读，此时set赋值时候就会报错</div><div class="line"> var name: String? &#123; get&#123;return &quot;ABC&quot;&#125;&#125;</div><div class="line">// 还有一种简写：</div><div class="line"> var name: String? &#123; return &quot;ABC&quot;&#125;</div></pre></td></tr></table></figure><p>看这类属性，是本身不保存内容的，都是通过计算获得结果。就可以当我就是个没有参数只有返回值的函数！！我每次return值给你我的任务就完成了。每次你调用我这个属性的时候，我都会进行一次计算！都会执行我的代码然后return给你。我自身不存储的。</p><p>（3）懒加载和计算型属性的区别：<br><img src="http://upload-images.jianshu.io/upload_images/1868951-3d568e0dedf0e0a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（4）存储型属性：需要开辟空间，存储数据。一般的属性都是存储型属性（懒加载）</p><p>（5）存储和计算都可以？或者不加。看情况是不是必选</p><p>（四）Swift中设置模型数据：<br>Swift做好模型后。别的控件拿到模型后，由视图自己来显示。此时在didSet里写。就是替代OC的Setter方法。（OC的Setter要考虑_成员变量 = 值，而且如果是copy需要.copy，而Swift不需要考虑一切）</p><h4 id="命名空间："><a href="#命名空间：" class="headerlink" title="命名空间："></a>命名空间：</h4><ul><li>在同一个空间（项目），全局共享。用第三方时，如果直接拖拽，那就从属于一个空间，很有可能冲突，所以用Cocopod</li><li>动态获得命名空间（从info.plist加载），命名空间和项目名称有关系。info的Bundle name其实就是命名空间（一般写的很奇怪 #（ProdectNmae））。<br>打印info<br>print(Bundle.main.infoDictionary)<br><img src="http://upload-images.jianshu.io/upload_images/1868951-f0870f71a52c609a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 获取命名空间的值，可选 let str = </div><div class="line">Bundle.main.infoDictionary?[&quot;CFBundleName&quot;] as? String ?? &quot;&quot;                  </div><div class="line">let con = NSClassFromString(str + &quot;.&quot; + &quot;ViewController&quot;) as? UIViewController.Type</div></pre></td></tr></table></figure></p><h4 id="反射机制："><a href="#反射机制：" class="headerlink" title="反射机制："></a>反射机制：</h4><p>对于任何类都可以知道类的所有属性和方法，对于任何对象都可以调用任何属性和方法，这种动态获取的信息和动态调用对象属性方法的功能成java的反射机制（Swift也有了）</p><p>（1）在OC中利用反射机制</p><ul><li>利用<strong>NSClassFromString</strong>方法来使用字符串获取类</li><li>利用<strong>isMemberOfClass</strong>判断是否是某一个类</li><li>利用<strong>isKindOfClass</strong>判断是否是某一个类的子类</li><li>利用<strong>conformsToProtocol</strong>判断对象是否遵守某一个协议</li><li>利用<strong>respondsToSelector</strong>判断是否实现了某一个方法</li><li>利用<strong>performSelector</strong>或者<strong>objc_msgSend</strong>间接调用方法</li></ul><p>（2）在Swift中利用反射机制类似。工作中用的很多很多。<br>场景：AppDelegate（OC中也用过，利用NSClassFromString获得类，然后设置根控制器。但是Swift中多了一个命名空间写法。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123;</div><div class="line">        </div><div class="line">    window = UIWindow(frame: UIScreen.main.bounds)</div><div class="line">    </div><div class="line">    // 依据String名字拿到控制器(添加项目名称，命名空间，不能有数字和特殊符号)</div><div class="line">    // 返回的是AnyClass？ 需要as？强转</div><div class="line">    // 控制器添加Type类型</div><div class="line">    let rootControl = NSClassFromString(&quot;SwiftyDemo.ViewController&quot;) as? UIViewController.Type</div><div class="line">    </div><div class="line">    let vc = rootControl?.init()</div><div class="line">    </div><div class="line">    window?.rootViewController = vc</div><div class="line">    </div><div class="line">    window?.makeKeyAndVisible()</div><div class="line">    </div><div class="line">    return true</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>（3）第三方框架，用了很多反射机制和工厂方法，为了实现大量的解耦和封装，很麻烦。一个方法可能跳10个方法10个控制器才写了一个加法。但是如果涉及高级开发和封装，必须要经过这一步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特点&lt;br&gt;（1）优于OC，快速，安全&lt;br&gt;（2）取消了预编译指令包括宏定义（OC用的太多了）&lt;br&gt;（3）取消了OC指
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>layer介绍</title>
    <link href="http://yoursite.com/2017/06/13/iOS/layer%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2017/06/13/iOS/layer介绍/</id>
    <published>2017-06-13T07:23:00.000Z</published>
    <updated>2017-10-31T09:51:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、CAEmitterLayer"><a href="#一、CAEmitterLayer" class="headerlink" title="一、CAEmitterLayer"></a>一、CAEmitterLayer</h4><p>CAEmitterLayer用来实现基于Core Animation的粒子发生器系统。每个粒子都是一个CAEmitterCell的实例。粒子绘制在背景色与border之上。</p><p>在属性中，可以指定Layer中的CAEmitterCell数组，每个cell定义了自己的一组属性，如速度、粒子发生率、旋转、缩放或者内容等。每个粒子也都有一个emitterCells属性，可以做为一个粒子发生器来运作。Layer还可以设置发生器位置、发生器形状、发射单元的位置等等。<br>下面是一段例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">self.view.backgroundColor = [UIColor colorWithRed:12/255.0f green:105/255.0f blue:244/255.0f alpha:1.0];</div><div class="line"></div><div class="line">//在实际应用中，我们一般会将其放到可视视图之外的地方，以便更好的模拟效果，不过这里为了测试属性，将其放在可视范围内</div><div class="line">CGRect rect = CGRectMake(0, 100, self.view.bounds.size.width, 50);</div><div class="line">//创建发射器</div><div class="line">CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];</div><div class="line">emitterLayer.frame = rect;</div><div class="line">[self.view.layer addSublayer:emitterLayer];</div><div class="line"></div><div class="line">//设置发射器类型</div><div class="line">emitterLayer.emitterShape = kCAEmitterLayerCuboid;</div><div class="line">emitterLayer.emitterPosition = CGPointMake(rect.size.width*0.5, rect.size.height*0.5);</div><div class="line">emitterLayer.emitterSize = rect.size;</div><div class="line"></div><div class="line">CAEmitterCell *emitterCell = [CAEmitterCell emitterCell];</div><div class="line">//设置粒子展现内容</div><div class="line">emitterCell.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;paopao&quot;].CGImage);</div><div class="line"></div><div class="line">//设置粒子创建速率，也就是每秒产生的个数</div><div class="line">emitterCell.birthRate = 100;</div><div class="line">//设置粒子的生命周期，也就是在屏幕上存在的时间</div><div class="line">emitterCell.lifetime = 3.5;</div><div class="line">//设置粒子声明周期范围</div><div class="line">emitterCell.lifetimeRange = 1.0;</div><div class="line">//设置y轴上的加速度</div><div class="line">emitterCell.yAcceleration = 70.0f;</div><div class="line">//设置x轴上的加速度</div><div class="line">emitterCell.xAcceleration = 10.0f;</div><div class="line">//设置粒子的初始速度</div><div class="line">emitterCell.velocity = 20;</div><div class="line">//设置粒子的初始角度 如果不设置这个值，我们发现粒子都是水平发射的</div><div class="line">emitterCell.emissionLongitude = -M_PI_2;</div><div class="line">//设置粒子的初始速度范围 在此例子中范围是 -180~220</div><div class="line">emitterCell.velocityRange = 200.0f;</div><div class="line">//设置粒子的初始角度范围 此例子的范围为 M_PI~0</div><div class="line">emitterCell.emissionRange = M_PI_2;</div><div class="line">//设置粒子的颜色</div><div class="line">//    emitterCell.color = [UIColor colorWithRed:0.9 green:1.0 blue:1.0 alpha:1.0].CGColor;</div><div class="line">//    //我们也可以设置随机颜色，并且限定范围。因为RGB的值最大为1.0,那Red来说，范围并不会变为0.6~1.3,而是0.6~1.0。相似的，如果是负值，则最小为0</div><div class="line">//    emitterCell.redRange = 0.3;</div><div class="line">//    emitterCell.greenRange = 0.3;</div><div class="line">//    emitterCell.blueRange = 0.3;</div><div class="line">//设置粒子的大小及其大小范围</div><div class="line">emitterCell.scale = 0.8;</div><div class="line">emitterCell.scaleRange = 0.8;</div><div class="line"></div><div class="line">//设置让粒子随着时间推移每秒减小15%,如果设置为正值则每秒增加</div><div class="line">emitterCell.scaleSpeed = -0.15;</div><div class="line"></div><div class="line">//设置粒子透明度的变化范围</div><div class="line">emitterCell.alphaRange = 0.75;</div><div class="line">//设置粒子变化速度</div><div class="line">emitterCell.alphaSpeed = -0.15;</div><div class="line">//将粒子赋给发射器</div><div class="line">emitterLayer.emitterCells = @[emitterCell];</div></pre></td></tr></table></figure></p><p>CAEmitterLayer通过emitterPosition指定了emitter的位置，在view的中间偏下的地方，并且形状为默认的一个点。renderMode定义了粒子的渲染方式，在这里让所有的粒子出现叠加增强的效果。birthRate让粒子每秒产生四个。</p><p>CAEmitterCell指定contents来定义了粒子的内容，emissionLongitude和emissionLatitude指定了经纬度，经度角代表了x-y轴平面上与x轴之间的夹角，纬度角代表了x-z轴平面上与x轴之间的夹角。emissionRange设置了一个范围，围绕着y轴负方向，建立了一个圆锥形，粒子从这个圆锥形的范围内打出。lifetime设置了粒子的存活时长，在1.6秒之后，粒子消失。birthRate定义每秒生成100个，与CAEmitterLayer的birtuRate相乘，即最终的粒子数量400个每秒。velcity指定了初速度，velcityRange设置初速度在300到500之间浮动，yAcceleration指定了沿y轴250的加速度，用于给粒子减速。color设置了粒子的颜色，并设置了每个色值的浮动范围，用于生成所有颜色的烟火。最后设置了名称，以后可以再次引用它。效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-a8f4e0d959ca1a3d.gif?imageMogr2/auto-orient/strip" alt="CAEmitterLayer.gif"></p><h4 id="二、CAGradientLayer"><a href="#二、CAGradientLayer" class="headerlink" title="二、CAGradientLayer"></a>二、CAGradientLayer</h4><p>CAGradientLayer用来绘制渐变色，指定几个颜色值、渐变结束位置，就能在layer中绘制出渐变效果。下面是一段例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">CAGradientLayer *layer = [CAGradientLayer layer];</div><div class="line">CGRect frame = self.view.frame;</div><div class="line">frame.origin = CGPointMake(0, 0);</div><div class="line">layer.frame = frame;</div><div class="line">layer.opacity = 0.5;</div><div class="line">layer.colors = @[(id)[UIColor redColor].CGColor,(id)[UIColor greenColor].CGColor,(id)[UIColor blueColor].CGColor];</div><div class="line">layer.locations = @[@0.2,@0.5,@0.8];</div><div class="line">layer.startPoint = CGPointMake(0, 0);</div><div class="line">layer.endPoint = CGPointMake(1, 1);</div><div class="line">[self.view.layer addSublayer:layer];</div></pre></td></tr></table></figure></p><p>例子中的layer是直接加载self.view.layer上的，位于emitterLayer上面,设置为半透明，在渐变色下显示出图片内容。colors指定渐变色选取红色、绿色和蓝色三色。locations设置了红色与绿色的渐变区域在20%与50%之间，小于20%的位置为红色，50%位置为绿色，绿色与蓝色的渐变区域在50%与80%之间，大于80%的位置为蓝色。startPoint设置为左上角，endPoint设置为右下角，颜色从左上角逐渐变到右下角。效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-1cce0422d9fb3c5d.gif?imageMogr2/auto-orient/strip" alt="CAGradientLayer.gif"></p><h4 id="三、CAReplicatorLayer"><a href="#三、CAReplicatorLayer" class="headerlink" title="三、CAReplicatorLayer"></a>三、CAReplicatorLayer</h4><p>CAReplicatorLayer创建layer和它的sublayer的多个副本，副本可以设置transform来变形，或者设置颜色、透明度的变化。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//  背景 layer</div><div class="line">   CAReplicatorLayer * repLayer = [CAReplicatorLayer layer];</div><div class="line">   repLayer.frame = self.view.frame;</div><div class="line">   repLayer.backgroundColor = [UIColor clearColor].CGColor;</div><div class="line">   [self.view.layer addSublayer:repLayer];</div><div class="line">   </div><div class="line">   //  1、单个原点： 原始层</div><div class="line">   CALayer * dotLayer = [CALayer layer];</div><div class="line">   dotLayer.frame = CGRectMake(0, 0, 10, 10);</div><div class="line">   dotLayer.position = CGPointMake(59, 61);</div><div class="line">   dotLayer.cornerRadius = 5;</div><div class="line">   dotLayer.borderWidth = 1;</div><div class="line">   dotLayer.backgroundColor = [UIColor colorWithWhite:0.8 alpha:1].CGColor;</div><div class="line">   dotLayer.borderColor = [UIColor colorWithWhite:1.0 alpha:1].CGColor;</div><div class="line">   //  Rasterize 光栅栏 效果</div><div class="line">   dotLayer.shouldRasterize = YES;</div><div class="line">   //  加在 replicator layer 上的 layer 可以复制</div><div class="line">   [repLayer addSublayer:dotLayer];</div><div class="line">   </div><div class="line">   //  2、只是为一个点添加了动画</div><div class="line">   CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">   //  设置动画的路径 为 设置好的 贝塞尔曲线</div><div class="line">   animation.path = [self creatBezierPath];</div><div class="line">   animation.repeatCount = INFINITY;</div><div class="line">   animation.duration = 4;</div><div class="line">   [dotLayer addAnimation:animation forKey:nil];</div><div class="line">   </div><div class="line">   //  3、设置延时,拷贝数量</div><div class="line">   repLayer.instanceDelay = 0.1;</div><div class="line">   repLayer.instanceCount = 20;</div><div class="line">   </div><div class="line">   //  4、改变颜色、设置颜色的 偏移</div><div class="line">   repLayer.instanceColor = [UIColor greenColor].CGColor;</div><div class="line">   //repLayer.instanceGreenOffset = -0.03;</div></pre></td></tr></table></figure></p><p> 利用 pinterCode 软件 计算的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (CGPathRef)creatBezierPath &#123;</div><div class="line">    </div><div class="line">    UIBezierPath* bezierPath = UIBezierPath.bezierPath;</div><div class="line">    [bezierPath moveToPoint: CGPointMake(59, 61)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(65.21, 66.9)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(73.69, 65.77)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(75.25, 74.19)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(82.78, 78.27)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(79.09, 86)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(82.78, 93.73)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(75.25, 97.81)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(73.69, 106.23)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(65.21, 105.1)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(59, 111)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(52.79, 105.1)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(44.31, 106.23)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(42.75, 97.81)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(35.22, 93.73)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(38.91, 86)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(35.22, 78.27)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(42.75, 74.19)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(44.31, 65.77)];</div><div class="line">    [bezierPath addLineToPoint: CGPointMake(52.79, 66.9)];</div><div class="line">    [bezierPath closePath];</div><div class="line">    </div><div class="line">    //  放大</div><div class="line">    CGAffineTransform scale = CGAffineTransformMakeScale(3, 3);</div><div class="line">    //  生成 CGPath 拷贝 （副本）</div><div class="line">    CGPathRef pathRef = CGPathCreateCopyByTransformingPath(bezierPath.CGPath, &amp;scale);</div><div class="line">    return pathRef;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/1868951-aa4040e681864ed8.gif?imageMogr2/auto-orient/strip" alt="CAReplicatorLayer.gif"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、CAEmitterLayer&quot;&gt;&lt;a href=&quot;#一、CAEmitterLayer&quot; class=&quot;headerlink&quot; title=&quot;一、CAEmitterLayer&quot;&gt;&lt;/a&gt;一、CAEmitterLayer&lt;/h4&gt;&lt;p&gt;CAEmitterLayer
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="动画与绘图" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>PHP案例-信息管理系统</title>
    <link href="http://yoursite.com/2017/05/24/PHP/PHP%E6%A1%88%E4%BE%8B-%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/05/24/PHP/PHP案例-信息管理系统/</id>
    <published>2017-05-24T03:40:00.000Z</published>
    <updated>2017-10-30T05:58:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>– Database: <code>test</code></p><p>– 表的结构 <code>message</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `message` (</div><div class="line">  `id` tinyint(1) NOT NULL PRIMARY KEY AUTO_INCREMENT,</div><div class="line">  `name` varchar(25) NOT NULL,</div><div class="line">  `sex` varchar(50) NOT NULL,</div><div class="line">  `age` tinyint(1) NOT NULL,</div><div class="line">  `classid` tinyint(1) NOT NULL</div><div class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure><h4 id="index-php"><a href="#index-php" class="headerlink" title="index.php"></a>index.php</h4><p><img src="http://upload-images.jianshu.io/upload_images/1868951-37a23780f6c00006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首页"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;学生信息管理&lt;/title&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        function doDel(id) &#123;</div><div class="line">            if (confirm(&quot;确定要删除么？&quot;)) &#123;</div><div class="line">                window.location = &apos;action.php?action=del&amp;id=&apos; + id;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;center&gt;</div><div class="line">    &lt;?php</div><div class="line">    include_once &quot;menu.php&quot;;</div><div class="line">    ?&gt;</div><div class="line">    &lt;h3&gt;浏览学生信息&lt;/h3&gt;</div><div class="line">    &lt;table width=&quot;600&quot; border=&quot;1&quot;&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;th&gt;ID&lt;/th&gt;</div><div class="line">            &lt;th&gt;姓名&lt;/th&gt;</div><div class="line">            &lt;th&gt;性别&lt;/th&gt;</div><div class="line">            &lt;th&gt;年龄&lt;/th&gt;</div><div class="line">            &lt;th&gt;班级&lt;/th&gt;</div><div class="line">            &lt;th&gt;操作&lt;/th&gt;</div><div class="line">        &lt;/tr&gt;</div><div class="line">        &lt;?php</div><div class="line">        //1.连接数据库</div><div class="line">        try &#123;</div><div class="line">            $pdo = new PDO(&quot;mysql:host=localhost;dbname=test;&quot;, &quot;root&quot;, &quot;&quot;);</div><div class="line">        &#125; catch (PDOException $e) &#123;</div><div class="line">            die(&quot;数据库连接失败&quot; . $e-&gt;getMessage());</div><div class="line">        &#125;</div><div class="line">        //2.解决中文乱码问题</div><div class="line">        $pdo-&gt;query(&quot;SET NAMES &apos;UTF8&apos;&quot;);</div><div class="line">        //3.执行sql语句，并实现解析和遍历</div><div class="line">        $sql = &quot;SELECT * FROM message &quot;;</div><div class="line">        foreach ($pdo-&gt;query($sql) as $row) &#123;</div><div class="line">            echo &quot;&lt;tr&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;id&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;name&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;sex&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;age&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;&#123;$row[&apos;classid&apos;]&#125;&lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;td&gt;</div><div class="line">                    &lt;a href=&apos;javascript:doDel(&#123;$row[&apos;id&apos;]&#125;)&apos;&gt;删除&lt;/a&gt;</div><div class="line">                    &lt;a href=&apos;edit.php?id=(&#123;$row[&apos;id&apos;]&#125;)&apos;&gt;修改&lt;/a&gt;</div><div class="line">                  &lt;/td&gt;&quot;;</div><div class="line">            echo &quot;&lt;/tr&gt;&quot;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ?&gt;</div><div class="line"></div><div class="line">    &lt;/table&gt;</div><div class="line">&lt;/center&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><h4 id="menu-php"><a href="#menu-php" class="headerlink" title="menu.php"></a>menu.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h2&gt;学生管理系统&lt;/h2&gt;</div><div class="line">&lt;a href=&quot;index.php&quot;&gt; 浏览学生&lt;/a&gt;</div><div class="line">&lt;a href=&quot;add.php&quot;&gt; 添加学生&lt;/a&gt;</div><div class="line">&lt;hr&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><h4 id="add-php"><a href="#add-php" class="headerlink" title="add.php"></a>add.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;学生信息管理&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;center&gt;</div><div class="line">    &lt;?php include(&quot;menu.php&quot;); ?&gt;</div><div class="line">    &lt;h3&gt;增加学生信息&lt;/h3&gt;</div><div class="line">    &lt;form method=&quot;post&quot; action=&quot;action.php?action=add&quot;&gt;</div><div class="line"></div><div class="line">        &lt;table&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;姓名&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input  name=&quot;name&quot; type=&quot;text&quot;/&gt;&lt;/td&gt;</div><div class="line"></div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;性别&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;/&gt; 男</div><div class="line">                    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;/&gt; 女</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;年龄&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;班级&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input  name=&quot;classid&quot; type=&quot;text&quot;/&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt; &lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;增加&quot;/&gt;  </div><div class="line">                    &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">        &lt;/table&gt;</div><div class="line"></div><div class="line">    &lt;/form&gt;</div><div class="line">&lt;/center&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1868951-40db8e8dca16bc41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加成功"></p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-6fb2b56d2790f7c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加后"></p><h4 id="edit-php"><a href="#edit-php" class="headerlink" title="edit.php"></a>edit.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;学生信息管理&lt;/title&gt;</div><div class="line"></div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;center&gt;</div><div class="line">    &lt;?php</div><div class="line">    include_once &quot;menu.php&quot;;</div><div class="line">    //1.连接数据库</div><div class="line">    try &#123;</div><div class="line">        $pdo = new PDO(&quot;mysql:host=localhost;dbname=test;&quot;, &quot;root&quot;, &quot;&quot;);</div><div class="line">    &#125; catch (PDOException $e) &#123;</div><div class="line">        die(&quot;数据库连接失败&quot; . $e-&gt;getMessage());</div><div class="line">    &#125;</div><div class="line">    //2.防止中文乱码</div><div class="line">    $pdo-&gt;query(&quot;SET NAMES &apos;UTF8&apos;&quot;);</div><div class="line">    //3.拼接sql语句，取出信息</div><div class="line">    $sql = &quot;SELECT * FROM message WHERE id =&quot; . $_GET[&apos;id&apos;];</div><div class="line">    $stmt = $pdo-&gt;query($sql);//返回预处理对象</div><div class="line">    if ($stmt-&gt;rowCount() &gt; 0) &#123;</div><div class="line">        $stu = $stmt-&gt;fetch(PDO::FETCH_ASSOC);//按照关联数组进行解析</div><div class="line">    &#125; else &#123;</div><div class="line">        die(&quot;没有要修改的数据！&quot;);</div><div class="line">    &#125;</div><div class="line">    ?&gt;</div><div class="line">    &lt;form method=&quot;post&quot; action=&quot;action.php?action=edit&quot;&gt;</div><div class="line"></div><div class="line">        &lt;input type=&quot;hidden&quot; name=&quot;id&quot; id=&quot;id&quot; value=&quot;&lt;?php echo $stu[&apos;id&apos;]; ?&gt;&quot;/&gt;</div><div class="line">        &lt;table&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;姓名&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input id=&quot;name&quot; name=&quot;name&quot; type=&quot;text&quot; value=&quot;&lt;?php echo $stu[&apos;name&apos;] ?&gt;&quot;/&gt;&lt;/td&gt;</div><div class="line"></div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;性别&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; &lt;?php echo ($stu[&apos;sex&apos;] == &quot;男&quot;) ? &quot;checked&quot; : &quot;&quot; ?&gt;/&gt; 男</div><div class="line">                    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; &lt;?php echo ($stu[&apos;sex&apos;] == &quot;女&quot;) ? &quot;checked&quot; : &quot;&quot; ?&gt;/&gt; 女</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;年龄&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; id=&quot;age&quot; value=&quot;&lt;?php echo $stu[&apos;age&apos;] ?&gt;&quot;/&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt;班级&lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input id=&quot;classid&quot; name=&quot;classid&quot; type=&quot;text&quot; value=&quot;&lt;?php echo $stu[&apos;classid&apos;] ?&gt;&quot;/&gt;&lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">            &lt;tr&gt;</div><div class="line">                &lt;td&gt; &lt;/td&gt;</div><div class="line">                &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;修改&quot;/&gt;  </div><div class="line">                    &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;</div><div class="line">                &lt;/td&gt;</div><div class="line">            &lt;/tr&gt;</div><div class="line">        &lt;/table&gt;</div><div class="line"></div><div class="line">    &lt;/form&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/center&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><h4 id="action-php"><a href="#action-php" class="headerlink" title="action.php"></a>action.php</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">//1.连接数据库</div><div class="line">try&#123;</div><div class="line">    $pdo = new PDO(&quot;mysql:host=localhost;dbname=test;&quot;,&quot;root&quot;,&quot;&quot;);</div><div class="line">&#125;catch(PDOException $e)&#123;</div><div class="line">    die(&quot;数据库连接失败&quot;.$e-&gt;getMessage());</div><div class="line">&#125;</div><div class="line"></div><div class="line">//2.通过action的值做地应操作</div><div class="line"></div><div class="line">switch($_GET[&apos;action&apos;])&#123;</div><div class="line">    case &quot;add&quot;://增加操作</div><div class="line">        $name = $_POST[&apos;name&apos;];</div><div class="line">        $sex = $_POST[&apos;sex&apos;];</div><div class="line">        $age = $_POST[&apos;age&apos;];</div><div class="line">        $classid = $_POST[&apos;classid&apos;];</div><div class="line"></div><div class="line">        $sql = &quot;insert into message values(null,&apos;&#123;$name&#125;&apos;,&apos;&#123;$sex&#125;&apos;,&apos;&#123;$age&#125;&apos;,&apos;&#123;$classid&#125;&apos;)&quot;;</div><div class="line">        $rw = $pdo-&gt;exec($sql);</div><div class="line">        if($rw &gt; 0)&#123;</div><div class="line">            echo &quot;&lt;script&gt;alert(&apos;增加成功&apos;);window.location=&apos;index.php&apos;&lt;/script&gt;&quot;;</div><div class="line">        &#125;else&#123;</div><div class="line">            echo &quot;&lt;script&gt;alert(&apos;增加失败&apos;);window.history.back();&lt;/script&gt;&quot;;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case &quot;del&quot;; //删除操作</div><div class="line">        $id = $_GET[&apos;id&apos;];</div><div class="line">        $sql = &quot;delete from message where id=&#123;$id&#125;&quot;;</div><div class="line">        $pdo-&gt;exec($sql);</div><div class="line">        header(&quot;Location:index.php&quot;);</div><div class="line">        break;</div><div class="line"></div><div class="line">    case &quot;edit&quot;:</div><div class="line"></div><div class="line">        //1.获取表单信息</div><div class="line">        $name = $_POST[&apos;name&apos;];</div><div class="line">        $sex = $_POST[&apos;sex&apos;];</div><div class="line">        $age = $_POST[&apos;age&apos;];</div><div class="line">        $classid = $_POST[&apos;classid&apos;];</div><div class="line">        $id = $_POST[&apos;id&apos;];</div><div class="line"></div><div class="line">        $sql = &quot;update message set name=&apos;&#123;$name&#125;&apos;,sex=&apos;&#123;$sex&#125;&apos;,age=&#123;$age&#125;,classid=&#123;$classid&#125; where id=&#123;$id&#125;&quot;;</div><div class="line">        $rw = $pdo-&gt;exec($sql);</div><div class="line">        if($rw&gt;0)&#123;</div><div class="line">            echo &quot;&lt;script&gt;alert(&apos;修改成功&apos;);window.location=&apos;index.php&apos;&lt;/script&gt;&quot;;</div><div class="line">        &#125;else&#123;</div><div class="line">           echo &quot;&lt;script&gt;alert(&apos;增加失败&apos;);window.history.back();&lt;/script&gt;&quot;;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– Database: &lt;code&gt;test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;– 表的结构 &lt;code&gt;message&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Github上Fork代码，及源码修改</title>
    <link href="http://yoursite.com/2017/05/15/iOS/Github%E4%B8%8AFork%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%8A%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-/"/>
    <id>http://yoursite.com/2017/05/15/iOS/Github上Fork代码，及源码修改-/</id>
    <published>2017-05-15T07:19:00.000Z</published>
    <updated>2017-10-31T09:41:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中经常遇到这种情况，你使用的第三方库不能完全满足自己项目需要，只能修改源码来解决。<br>我们以前的解决办法是，添加到项目中直接修改源码。这样就有一个问题，不能和源库同步，当作者更新后你不能（pod update）更新，否则自己原来的修改就被冲掉了。所以只能选择不更新，或者更新后重新修改源码。</p><p>当第三方库更新时如何同步更新？Git的Fork功能解决了这种问题，当你fork别人的开源代码后，你可以随意的修改。当然你对自己的修改满意还可以请求合并到（pull request）原作者项目中去。</p><p>今天具体讲解如何在Github上Fork别人的代码，进行二次开发。下面以<strong>iOS-Charts</strong>为例，<a href="http://lvesli.com/2016/06/06/iOS-Charts/" target="_blank" rel="external">上一篇文章</a>中我对这个开源库做了介绍。</p><p>1.首先你要有自己的Github账号<br>2.进入<a href="https://github.com/danielgindi/Charts" target="_blank" rel="external">https://github.com/danielgindi/Charts</a> 你要Fork项目的首页点击右上角Fork<br>3.到自己项目列表就可以看到刚刚Fork的项目了</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-eb564f0a66f08f66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>现在你就可以当做自己的项目，随意的更改了。如果修改完之后你想和原来库合并，贡献自己的代码，就点击自己项目中的“New Pull Request”请求合并。作者同意后就可以在项目中看到自己贡献的代码了。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-e44c5466ea2baf09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面讲解本文的重点，如何修改源码满足自己项目需求。修改时注意一下几点：</p><pre><code>1.改源码首先当然是读懂源码了，读懂后才知道从何下手。2.查看源码时一开始不止如何下手，对于一些UI控件我的解决方式是采用“注释法”，先把不知道的代码注释掉然后运行查看效果，通过对比界面可以简单直接的看到代码在操控那里。3.修改时要考虑如何最小的改动满足自己需求，可以尝试添加子类或者分类的形式解决。4.实在没办法只能修改源码了，修改源码的地方最好做上标记，方便自己查看、修改。</code></pre><p>举个例子，我们想要修改点击Charts高亮时的高亮线的形式，改之前的效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-bdd195925ef6629a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>我们想要隐藏掉水平高亮线，只显示垂直高亮线，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-a9b2f46c390be392.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>通过查看源码我们可以知道<strong>LineChartDateSet</strong>的属性<strong>drawVerticalHighlightIndicatorEnabled</strong>是控制是否显示垂直高亮线的，我们简单推理，通过搜索这个属性我们应该能找到如何绘制高亮线的代码。</p><p>通过全局搜索 <strong>drawVerticalHighlightIndicatorEnabled</strong>结果如下图:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-dc82f7b9a7c9aba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>并没有找到绘制高亮线的代码，查看属性定义的地方发现<strong>drawVerticalHighlightIndicatorEnabled</strong>是存储属性，还有一个对应的计算性属性<strong>isVerticalHighlightIndicatorEnabled</strong>，我们接下来全局搜索<strong>isVerticalHighlightIndicatorEnabled</strong> ,结果如下：</p><p>通过注意查看，我们可以确定<strong>LineScatterCandleRadarChartRenderer.swift</strong>有绘制高亮线的地方，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-929885ec3fe15e82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以发现35-38行是控制如何绘制竖直高亮线的代码，我们注释掉，</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-b4f0c4e929b17c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>换成使用图片来绘制的代码，修改成如下代码（前提准备一张高亮图”highlight_line”）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CGContextSaveGState(context);</div><div class="line">//获得高亮线图片</div><div class="line">let lineImage = NSUIImage(named: &quot;highlight_line&quot;)</div><div class="line">//绘制</div><div class="line">lineImage?.drawInRect(CGRectMake(point.x-5.0/2.0, viewPortHandler.contentTop, 5, viewPortHandler.contentBottom - viewPortHandler.contentTop))</div><div class="line"></div><div class="line">CGContextRestoreGState( context );</div></pre></td></tr></table></figure><p>运行看下效果轻松搞定。</p><p>文章转载自:<a href="http://lvesli.com/?p=184&amp;utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">lvesli</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS开发中经常遇到这种情况，你使用的第三方库不能完全满足自己项目需要，只能修改源码来解决。&lt;br&gt;我们以前的解决办法是，添加到项目中直接修改源码。这样就有一个问题，不能和源库同步，当作者更新后你不能（pod update）更新，否则自己原来的修改就被冲掉了。所以只能选择不
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>动画切换效果之push、pop、present、dismiss</title>
    <link href="http://yoursite.com/2017/05/08/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/%E5%8A%A8%E7%94%BB%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C%E4%B9%8Bpush%E3%80%81pop%E3%80%81present%E3%80%81dismiss/"/>
    <id>http://yoursite.com/2017/05/08/动画与绘图/动画切换效果之push、pop、present、dismiss/</id>
    <published>2017-05-08T02:55:03.000Z</published>
    <updated>2017-10-30T05:48:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候页面跳转或视图切换的时候,需要做成特定的效果,常见的push、pop、present、dismiss效果如下,注意要添加<strong><caanimationdelegate></caanimationdelegate></strong>代理</p><h4 id="push默认动画效果"><a href="#push默认动画效果" class="headerlink" title="push默认动画效果"></a>push默认动画效果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    CATransition *transition = [CATransition animation];</div><div class="line">    transition.duration = 0.3f;</div><div class="line">    transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    transition.type = kCATransitionPush;</div><div class="line">    transition.subtype = kCATransitionFromRight;</div><div class="line">    transition.delegate = self;</div><div class="line">    [self.contentView.layer addAnimation:transition forKey:nil];</div><div class="line">    [self.contentView addSubview:self.productDetailController.view];</div><div class="line"></div><div class="line">```  </div><div class="line">#### pop默认动画效果</div></pre></td></tr></table></figure><pre><code>CATransition *transition = [CATransition animation];transition.duration = 0.3f;transition.timingFunction = [CAMediaTimingFunctionfunctionWithName:kCAMediaTimingFunctionEaseInEaseOut];transition.type = kCATransitionPush;transition.subtype = kCATransitionFromLeft;transition.delegate = self;[self.view.superview.layer addAnimation:transition forKey:nil];[self.view removeFromSuperview];</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### present默认动画效果</div></pre></td></tr></table></figure><pre><code>CATransition *transition = [CATransition animation];transition.duration = 0.4f;transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];transition.type = kCATransitionMoveIn;transition.subtype = kCATransitionFromTop;transition.delegate = self;[[self currentNavigationController].view.layer addAnimation:transition forKey:nil];[[self currentNavigationController] pushViewController:playVC animated:NO];</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#### dismiss默认动画效果</div></pre></td></tr></table></figure><pre><code>CATransition *transition = [CATransition animation];transition.duration = 0.3f;transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];transition.type = kCATransitionReveal;transition.subtype = kCATransitionFromBottom;transition.delegate = self;[self.navigationController.view.layer addAnimation:transition forKey:nil];[self.navigationController popViewControllerAnimated:NO];</code></pre><p>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候页面跳转或视图切换的时候,需要做成特定的效果,常见的push、pop、present、dismiss效果如下,注意要添加&lt;strong&gt;&lt;caanimationdelegate&gt;&lt;/caanimationdelegate&gt;&lt;/strong&gt;代理&lt;/p&gt;
&lt;h4 id=
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="动画与绘图" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BB%98%E5%9B%BE/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP笔记</title>
    <link href="http://yoursite.com/2017/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/04/07/计算机网络/HTTP笔记/</id>
    <published>2017-04-07T06:47:00.000Z</published>
    <updated>2017-10-30T05:51:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>“你知道当我们在网页浏览器（Web browser）的地址栏中输入 URL 时，Web 页面是如何呈现的吗？”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-48cf5d50116ffd8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="过程.png"></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议（HyperText Transfer Protocol）即超文本传输协议是用于服务器传输到客户端浏览器的传输协议。Web上，服务器和客户端利用HTTP协议进行通信会话。</p><p>在Web上，HTTP协议使用TCP协议而不是UDP协议的原因在于一个网页必须传送很多数据，而且保证其完整性。TCP协议提供传输控制，按顺序组织数据和错误纠正的一系列功能。</p><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><pre><code>1、客户端与服务器需要建立连接。（比如某个超级链接，HTTP就开始了。）2、建立连接后，发送请求。3、服务器接到请求后，响应其响应信息。4、客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</code></pre><p>忽略掉连接过程是这样的:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-058c281b84838c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作过程.png"></p><h3 id="URI、URL与RFC"><a href="#URI、URL与RFC" class="headerlink" title="URI、URL与RFC"></a>URI、URL与RFC</h3><p>先看看官方的解释：<br>URI：uniform resource identifier 统一资源标识符<br>URL：uniform resource location 统一资源定位符</p><p>URI用字符串标识某一互联网资源，而URL表示资源的地点。可见URL是URI的子集。</p><p>URI要使用涵盖全部必要信息的URI、绝对URL以及相对URL。相对URL是指从浏览器中基本URI处理的URL，来先看下URI的格式:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-eb2b672fed8c4be9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="URI格式.png"></p><p>RFC：reqeust for comments 征求修正意见书<br>RFC素有网络知识圣经之称，规定了网络中协议的基本内容。因此许多的不同系统的应用程序才可以互相访问。</p><h3 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h3><p>请求行-请求方法</p><ul><li>GET            获取资源</li><li>POST          传输实体主体</li><li>PUT            传输文件</li><li>HEAD         获取报文首部</li><li>DELETE     删除文件</li><li>OPTIONS   请求查询服务器的性能，或者查询与资源相关的选项和需求 </li><li>TRACE        请求服务器回送收到的请求信息，主要用于测试或诊断</li><li>CONNECT  要求用隧道协议连接代理(SSL：Secure Sockets Layer安全套接层，TLS：Transport Layer Security传输层安全)</li></ul><h3 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h3><p><a href="https://segmentfault.com/a/1190000004014583" target="_blank" rel="external">看别人总结的吧</a><br><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external">还有这篇</a></p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-94b9b3e85b4abde1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="状态码类别.png"></p><p>常见的状态码</p><pre><code>200 OK请求成功（其后是对GET和POST请求的应答文档。）304 Not Modified未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。404 Not Found服务器无法找到被请求的页面。500 Internal Server Error请求未完成。服务器遇到不可预知的情况。</code></pre><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。</p><p>请求我博客园首页时发送的报文内容:</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-2e62214fed2f76cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报文.png"></p><p>　其中最常使用的属性是：</p><ul><li>URL, 即http访问的地址</li><li>request method, 报文的请求方式</li><li>Remote Address,远程地址</li><li>status code, 状态码以及状态短语</li><li>Connection, 连接方式</li><li>Content-Type头：便是接收方实体的介质类型。</li><li>Accept Encoding, 内容编码</li><li>Date头域：时间描述</li><li>Referer头域：允许客户端指定请求URL的资源地址。</li><li>Cookie, 添加的cookie内容</li><li>Host, 目标主机</li><li>User-Agent, 客户端浏览器的相关信息</li><li>Set-Cookie, 指定想要在Cookie中保存的内容</li></ul><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>“HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-cf9c8252e3979368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通信一次断开一次.png"></p><p>“为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-4e13a9ac5f083e57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="持久连接.png"></p><p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。<br>在 HTTP/1.1 中，所有的连接默认都是持久连接</p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>“持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p><p>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。”</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-5f1fa307c9c4ca54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-16 下午3.41.33.png"></p><p>比如，当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。</p><h3 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h3><p>由于某些报文的内容过大，因此在传输时，为了减少传输的时间，会采取一些压缩的措施。</p><p>例如上面的报文信息中，Accept-Encoding就定义了内容编码的格式：gzip,deflate</p><p>有下面几种方式：</p><ul><li>gzip：GNU压缩格式</li><li>compress：UNIX系统的标准压缩格式</li><li>deflate：是一种同时使用了LZ77和哈弗曼编码的无损压缩格式</li><li>identity：不进行压缩</li></ul><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p><p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。</p><p>对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-0a2a457a44dd55e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-03-16 下午4.13.32.png"></p><p>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。</p><p>byte 范围的指定形式如下。</p><ul><li><p>5001~10 000 字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=5001-10000</div></pre></td></tr></table></figure></li><li><p>从 5001 字节之后全部的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=5001-</div></pre></td></tr></table></figure></li><li><p>从一开始到 3000 字节和 5000~7000 字节的多重范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Range: bytes=-3000, 5000-7000</div></pre></td></tr></table></figure></li></ul><p>针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</p><p>如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。”</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</p><p>假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。</p><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><p>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-89c6414d2822a545.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Cookie.png"></p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP 主要有这些不足，例举如下。</p><ul><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改”</li></ul><p>这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题。</p><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p><p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-f647e66bc61d89e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SSL.png"></p><p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。</p><p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-aec3c3a7c56e95da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTPS通信.png"></p><p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p><p>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p><p>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p><p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p><p>步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p><p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p><p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p><p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p><p>步骤 9： 服务器同样发送 Finished 报文。</p><p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p><p>步骤 11： 应用层协议通信，即发送 HTTP 响应。</p><p>步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p><p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><h3 id="HTTP认证"><a href="#HTTP认证" class="headerlink" title="HTTP认证"></a>HTTP认证</h3><p>　　有一些网址或者服务需要用户的身份信息，因此需要随时知道这些消息，但是肯定不能每次都让用户输入用户密码，因此关于认证就有下面几种方式：</p><p><img src="http://upload-images.jianshu.io/upload_images/1868951-7742dd7b79eca737.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="032135393488858.jpeg"></p><p>其中BASIC认证是最简单的认证，大致过程如下：<br>1 、客户端访问某URL。<br>2 、服务器端返回401状态码，提示用户输入用户名密码。<br>3 、用户输入用户名密码，通过BASE64编码传输。<br>4 、服务器通过认证，返回状态码200</p><p>通过上面的过程，就可以发现BASIC的问题：</p><ul><li>仅仅通过BASE64编码，其实还是属于明文传输，安全性不高</li><li>有的浏览器不支持注销</li></ul><p>鉴于上面BASIC的问题，DIGEST做了补充，它的过程与上面类似：<br>1 、客户端访问<br>2 、服务器端返回质询码<br>3 、客户端发送响应码</p><p>这里通过随机的生成质询码来作为计算的一种方式，客户端依据这个质询码生成响应码，进行验证。<br>这样就弥补了明文传输用户密码的风险。</p><p>SSL客户端验证，这个比较普遍了！</p><p>像支付宝啊，邮政网银啊之类的，在登录时，都需要下载一个数字认证的东西，这个东西就属于一种SSL客户端的验证。</p><p>很显然它的缺点就是需要客户去手动的安装，这个对于一般的用户来说，代价有点高。</p><p>最后一种是应用最普遍的，通过表单记录用户的身份信息，可以使用cookie或者session的方式保存用户信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“你知道当我们在网页浏览器（Web browser）的地址栏中输入 URL 时，Web 页面是如何呈现的吗？”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1868951-48cf5d5011
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
